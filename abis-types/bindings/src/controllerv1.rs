/**

Generated by the following Solidity interface...
```solidity
interface ControllerV1 {
    type StoreKey is bytes27;
    struct Asset {
        address addr;
        uint256 total;
        Distribution[] dists;
    }
    struct Distribution {
        address to;
        uint256 amount;
    }
    struct PoolUpdate {
        address assetA;
        address assetB;
        uint24 bundleFee;
        uint24 unlockedFee;
        uint24 protocolUnlockedFee;
    }

    error AlreadyInitialized();
    error AlreadyNode();
    error FeeAboveMax();
    error FunctionDisabled();
    error KeyNotFound();
    error NewOwnerIsZeroAddress();
    error NoEntry();
    error NoHandoverRequest();
    error NonexistentPool(address asset0, address asset1);
    error NotNode();
    error NotNodeOrOwner();
    error NotSetController();
    error TotalNotDistributed();
    error Unauthorized();

    event NewControllerAccepted(address indexed newController);
    event NewControllerSet(address indexed newController);
    event NodeAdded(address indexed node);
    event NodeRemoved(address indexed node);
    event OpaqueBatchPoolUpdate();
    event OwnershipHandoverCanceled(address indexed pendingOwner);
    event OwnershipHandoverRequested(address indexed pendingOwner);
    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);
    event PoolConfigured(address indexed asset0, address indexed asset1, uint16 tickSpacing, uint24 bundleFee, uint24 unlockedFee, uint24 protocolUnlockedFee);
    event PoolRemoved(address indexed asset0, address indexed asset1, int24 tickSpacing, uint24 feeInE6);

    constructor(address angstrom, address initialOwner, address _fastOwner);

    function ANGSTROM() external view returns (address);
    function acceptNewController() external;
    function addNode(address node) external;
    function batchUpdatePools(PoolUpdate[] memory updates) external;
    function cancelOwnershipHandover() external payable;
    function collect_unlock_swap_fees(address to, bytes memory packed_assets) external;
    function completeOwnershipHandover(address pendingOwner) external payable;
    function configurePool(address asset0, address asset1, uint16 tickSpacing, uint24 bundleFee, uint24 unlockedFee, uint24 protocolUnlockedFee) external;
    function distributeFees(Asset[] memory assets) external;
    function fastOwner() external view returns (address);
    function getPoolByIndex(uint256 index) external view returns (address asset0, address asset1);
    function getPoolByKey(StoreKey key) external view returns (address asset0, address asset1);
    function initStartNodes(address[] memory initNodes) external;
    function keyExists(StoreKey key) external view returns (bool);
    function nodes() external view returns (address[] memory);
    function owner() external view returns (address result);
    function ownershipHandoverExpiresAt(address pendingOwner) external view returns (uint256 result);
    function removeNode(address node) external;
    function removePool(address asset0, address asset1) external;
    function renounceOwnership() external payable;
    function requestOwnershipHandover() external payable;
    function setController() external view returns (address);
    function setNewController(address newController) external;
    function totalNodes() external view returns (uint256);
    function totalPools() external view returns (uint256);
    function transferOwnership(address) external payable;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "angstrom",
        "type": "address",
        "internalType": "contract IAngstromAuth"
      },
      {
        "name": "initialOwner",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_fastOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "ANGSTROM",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IAngstromAuth"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "acceptNewController",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "addNode",
    "inputs": [
      {
        "name": "node",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "batchUpdatePools",
    "inputs": [
      {
        "name": "updates",
        "type": "tuple[]",
        "internalType": "struct ControllerV1.PoolUpdate[]",
        "components": [
          {
            "name": "assetA",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "assetB",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "bundleFee",
            "type": "uint24",
            "internalType": "uint24"
          },
          {
            "name": "unlockedFee",
            "type": "uint24",
            "internalType": "uint24"
          },
          {
            "name": "protocolUnlockedFee",
            "type": "uint24",
            "internalType": "uint24"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "cancelOwnershipHandover",
    "inputs": [],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "collect_unlock_swap_fees",
    "inputs": [
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "packed_assets",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "completeOwnershipHandover",
    "inputs": [
      {
        "name": "pendingOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "configurePool",
    "inputs": [
      {
        "name": "asset0",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "asset1",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "tickSpacing",
        "type": "uint16",
        "internalType": "uint16"
      },
      {
        "name": "bundleFee",
        "type": "uint24",
        "internalType": "uint24"
      },
      {
        "name": "unlockedFee",
        "type": "uint24",
        "internalType": "uint24"
      },
      {
        "name": "protocolUnlockedFee",
        "type": "uint24",
        "internalType": "uint24"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "distributeFees",
    "inputs": [
      {
        "name": "assets",
        "type": "tuple[]",
        "internalType": "struct Asset[]",
        "components": [
          {
            "name": "addr",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "total",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "dists",
            "type": "tuple[]",
            "internalType": "struct Distribution[]",
            "components": [
              {
                "name": "to",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fastOwner",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPoolByIndex",
    "inputs": [
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "asset0",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "asset1",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPoolByKey",
    "inputs": [
      {
        "name": "key",
        "type": "bytes27",
        "internalType": "StoreKey"
      }
    ],
    "outputs": [
      {
        "name": "asset0",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "asset1",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "initStartNodes",
    "inputs": [
      {
        "name": "initNodes",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "keyExists",
    "inputs": [
      {
        "name": "key",
        "type": "bytes27",
        "internalType": "StoreKey"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "nodes",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "owner",
    "inputs": [],
    "outputs": [
      {
        "name": "result",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "ownershipHandoverExpiresAt",
    "inputs": [
      {
        "name": "pendingOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "removeNode",
    "inputs": [
      {
        "name": "node",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "removePool",
    "inputs": [
      {
        "name": "asset0",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "asset1",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "renounceOwnership",
    "inputs": [],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "requestOwnershipHandover",
    "inputs": [],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "setController",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "setNewController",
    "inputs": [
      {
        "name": "newController",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "totalNodes",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "totalPools",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "transferOwnership",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "event",
    "name": "NewControllerAccepted",
    "inputs": [
      {
        "name": "newController",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "NewControllerSet",
    "inputs": [
      {
        "name": "newController",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "NodeAdded",
    "inputs": [
      {
        "name": "node",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "NodeRemoved",
    "inputs": [
      {
        "name": "node",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OpaqueBatchPoolUpdate",
    "inputs": [],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnershipHandoverCanceled",
    "inputs": [
      {
        "name": "pendingOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnershipHandoverRequested",
    "inputs": [
      {
        "name": "pendingOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnershipTransferred",
    "inputs": [
      {
        "name": "oldOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "PoolConfigured",
    "inputs": [
      {
        "name": "asset0",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "asset1",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "tickSpacing",
        "type": "uint16",
        "indexed": false,
        "internalType": "uint16"
      },
      {
        "name": "bundleFee",
        "type": "uint24",
        "indexed": false,
        "internalType": "uint24"
      },
      {
        "name": "unlockedFee",
        "type": "uint24",
        "indexed": false,
        "internalType": "uint24"
      },
      {
        "name": "protocolUnlockedFee",
        "type": "uint24",
        "indexed": false,
        "internalType": "uint24"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "PoolRemoved",
    "inputs": [
      {
        "name": "asset0",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "asset1",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "tickSpacing",
        "type": "int24",
        "indexed": false,
        "internalType": "int24"
      },
      {
        "name": "feeInE6",
        "type": "uint24",
        "indexed": false,
        "internalType": "uint24"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AlreadyInitialized",
    "inputs": []
  },
  {
    "type": "error",
    "name": "AlreadyNode",
    "inputs": []
  },
  {
    "type": "error",
    "name": "FeeAboveMax",
    "inputs": []
  },
  {
    "type": "error",
    "name": "FunctionDisabled",
    "inputs": []
  },
  {
    "type": "error",
    "name": "KeyNotFound",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NewOwnerIsZeroAddress",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NoEntry",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NoHandoverRequest",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NonexistentPool",
    "inputs": [
      {
        "name": "asset0",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "asset1",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotNode",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotNodeOrOwner",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotSetController",
    "inputs": []
  },
  {
    "type": "error",
    "name": "TotalNotDistributed",
    "inputs": []
  },
  {
    "type": "error",
    "name": "Unauthorized",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod ControllerV1 {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60c060405234801561000f575f80fd5b50604051612a91380380612a9183398101604081905261002e916100a1565b61003782610051565b6001600160a01b0392831660805290911660a052506100eb565b6001600160a01b0316638b78c6d819819055805f7f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08180a35b50565b6001600160a01b038116811461008a575f80fd5b5f805f606084860312156100b3575f80fd5b83516100be8161008d565b60208501519093506100cf8161008d565b60408501519092506100e08161008d565b809150509250925092565b60805160a0516129386101595f395f8181610279015281816119790152611ab401525f81816104e10152818161082d015281816108e601528181610b0c01528181610e4a01528181610ec4015281816114490152818161159a015281816118fa0152611d8c01526129385ff3fe608060405260043610610199575f3560e01c8063744b92e2116100dc578063ab3c7e5211610087578063f2fde38b11610062578063f2fde38b146104bd578063f8098f38146104d0578063f86ad98a14610503578063fee81cf414610517575f80fd5b8063ab3c7e5214610477578063b2b99ec91461048b578063f04e283e146104aa575f80fd5b80638da5cb5b116100b75780638da5cb5b146104035780639592d424146104365780639d95f1cc14610458575f80fd5b8063744b92e21461039a57806377e2bf8a146103b95780638b2704ec146103d8575f80fd5b80634d2bf47c116101475780635c1b182d116101225780635c1b182d146103065780635db82fa0146103255780636ce0c4b514610346578063715018a614610392575f80fd5b80634d2bf47c146102c057806354d1f13d146102df57806359baef40146102e7575f80fd5b806329adecf61161017757806329adecf6146101e557806333830e481461024957806343a9a71f14610268575f80fd5b8063138714651461019d578063182e6f39146101be57806325692962146101dd575b5f80fd5b3480156101a8575f80fd5b506101bc6101b73660046122b2565b610548565b005b3480156101c9575f80fd5b506101bc6101d836600461232a565b61088e565b6101bc610a7a565b3480156101f0575f80fd5b506102346101ff36600461239b565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffff0000000000165f90815260036020526040902054151590565b60405190151581526020015b60405180910390f35b348015610254575f80fd5b506101bc6102633660046123e1565b610ac7565b348015610273575f80fd5b5061029b7f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff9091168152602001610240565b3480156102cb575f80fd5b506101bc6102da36600461245f565b610b77565b6101bc610f2e565b3480156102f2575f80fd5b506101bc6103013660046124c0565b610f67565b348015610311575f80fd5b506101bc610320366004612506565b610fdb565b348015610330575f80fd5b506103396110dc565b60405161024091906125ef565b348015610351575f80fd5b50610365610360366004612647565b6110ed565b6040805173ffffffffffffffffffffffffffffffffffffffff938416815292909116602083015201610240565b6101bc61113d565b3480156103a5575f80fd5b506101bc6103b436600461265e565b61116f565b3480156103c4575f80fd5b506103656103d336600461239b565b6115fc565b3480156103e3575f80fd5b505f5461029b9073ffffffffffffffffffffffffffffffffffffffff1681565b34801561040e575f80fd5b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffff748739275461029b565b348015610441575f80fd5b5061044a6116c1565b604051908152602001610240565b348015610463575f80fd5b506101bc6104723660046124c0565b6116cc565b348015610482575f80fd5b5060025461044a565b348015610496575f80fd5b506101bc6104a53660046124c0565b611761565b6101bc6104b83660046124c0565b6117f3565b6101bc6104cb3660046124c0565b61113d565b3480156104db575f80fd5b5061029b7f000000000000000000000000000000000000000000000000000000000000000081565b34801561050e575f80fd5b506101bc61182d565b348015610522575f80fd5b5061044a6105313660046124c0565b63389a75e1600c9081525f91909152602090205490565b610550611962565b6127108362ffffff161115610591576040517f76a3f95d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6127108262ffffff1611156105d2576040517f76a3f95d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8473ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff16111561060a579394935b5f86815260208690526040812060281b7fffffffffffffffffffffffffffffffffffffffffffffffffffffff000000000081165f9081526003602052604081205491925081900361074d575060408051808201825273ffffffffffffffffffffffffffffffffffffffff808a1682528881166020808401918252600280546001810182555f82815295519082027f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace810180549287167fffffffffffffffffffffffff000000000000000000000000000000000000000093841617905593517f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5acf909401805494909516931692909217909255547fffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000008516835260039091529190208190555b6040805161ffff8816815262ffffff87811660208301528681168284015285166060820152905173ffffffffffffffffffffffffffffffffffffffff89811692908b16917ff325a037d71efc98bc41dc5257edefd43a1d1162e206373e53af271a7a3224e99181900360800190a36040517f1387146500000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8981166004830152888116602483015261ffff8816604483015262ffffff80881660648401528087166084840152851660a48301527f0000000000000000000000000000000000000000000000000000000000000000169063138714659060c4015f604051808303815f87803b15801561086e575f80fd5b505af1158015610880573d5f803e3d5ffd5b505050505050505050505050565b610896611a13565b805f5b81811015610a7457368484838181106108b4576108b461268f565b90506020028101906108c691906126bc565b90506020810180359073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000169063d9e17f989061091790856124c0565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b16815273ffffffffffffffffffffffffffffffffffffffff9091166004820152602481018490526044015f604051808303815f87803b158015610981575f80fd5b505af1158015610993573d5f803e3d5ffd5b505050505f5b6109a660408401846126f8565b9050811015610a3157366109bd60408501856126f8565b838181106109cd576109cd61268f565b604002919091019150610a1890506109e860208301836124c0565b602080840135906109fb908801886124c0565b73ffffffffffffffffffffffffffffffffffffffff169190611a4a565b610a26602082013584612763565b925050600101610999565b508015610a6a576040517fb21c63eb00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5050600101610899565b50505050565b5f6202a30067ffffffffffffffff164201905063389a75e1600c52335f52806020600c2055337fdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d5f80a250565b610acf611962565b6040517f33830e4800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016906333830e4890610b45908690869086906004016127a1565b5f604051808303815f87803b158015610b5c575f80fd5b505af1158015610b6e573d5f803e3d5ffd5b50505050505050565b610b7f611a9d565b5f8167ffffffffffffffff811115610b9957610b996124d9565b604051908082528060200260200182016040528015610c0f57816020015b6040805160a0810182525f808252602080830182905292820181905260608201819052608082015282527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff909201910181610bb75790505b5090505f5b82811015610e1b5736848483818110610c2f57610c2f61268f565b905060a002019050612710816040016020810190610c4d919061280a565b62ffffff161115610c8a576040517f76a3f95d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b612710610c9d608083016060840161280a565b62ffffff161115610cda576040517f76a3f95d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f80610ce960208401846124c0565b610cf960408501602086016124c0565b915091508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161115610d3357905b5f82815260208281526040808320815160a0810183527fffffffffffffffffffffffffffffffffffffffffffffffffffffff000000000060289290921b918216855260039093529220548190610d8b90600190612763565b81526020018264ffffffffff19168152602001856040016020810190610db1919061280a565b62ffffff168152602001610dcb608087016060880161280a565b62ffffff168152602001610de560a087016080880161280a565b62ffffff16815250868681518110610dff57610dff61268f565b6020026020010181905250505050508080600101915050610c14565b506040517fc93f1add41c218fa7665c10617033f441f8e3c16fa372796265445d7a1497c23905f90a15f610e847f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16611aee565b6040517f53b41c5500000000000000000000000000000000000000000000000000000000815290915073ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016906353b41c5590610efb9084908690600401612823565b5f604051808303815f87803b158015610f12575f80fd5b505af1158015610f24573d5f803e3d5ffd5b5050505050505050565b63389a75e1600c52335f525f6020600c2055337ffa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c925f80a2565b610f6f611a13565b5f80547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff8316908117825560405190917fcbcf384e26c16836177d0b6d8ce70541a86ff3091deecaf5b6e0fa5564c7825091a250565b60045460ff1615610fe95750565b600480547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001660011790555f5b81518110156110d8575f8282815181106110325761103261268f565b60200260200101519050611050816001611b8990919063ffffffff16565b611086576040517fef6f523600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61108f81611d0d565b60405173ffffffffffffffffffffffffffffffffffffffff8216907fb25d03aaf308d7291709be1ea28b800463cf3a9a4c4a5555d7333a964c1dfebd905f90a250600101611016565b5050565b60606110e86001611df4565b905090565b5f805f600284815481106111035761110361268f565b5f9182526020909120600290910201805460019091015473ffffffffffffffffffffffffffffffffffffffff918216969116945092505050565b6040517fbf24148800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b611177611a13565b8073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1611156111ad57905b5f82815260208290526040812060281b7fffffffffffffffffffffffffffffffffffffffffffffffffffffff000000000081165f9081526003602052604081205491925081900361124e576040517f02f51b3100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff80861660048301528416602482015260440160405180910390fd5b6002547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82019080831015611399575f600260018303815481106112945761129461268f565b5f9182526020808320604080518082018252600294909402909101805473ffffffffffffffffffffffffffffffffffffffff90811680865260019092015416848401819052908552909152822090925060281b905081600285815481106112fd576112fd61268f565b5f91825260208083208451600290930201805473ffffffffffffffffffffffffffffffffffffffff9384167fffffffffffffffffffffffff000000000000000000000000000000000000000091821617825594820151600190910180549190931694169390931790557fffffffffffffffffffffffffffffffffffffffffffffffffffffff000000000090921682526003905260409020849055505b7fffffffffffffffffffffffffffffffffffffffffffffffffffffff000000000084165f9081526003602052604081205560028054806113db576113db6128e7565b5f8281526020812060027fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9093019283020180547fffffffffffffffffffffffff000000000000000000000000000000000000000090811682556001919091018054909116905591556114837f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16611aee565b90505f806114a873ffffffffffffffffffffffffffffffffffffffff84168887611ec8565b915091508773ffffffffffffffffffffffffffffffffffffffff168973ffffffffffffffffffffffffffffffffffffffff167f79f612570217c00df128c1b828dd6b321b3a70ae4c61b7a97fe4a71fc19df9ba848460405161151e92919060029290920b825262ffffff16602082015260400190565b60405180910390a36040517fdd4d4cf60000000000000000000000000000000000000000000000000000000081527fffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000008816600482015273ffffffffffffffffffffffffffffffffffffffff8481166024830152604482018790527f0000000000000000000000000000000000000000000000000000000000000000169063dd4d4cf6906064015f604051808303815f87803b1580156115db575f80fd5b505af11580156115ed573d5f803e3d5ffd5b50505050505050505050505050565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffff000000000081165f908152600360205260408120548190808203611668576040517f5f3f479c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f6002611676600184612763565b815481106116865761168661268f565b5f9182526020909120600290910201805460019091015473ffffffffffffffffffffffffffffffffffffffff91821697911695509350505050565b5f6110e86001611f3f565b6116d4611a13565b6116df600182611b89565b611715576040517fef6f523600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60405173ffffffffffffffffffffffffffffffffffffffff8216907fb25d03aaf308d7291709be1ea28b800463cf3a9a4c4a5555d7333a964c1dfebd905f90a261175e81611d0d565b50565b611769611962565b611774600182611f90565b6117aa576040517f5cd26b6800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60405173ffffffffffffffffffffffffffffffffffffffff8216907fcfc24166db4bb677e857cacabd1541fb2b30645021b27c5130419589b84db52b905f90a261175e81611d0d565b6117fb611a13565b63389a75e1600c52805f526020600c20805442111561182157636f5e88185f526004601cfd5b5f905561175e81612104565b5f5473ffffffffffffffffffffffffffffffffffffffff16331461187d576040517fb0634a7600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f80547fffffffffffffffffffffffff000000000000000000000000000000000000000016815560405133917fab258afbe9ebb963a1baeadbb7265f37c95f67b6ca707ab7f56268bcb7d291c891a26040517f92eefe9b0000000000000000000000000000000000000000000000000000000081523360048201527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16906392eefe9b906024015f604051808303815f87803b158015611950575f80fd5b505af1158015610a74573d5f803e3d5ffd5b73ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001633036119a157565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffff748739275473ffffffffffffffffffffffffffffffffffffffff1633036119e157565b6040517f29ab190d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927543314611a48576382b429005f526004601cfd5b565b81601452806034526fa9059cbb0000000000000000000000005f5260205f604460105f875af18060015f511416611a9357803d853b151710611a93576390b8ec185f526004601cfd5b505f603452505050565b73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163303611adc57565b611ae7600133612169565b156119a157565b6040517f7cf98081000000000000000000000000000000000000000000000000000000008152600360048201525f90819073ffffffffffffffffffffffffffffffffffffffff841690637cf9808190602401602060405180830381865afa158015611b5b573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611b7f9190612914565b60401c9392505050565b63978aab926004525f8281526024812073ffffffffffffffffffffffffffffffffffffffff92909216917fffffffffffffffffffffffffffffffffffffffffffffff04498025ad2b4047418301611be75763f5a267f15f526004601cfd5b82611bf95768fbb67fda52d4bfb8bf92505b80546bffffffffffffffffffffffff81168260205280611cc0578160601c80611c2c578560601b84556001945050611d04565b858103611c395750611d04565b600184015460601c80611c5a578660601b6001860155600195505050611d04565b868103611c68575050611d04565b600285015460601c80611c8a578760601b600287015560019650505050611d04565b878103611c9957505050611d04565b5f928352604080842060019055918352818320600290558252902060039055506007908117905b845f5260405f208054611d0257600191821c808301825591945081611cee578560601b600317845550611d04565b8560601b8285015582600201845550611d04565b505b50505092915050565b6040805160018082528183019092525f916020808301908036833701905050905081815f81518110611d4157611d4161268f565b73ffffffffffffffffffffffffffffffffffffffff92831660209182029290920101526040517fd6cffd1e0000000000000000000000000000000000000000000000000000000081527f00000000000000000000000000000000000000000000000000000000000000009091169063d6cffd1e90611dc39084906004016125ef565b5f604051808303815f87803b158015611dda575f80fd5b505af1158015611dec573d5f803e3d5ffd5b505050505050565b63978aab926004525f818152602481206060915068fbb67fda52d4bfb8bf81548060a01b60a01c6040519450846020018260601c9250838314158302815281611e82578215611e7d57600191508185015460601c92508215611e7d578284141590920260208301525060028381015460601c918215611e7d576003915083831415830260408201525b611eb2565b600191821c915b82811015611eb0578581015460601c858114158102600583901b8401529350600101611e89565b505b8186528160051b81016040525050505050919050565b5f8080611eec73ffffffffffffffffffffffffffffffffffffffff8716868661223a565b905080611f25576040517f2f659e4400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61ffff601882901c169662ffffff90911695509350505050565b63978aab926004525f8181526024812080548060a01b60a01c8060011c9350808260601c1517611f8857600193508383015415611f8857600293508383015415611f8857600393505b505050919050565b63978aab926004525f8281526024812073ffffffffffffffffffffffffffffffffffffffff92909216917fffffffffffffffffffffffffffffffffffffffffffffff04498025ad2b4047418301611fee5763f5a267f15f526004601cfd5b826120005768fbb67fda52d4bfb8bf92505b80546bffffffffffffffffffffffff81168061207f5760019350848260601c0361203d5760018301805484556002840180549091555f9055611d04565b84600184015460601c0361205e5760028301805460018501555f9055611d04565b84600284015460601c03612077575f6002840155611d04565b5f9350611d04565b82602052845f5260405f20805480612098575050611d04565b60018360011c0392508260018203146120c8578285015460601c8060601b60018303870155805f52508060405f20555b5083547fffffffffffffffffffffffffffffffffffffffff00000000000000000000000016600192831b1782179093555f909255509392505050565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927805473ffffffffffffffffffffffffffffffffffffffff9092169182907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a355565b63978aab926004525f8281526024812073ffffffffffffffffffffffffffffffffffffffff92909216917fffffffffffffffffffffffffffffffffffffffffffffff04498025ad2b40474183016121c75763f5a267f15f526004601cfd5b826121d95768fbb67fda52d4bfb8bf92505b80546bffffffffffffffffffffffff81166122215760019250838160601c031561223257600182015460601c841461223257600282015460601c8414612232575f9250612232565b81602052835f5260405f2054151592505b505092915050565b5f6020826020026001015f863c50505f517fffffffffffffffffffffffffffffffffffffffffffffffffffffff000000000081169190911402919050565b803573ffffffffffffffffffffffffffffffffffffffff8116811461229b575f80fd5b919050565b803562ffffff8116811461229b575f80fd5b5f805f805f8060c087890312156122c7575f80fd5b6122d087612278565b95506122de60208801612278565b9450604087013561ffff811681146122f4575f80fd5b9350612302606088016122a0565b9250612310608088016122a0565b915061231e60a088016122a0565b90509295509295509295565b5f806020838503121561233b575f80fd5b823567ffffffffffffffff811115612351575f80fd5b8301601f81018513612361575f80fd5b803567ffffffffffffffff811115612377575f80fd5b8560208260051b840101111561238b575f80fd5b6020919091019590945092505050565b5f602082840312156123ab575f80fd5b81357fffffffffffffffffffffffffffffffffffffffffffffffffffffff0000000000811681146123da575f80fd5b9392505050565b5f805f604084860312156123f3575f80fd5b6123fc84612278565b9250602084013567ffffffffffffffff811115612417575f80fd5b8401601f81018613612427575f80fd5b803567ffffffffffffffff81111561243d575f80fd5b86602082840101111561244e575f80fd5b939660209190910195509293505050565b5f8060208385031215612470575f80fd5b823567ffffffffffffffff811115612486575f80fd5b8301601f81018513612496575f80fd5b803567ffffffffffffffff8111156124ac575f80fd5b85602060a08302840101111561238b575f80fd5b5f602082840312156124d0575f80fd5b6123da82612278565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b5f60208284031215612516575f80fd5b813567ffffffffffffffff81111561252c575f80fd5b8201601f8101841361253c575f80fd5b803567ffffffffffffffff811115612556576125566124d9565b8060051b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0603f830116810181811067ffffffffffffffff821117156125a1576125a16124d9565b6040529182526020818401810192908101878411156125be575f80fd5b6020850194505b838510156125e4576125d685612278565b8152602094850194016125c5565b509695505050505050565b602080825282518282018190525f918401906040840190835b8181101561263c57835173ffffffffffffffffffffffffffffffffffffffff16835260209384019390920191600101612608565b509095945050505050565b5f60208284031215612657575f80fd5b5035919050565b5f806040838503121561266f575f80fd5b61267883612278565b915061268660208401612278565b90509250929050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f82357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa18336030181126126ee575f80fd5b9190910192915050565b5f8083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe184360301811261272b575f80fd5b83018035915067ffffffffffffffff821115612745575f80fd5b6020019150600681901b360382131561275c575f80fd5b9250929050565b8181038181111561279b577f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b92915050565b73ffffffffffffffffffffffffffffffffffffffff8416815260406020820152816040820152818360608301375f818301606090810191909152601f9092017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016010192915050565b5f6020828403121561281a575f80fd5b6123da826122a0565b5f6040820173ffffffffffffffffffffffffffffffffffffffff85168352604060208401528084518083526060850191506020860192505f5b818110156128db578351805184527fffffffffffffffffffffffffffffffffffffffffffffffffffffff0000000000602082015116602085015262ffffff604082015116604085015262ffffff606082015116606085015262ffffff60808201511660808501525060a08301925060208401935060018101905061285c565b50909695505050505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603160045260245ffd5b5f60208284031215612924575f80fd5b505191905056fea164736f6c634300081a000a
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xC0`@R4\x80\x15a\0\x0FW_\x80\xFD[P`@Qa*\x918\x03\x80a*\x91\x839\x81\x01`@\x81\x90Ra\0.\x91a\0\xA1V[a\x007\x82a\0QV[`\x01`\x01`\xA0\x1B\x03\x92\x83\x16`\x80R\x90\x91\x16`\xA0RPa\0\xEBV[`\x01`\x01`\xA0\x1B\x03\x16c\x8Bx\xC6\xD8\x19\x81\x90U\x80_\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0\x81\x80\xA3[PV[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\0\x8AW_\x80\xFD[_\x80_``\x84\x86\x03\x12\x15a\0\xB3W_\x80\xFD[\x83Qa\0\xBE\x81a\0\x8DV[` \x85\x01Q\x90\x93Pa\0\xCF\x81a\0\x8DV[`@\x85\x01Q\x90\x92Pa\0\xE0\x81a\0\x8DV[\x80\x91PP\x92P\x92P\x92V[`\x80Q`\xA0Qa)8a\x01Y_9_\x81\x81a\x02y\x01R\x81\x81a\x19y\x01Ra\x1A\xB4\x01R_\x81\x81a\x04\xE1\x01R\x81\x81a\x08-\x01R\x81\x81a\x08\xE6\x01R\x81\x81a\x0B\x0C\x01R\x81\x81a\x0EJ\x01R\x81\x81a\x0E\xC4\x01R\x81\x81a\x14I\x01R\x81\x81a\x15\x9A\x01R\x81\x81a\x18\xFA\x01Ra\x1D\x8C\x01Ra)8_\xF3\xFE`\x80`@R`\x046\x10a\x01\x99W_5`\xE0\x1C\x80ctK\x92\xE2\x11a\0\xDCW\x80c\xAB<~R\x11a\0\x87W\x80c\xF2\xFD\xE3\x8B\x11a\0bW\x80c\xF2\xFD\xE3\x8B\x14a\x04\xBDW\x80c\xF8\t\x8F8\x14a\x04\xD0W\x80c\xF8j\xD9\x8A\x14a\x05\x03W\x80c\xFE\xE8\x1C\xF4\x14a\x05\x17W_\x80\xFD[\x80c\xAB<~R\x14a\x04wW\x80c\xB2\xB9\x9E\xC9\x14a\x04\x8BW\x80c\xF0N(>\x14a\x04\xAAW_\x80\xFD[\x80c\x8D\xA5\xCB[\x11a\0\xB7W\x80c\x8D\xA5\xCB[\x14a\x04\x03W\x80c\x95\x92\xD4$\x14a\x046W\x80c\x9D\x95\xF1\xCC\x14a\x04XW_\x80\xFD[\x80ctK\x92\xE2\x14a\x03\x9AW\x80cw\xE2\xBF\x8A\x14a\x03\xB9W\x80c\x8B'\x04\xEC\x14a\x03\xD8W_\x80\xFD[\x80cM+\xF4|\x11a\x01GW\x80c\\\x1B\x18-\x11a\x01\"W\x80c\\\x1B\x18-\x14a\x03\x06W\x80c]\xB8/\xA0\x14a\x03%W\x80cl\xE0\xC4\xB5\x14a\x03FW\x80cqP\x18\xA6\x14a\x03\x92W_\x80\xFD[\x80cM+\xF4|\x14a\x02\xC0W\x80cT\xD1\xF1=\x14a\x02\xDFW\x80cY\xBA\xEF@\x14a\x02\xE7W_\x80\xFD[\x80c)\xAD\xEC\xF6\x11a\x01wW\x80c)\xAD\xEC\xF6\x14a\x01\xE5W\x80c3\x83\x0EH\x14a\x02IW\x80cC\xA9\xA7\x1F\x14a\x02hW_\x80\xFD[\x80c\x13\x87\x14e\x14a\x01\x9DW\x80c\x18.o9\x14a\x01\xBEW\x80c%i)b\x14a\x01\xDDW[_\x80\xFD[4\x80\x15a\x01\xA8W_\x80\xFD[Pa\x01\xBCa\x01\xB76`\x04a\"\xB2V[a\x05HV[\0[4\x80\x15a\x01\xC9W_\x80\xFD[Pa\x01\xBCa\x01\xD86`\x04a#*V[a\x08\x8EV[a\x01\xBCa\nzV[4\x80\x15a\x01\xF0W_\x80\xFD[Pa\x024a\x01\xFF6`\x04a#\x9BV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\x16_\x90\x81R`\x03` R`@\x90 T\x15\x15\x90V[`@Q\x90\x15\x15\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02TW_\x80\xFD[Pa\x01\xBCa\x02c6`\x04a#\xE1V[a\n\xC7V[4\x80\x15a\x02sW_\x80\xFD[Pa\x02\x9B\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16\x81R` \x01a\x02@V[4\x80\x15a\x02\xCBW_\x80\xFD[Pa\x01\xBCa\x02\xDA6`\x04a$_V[a\x0BwV[a\x01\xBCa\x0F.V[4\x80\x15a\x02\xF2W_\x80\xFD[Pa\x01\xBCa\x03\x016`\x04a$\xC0V[a\x0FgV[4\x80\x15a\x03\x11W_\x80\xFD[Pa\x01\xBCa\x03 6`\x04a%\x06V[a\x0F\xDBV[4\x80\x15a\x030W_\x80\xFD[Pa\x039a\x10\xDCV[`@Qa\x02@\x91\x90a%\xEFV[4\x80\x15a\x03QW_\x80\xFD[Pa\x03ea\x03`6`\x04a&GV[a\x10\xEDV[`@\x80Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x93\x84\x16\x81R\x92\x90\x91\x16` \x83\x01R\x01a\x02@V[a\x01\xBCa\x11=V[4\x80\x15a\x03\xA5W_\x80\xFD[Pa\x01\xBCa\x03\xB46`\x04a&^V[a\x11oV[4\x80\x15a\x03\xC4W_\x80\xFD[Pa\x03ea\x03\xD36`\x04a#\x9BV[a\x15\xFCV[4\x80\x15a\x03\xE3W_\x80\xFD[P_Ta\x02\x9B\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[4\x80\x15a\x04\x0EW_\x80\xFD[P\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFt\x879'Ta\x02\x9BV[4\x80\x15a\x04AW_\x80\xFD[Pa\x04Ja\x16\xC1V[`@Q\x90\x81R` \x01a\x02@V[4\x80\x15a\x04cW_\x80\xFD[Pa\x01\xBCa\x04r6`\x04a$\xC0V[a\x16\xCCV[4\x80\x15a\x04\x82W_\x80\xFD[P`\x02Ta\x04JV[4\x80\x15a\x04\x96W_\x80\xFD[Pa\x01\xBCa\x04\xA56`\x04a$\xC0V[a\x17aV[a\x01\xBCa\x04\xB86`\x04a$\xC0V[a\x17\xF3V[a\x01\xBCa\x04\xCB6`\x04a$\xC0V[a\x11=V[4\x80\x15a\x04\xDBW_\x80\xFD[Pa\x02\x9B\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[4\x80\x15a\x05\x0EW_\x80\xFD[Pa\x01\xBCa\x18-V[4\x80\x15a\x05\"W_\x80\xFD[Pa\x04Ja\x0516`\x04a$\xC0V[c8\x9Au\xE1`\x0C\x90\x81R_\x91\x90\x91R` \x90 T\x90V[a\x05Pa\x19bV[a'\x10\x83b\xFF\xFF\xFF\x16\x11\x15a\x05\x91W`@Q\x7Fv\xA3\xF9]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a'\x10\x82b\xFF\xFF\xFF\x16\x11\x15a\x05\xD2W`@Q\x7Fv\xA3\xF9]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x86s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x11\x15a\x06\nW\x93\x94\x93[_\x86\x81R` \x86\x90R`@\x81 `(\x1B\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\x81\x16_\x90\x81R`\x03` R`@\x81 T\x91\x92P\x81\x90\x03a\x07MWP`@\x80Q\x80\x82\x01\x82Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x8A\x16\x82R\x88\x81\x16` \x80\x84\x01\x91\x82R`\x02\x80T`\x01\x81\x01\x82U_\x82\x81R\x95Q\x90\x82\x02\x7F@W\x87\xFA\x12\xA8#\xE0\xF2\xB7c\x1C\xC4\x1B;\xA8\x82\x8B3!\xCA\x81\x11\x11\xFAu\xCD:\xA3\xBBZ\xCE\x81\x01\x80T\x92\x87\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x93\x84\x16\x17\x90U\x93Q\x7F@W\x87\xFA\x12\xA8#\xE0\xF2\xB7c\x1C\xC4\x1B;\xA8\x82\x8B3!\xCA\x81\x11\x11\xFAu\xCD:\xA3\xBBZ\xCF\x90\x94\x01\x80T\x94\x90\x95\x16\x93\x16\x92\x90\x92\x17\x90\x92UT\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\x85\x16\x83R`\x03\x90\x91R\x91\x90 \x81\x90U[`@\x80Qa\xFF\xFF\x88\x16\x81Rb\xFF\xFF\xFF\x87\x81\x16` \x83\x01R\x86\x81\x16\x82\x84\x01R\x85\x16``\x82\x01R\x90Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x89\x81\x16\x92\x90\x8B\x16\x91\x7F\xF3%\xA07\xD7\x1E\xFC\x98\xBCA\xDCRW\xED\xEF\xD4:\x1D\x11b\xE2\x067>S\xAF'\x1Az2$\xE9\x91\x81\x90\x03`\x80\x01\x90\xA3`@Q\x7F\x13\x87\x14e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x89\x81\x16`\x04\x83\x01R\x88\x81\x16`$\x83\x01Ra\xFF\xFF\x88\x16`D\x83\x01Rb\xFF\xFF\xFF\x80\x88\x16`d\x84\x01R\x80\x87\x16`\x84\x84\x01R\x85\x16`\xA4\x83\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c\x13\x87\x14e\x90`\xC4\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x08nW_\x80\xFD[PZ\xF1\x15\x80\x15a\x08\x80W=_\x80>=_\xFD[PPPPPPPPPPPPV[a\x08\x96a\x1A\x13V[\x80_[\x81\x81\x10\x15a\ntW6\x84\x84\x83\x81\x81\x10a\x08\xB4Wa\x08\xB4a&\x8FV[\x90P` \x02\x81\x01\x90a\x08\xC6\x91\x90a&\xBCV[\x90P` \x81\x01\x805\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c\xD9\xE1\x7F\x98\x90a\t\x17\x90\x85a$\xC0V[`@Q\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\xE0\x84\x90\x1B\x16\x81Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16`\x04\x82\x01R`$\x81\x01\x84\x90R`D\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\t\x81W_\x80\xFD[PZ\xF1\x15\x80\x15a\t\x93W=_\x80>=_\xFD[PPPP_[a\t\xA6`@\x84\x01\x84a&\xF8V[\x90P\x81\x10\x15a\n1W6a\t\xBD`@\x85\x01\x85a&\xF8V[\x83\x81\x81\x10a\t\xCDWa\t\xCDa&\x8FV[`@\x02\x91\x90\x91\x01\x91Pa\n\x18\x90Pa\t\xE8` \x83\x01\x83a$\xC0V[` \x80\x84\x015\x90a\t\xFB\x90\x88\x01\x88a$\xC0V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91\x90a\x1AJV[a\n&` \x82\x015\x84a'cV[\x92PP`\x01\x01a\t\x99V[P\x80\x15a\njW`@Q\x7F\xB2\x1Cc\xEB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PP`\x01\x01a\x08\x99V[PPPPV[_b\x02\xA3\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16B\x01\x90Pc8\x9Au\xE1`\x0CR3_R\x80` `\x0C U3\x7F\xDB\xF3j\x10}\xA1\x9EIRzqv\xA1\xBA\xBF\x96;K\x0F\xF8\xCD\xE3^\xE3]l\xD8\xF1\xF9\xAC~\x1D_\x80\xA2PV[a\n\xCFa\x19bV[`@Q\x7F3\x83\x0EH\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c3\x83\x0EH\x90a\x0BE\x90\x86\x90\x86\x90\x86\x90`\x04\x01a'\xA1V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x0B\\W_\x80\xFD[PZ\xF1\x15\x80\x15a\x0BnW=_\x80>=_\xFD[PPPPPPPV[a\x0B\x7Fa\x1A\x9DV[_\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x0B\x99Wa\x0B\x99a$\xD9V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x0C\x0FW\x81` \x01[`@\x80Q`\xA0\x81\x01\x82R_\x80\x82R` \x80\x83\x01\x82\x90R\x92\x82\x01\x81\x90R``\x82\x01\x81\x90R`\x80\x82\x01R\x82R\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x92\x01\x91\x01\x81a\x0B\xB7W\x90P[P\x90P_[\x82\x81\x10\x15a\x0E\x1BW6\x84\x84\x83\x81\x81\x10a\x0C/Wa\x0C/a&\x8FV[\x90P`\xA0\x02\x01\x90Pa'\x10\x81`@\x01` \x81\x01\x90a\x0CM\x91\x90a(\nV[b\xFF\xFF\xFF\x16\x11\x15a\x0C\x8AW`@Q\x7Fv\xA3\xF9]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a'\x10a\x0C\x9D`\x80\x83\x01``\x84\x01a(\nV[b\xFF\xFF\xFF\x16\x11\x15a\x0C\xDAW`@Q\x7Fv\xA3\xF9]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80a\x0C\xE9` \x84\x01\x84a$\xC0V[a\x0C\xF9`@\x85\x01` \x86\x01a$\xC0V[\x91P\x91P\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x11\x15a\r3W\x90[_\x82\x81R` \x82\x81R`@\x80\x83 \x81Q`\xA0\x81\x01\x83R\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0`(\x92\x90\x92\x1B\x91\x82\x16\x85R`\x03\x90\x93R\x92 T\x81\x90a\r\x8B\x90`\x01\x90a'cV[\x81R` \x01\x82d\xFF\xFF\xFF\xFF\xFF\x19\x16\x81R` \x01\x85`@\x01` \x81\x01\x90a\r\xB1\x91\x90a(\nV[b\xFF\xFF\xFF\x16\x81R` \x01a\r\xCB`\x80\x87\x01``\x88\x01a(\nV[b\xFF\xFF\xFF\x16\x81R` \x01a\r\xE5`\xA0\x87\x01`\x80\x88\x01a(\nV[b\xFF\xFF\xFF\x16\x81RP\x86\x86\x81Q\x81\x10a\r\xFFWa\r\xFFa&\x8FV[` \x02` \x01\x01\x81\x90RPPPPP\x80\x80`\x01\x01\x91PPa\x0C\x14V[P`@Q\x7F\xC9?\x1A\xDDA\xC2\x18\xFAve\xC1\x06\x17\x03?D\x1F\x8E<\x16\xFA7'\x96&TE\xD7\xA1I|#\x90_\x90\xA1_a\x0E\x84\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x1A\xEEV[`@Q\x7FS\xB4\x1CU\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\x90\x91Ps\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90cS\xB4\x1CU\x90a\x0E\xFB\x90\x84\x90\x86\x90`\x04\x01a(#V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x0F\x12W_\x80\xFD[PZ\xF1\x15\x80\x15a\x0F$W=_\x80>=_\xFD[PPPPPPPPV[c8\x9Au\xE1`\x0CR3_R_` `\x0C U3\x7F\xFA{\x8E\xAB}\xA6\x7FA,\xC9W^\xD44dF\x8F\x9B\xFB\xAE\x89\xD1gY\x174l\xA6\xD8\xFE<\x92_\x80\xA2V[a\x0Foa\x1A\x13V[_\x80T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16\x90\x81\x17\x82U`@Q\x90\x91\x7F\xCB\xCF8N&\xC1h6\x17}\x0Bm\x8C\xE7\x05A\xA8o\xF3\t\x1D\xEE\xCA\xF5\xB6\xE0\xFAUd\xC7\x82P\x91\xA2PV[`\x04T`\xFF\x16\x15a\x0F\xE9WPV[`\x04\x80T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\x16`\x01\x17\x90U_[\x81Q\x81\x10\x15a\x10\xD8W_\x82\x82\x81Q\x81\x10a\x102Wa\x102a&\x8FV[` \x02` \x01\x01Q\x90Pa\x10P\x81`\x01a\x1B\x89\x90\x91\x90c\xFF\xFF\xFF\xFF\x16V[a\x10\x86W`@Q\x7F\xEFoR6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x10\x8F\x81a\x1D\rV[`@Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90\x7F\xB2]\x03\xAA\xF3\x08\xD7)\x17\t\xBE\x1E\xA2\x8B\x80\x04c\xCF:\x9ALJUU\xD73:\x96L\x1D\xFE\xBD\x90_\x90\xA2P`\x01\x01a\x10\x16V[PPV[``a\x10\xE8`\x01a\x1D\xF4V[\x90P\x90V[_\x80_`\x02\x84\x81T\x81\x10a\x11\x03Wa\x11\x03a&\x8FV[_\x91\x82R` \x90\x91 `\x02\x90\x91\x02\x01\x80T`\x01\x90\x91\x01Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x91\x82\x16\x96\x91\x16\x94P\x92PPPV[`@Q\x7F\xBF$\x14\x88\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x11wa\x1A\x13V[\x80s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x11\x15a\x11\xADW\x90[_\x82\x81R` \x82\x90R`@\x81 `(\x1B\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\x81\x16_\x90\x81R`\x03` R`@\x81 T\x91\x92P\x81\x90\x03a\x12NW`@Q\x7F\x02\xF5\x1B1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x86\x16`\x04\x83\x01R\x84\x16`$\x82\x01R`D\x01`@Q\x80\x91\x03\x90\xFD[`\x02T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x01\x90\x80\x83\x10\x15a\x13\x99W_`\x02`\x01\x83\x03\x81T\x81\x10a\x12\x94Wa\x12\x94a&\x8FV[_\x91\x82R` \x80\x83 `@\x80Q\x80\x82\x01\x82R`\x02\x94\x90\x94\x02\x90\x91\x01\x80Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16\x80\x86R`\x01\x90\x92\x01T\x16\x84\x84\x01\x81\x90R\x90\x85R\x90\x91R\x82 \x90\x92P`(\x1B\x90P\x81`\x02\x85\x81T\x81\x10a\x12\xFDWa\x12\xFDa&\x8FV[_\x91\x82R` \x80\x83 \x84Q`\x02\x90\x93\x02\x01\x80Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x93\x84\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x82\x16\x17\x82U\x94\x82\x01Q`\x01\x90\x91\x01\x80T\x91\x90\x93\x16\x94\x16\x93\x90\x93\x17\x90U\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\x90\x92\x16\x82R`\x03\x90R`@\x90 \x84\x90UP[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\x84\x16_\x90\x81R`\x03` R`@\x81 U`\x02\x80T\x80a\x13\xDBWa\x13\xDBa(\xE7V[_\x82\x81R` \x81 `\x02\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x93\x01\x92\x83\x02\x01\x80T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x81\x16\x82U`\x01\x91\x90\x91\x01\x80T\x90\x91\x16\x90U\x91Ua\x14\x83\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x1A\xEEV[\x90P_\x80a\x14\xA8s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x16\x88\x87a\x1E\xC8V[\x91P\x91P\x87s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x89s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7Fy\xF6\x12W\x02\x17\xC0\r\xF1(\xC1\xB8(\xDDk2\x1B:p\xAELa\xB7\xA9\x7F\xE4\xA7\x1F\xC1\x9D\xF9\xBA\x84\x84`@Qa\x15\x1E\x92\x91\x90`\x02\x92\x90\x92\x0B\x82Rb\xFF\xFF\xFF\x16` \x82\x01R`@\x01\x90V[`@Q\x80\x91\x03\x90\xA3`@Q\x7F\xDDML\xF6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\x88\x16`\x04\x82\x01Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x81\x16`$\x83\x01R`D\x82\x01\x87\x90R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c\xDDML\xF6\x90`d\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x15\xDBW_\x80\xFD[PZ\xF1\x15\x80\x15a\x15\xEDW=_\x80>=_\xFD[PPPPPPPPPPPPPV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\x81\x16_\x90\x81R`\x03` R`@\x81 T\x81\x90\x80\x82\x03a\x16hW`@Q\x7F_?G\x9C\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x02a\x16v`\x01\x84a'cV[\x81T\x81\x10a\x16\x86Wa\x16\x86a&\x8FV[_\x91\x82R` \x90\x91 `\x02\x90\x91\x02\x01\x80T`\x01\x90\x91\x01Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x91\x82\x16\x97\x91\x16\x95P\x93PPPPV[_a\x10\xE8`\x01a\x1F?V[a\x16\xD4a\x1A\x13V[a\x16\xDF`\x01\x82a\x1B\x89V[a\x17\x15W`@Q\x7F\xEFoR6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90\x7F\xB2]\x03\xAA\xF3\x08\xD7)\x17\t\xBE\x1E\xA2\x8B\x80\x04c\xCF:\x9ALJUU\xD73:\x96L\x1D\xFE\xBD\x90_\x90\xA2a\x17^\x81a\x1D\rV[PV[a\x17ia\x19bV[a\x17t`\x01\x82a\x1F\x90V[a\x17\xAAW`@Q\x7F\\\xD2kh\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90\x7F\xCF\xC2Af\xDBK\xB6w\xE8W\xCA\xCA\xBD\x15A\xFB+0dP!\xB2|Q0A\x95\x89\xB8M\xB5+\x90_\x90\xA2a\x17^\x81a\x1D\rV[a\x17\xFBa\x1A\x13V[c8\x9Au\xE1`\x0CR\x80_R` `\x0C \x80TB\x11\x15a\x18!Wco^\x88\x18_R`\x04`\x1C\xFD[_\x90Ua\x17^\x81a!\x04V[_Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163\x14a\x18}W`@Q\x7F\xB0cJv\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x81U`@Q3\x91\x7F\xAB%\x8A\xFB\xE9\xEB\xB9c\xA1\xBA\xEA\xDB\xB7&_7\xC9_g\xB6\xCApz\xB7\xF5bh\xBC\xB7\xD2\x91\xC8\x91\xA2`@Q\x7F\x92\xEE\xFE\x9B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R3`\x04\x82\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90c\x92\xEE\xFE\x9B\x90`$\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x19PW_\x80\xFD[PZ\xF1\x15\x80\x15a\ntW=_\x80>=_\xFD[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x163\x03a\x19\xA1WV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFt\x879'Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163\x03a\x19\xE1WV[`@Q\x7F)\xAB\x19\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFt\x879'T3\x14a\x1AHWc\x82\xB4)\0_R`\x04`\x1C\xFD[V[\x81`\x14R\x80`4Ro\xA9\x05\x9C\xBB\0\0\0\0\0\0\0\0\0\0\0\0_R` _`D`\x10_\x87Z\xF1\x80`\x01_Q\x14\x16a\x1A\x93W\x80=\x85;\x15\x17\x10a\x1A\x93Wc\x90\xB8\xEC\x18_R`\x04`\x1C\xFD[P_`4RPPPV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x163\x03a\x1A\xDCWV[a\x1A\xE7`\x013a!iV[\x15a\x19\xA1WV[`@Q\x7F|\xF9\x80\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x03`\x04\x82\x01R_\x90\x81\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x16\x90c|\xF9\x80\x81\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x1B[W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1B\x7F\x91\x90a)\x14V[`@\x1C\x93\x92PPPV[c\x97\x8A\xAB\x92`\x04R_\x82\x81R`$\x81 s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x92\x90\x92\x16\x91\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x04I\x80%\xAD+@GA\x83\x01a\x1B\xE7Wc\xF5\xA2g\xF1_R`\x04`\x1C\xFD[\x82a\x1B\xF9Wh\xFB\xB6\x7F\xDAR\xD4\xBF\xB8\xBF\x92P[\x80Tk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x82` R\x80a\x1C\xC0W\x81``\x1C\x80a\x1C,W\x85``\x1B\x84U`\x01\x94PPa\x1D\x04V[\x85\x81\x03a\x1C9WPa\x1D\x04V[`\x01\x84\x01T``\x1C\x80a\x1CZW\x86``\x1B`\x01\x86\x01U`\x01\x95PPPa\x1D\x04V[\x86\x81\x03a\x1ChWPPa\x1D\x04V[`\x02\x85\x01T``\x1C\x80a\x1C\x8AW\x87``\x1B`\x02\x87\x01U`\x01\x96PPPPa\x1D\x04V[\x87\x81\x03a\x1C\x99WPPPa\x1D\x04V[_\x92\x83R`@\x80\x84 `\x01\x90U\x91\x83R\x81\x83 `\x02\x90U\x82R\x90 `\x03\x90UP`\x07\x90\x81\x17\x90[\x84_R`@_ \x80Ta\x1D\x02W`\x01\x91\x82\x1C\x80\x83\x01\x82U\x91\x94P\x81a\x1C\xEEW\x85``\x1B`\x03\x17\x84UPa\x1D\x04V[\x85``\x1B\x82\x85\x01U\x82`\x02\x01\x84UPa\x1D\x04V[P[PPP\x92\x91PPV[`@\x80Q`\x01\x80\x82R\x81\x83\x01\x90\x92R_\x91` \x80\x83\x01\x90\x806\x837\x01\x90PP\x90P\x81\x81_\x81Q\x81\x10a\x1DAWa\x1DAa&\x8FV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x92\x83\x16` \x91\x82\x02\x92\x90\x92\x01\x01R`@Q\x7F\xD6\xCF\xFD\x1E\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x91\x16\x90c\xD6\xCF\xFD\x1E\x90a\x1D\xC3\x90\x84\x90`\x04\x01a%\xEFV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x1D\xDAW_\x80\xFD[PZ\xF1\x15\x80\x15a\x1D\xECW=_\x80>=_\xFD[PPPPPPV[c\x97\x8A\xAB\x92`\x04R_\x81\x81R`$\x81 ``\x91Ph\xFB\xB6\x7F\xDAR\xD4\xBF\xB8\xBF\x81T\x80`\xA0\x1B`\xA0\x1C`@Q\x94P\x84` \x01\x82``\x1C\x92P\x83\x83\x14\x15\x83\x02\x81R\x81a\x1E\x82W\x82\x15a\x1E}W`\x01\x91P\x81\x85\x01T``\x1C\x92P\x82\x15a\x1E}W\x82\x84\x14\x15\x90\x92\x02` \x83\x01RP`\x02\x83\x81\x01T``\x1C\x91\x82\x15a\x1E}W`\x03\x91P\x83\x83\x14\x15\x83\x02`@\x82\x01R[a\x1E\xB2V[`\x01\x91\x82\x1C\x91[\x82\x81\x10\x15a\x1E\xB0W\x85\x81\x01T``\x1C\x85\x81\x14\x15\x81\x02`\x05\x83\x90\x1B\x84\x01R\x93P`\x01\x01a\x1E\x89V[P[\x81\x86R\x81`\x05\x1B\x81\x01`@RPPPPP\x91\x90PV[_\x80\x80a\x1E\xECs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x87\x16\x86\x86a\":V[\x90P\x80a\x1F%W`@Q\x7F/e\x9ED\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\xFF\xFF`\x18\x82\x90\x1C\x16\x96b\xFF\xFF\xFF\x90\x91\x16\x95P\x93PPPPV[c\x97\x8A\xAB\x92`\x04R_\x81\x81R`$\x81 \x80T\x80`\xA0\x1B`\xA0\x1C\x80`\x01\x1C\x93P\x80\x82``\x1C\x15\x17a\x1F\x88W`\x01\x93P\x83\x83\x01T\x15a\x1F\x88W`\x02\x93P\x83\x83\x01T\x15a\x1F\x88W`\x03\x93P[PPP\x91\x90PV[c\x97\x8A\xAB\x92`\x04R_\x82\x81R`$\x81 s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x92\x90\x92\x16\x91\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x04I\x80%\xAD+@GA\x83\x01a\x1F\xEEWc\xF5\xA2g\xF1_R`\x04`\x1C\xFD[\x82a \0Wh\xFB\xB6\x7F\xDAR\xD4\xBF\xB8\xBF\x92P[\x80Tk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x80a \x7FW`\x01\x93P\x84\x82``\x1C\x03a =W`\x01\x83\x01\x80T\x84U`\x02\x84\x01\x80T\x90\x91U_\x90Ua\x1D\x04V[\x84`\x01\x84\x01T``\x1C\x03a ^W`\x02\x83\x01\x80T`\x01\x85\x01U_\x90Ua\x1D\x04V[\x84`\x02\x84\x01T``\x1C\x03a wW_`\x02\x84\x01Ua\x1D\x04V[_\x93Pa\x1D\x04V[\x82` R\x84_R`@_ \x80T\x80a \x98WPPa\x1D\x04V[`\x01\x83`\x01\x1C\x03\x92P\x82`\x01\x82\x03\x14a \xC8W\x82\x85\x01T``\x1C\x80``\x1B`\x01\x83\x03\x87\x01U\x80_RP\x80`@_ U[P\x83T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\x16`\x01\x92\x83\x1B\x17\x82\x17\x90\x93U_\x90\x92UP\x93\x92PPPV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFt\x879'\x80Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x92\x16\x91\x82\x90\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0_\x80\xA3UV[c\x97\x8A\xAB\x92`\x04R_\x82\x81R`$\x81 s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x92\x90\x92\x16\x91\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x04I\x80%\xAD+@GA\x83\x01a!\xC7Wc\xF5\xA2g\xF1_R`\x04`\x1C\xFD[\x82a!\xD9Wh\xFB\xB6\x7F\xDAR\xD4\xBF\xB8\xBF\x92P[\x80Tk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16a\"!W`\x01\x92P\x83\x81``\x1C\x03\x15a\"2W`\x01\x82\x01T``\x1C\x84\x14a\"2W`\x02\x82\x01T``\x1C\x84\x14a\"2W_\x92Pa\"2V[\x81` R\x83_R`@_ T\x15\x15\x92P[PP\x92\x91PPV[_` \x82` \x02`\x01\x01_\x86<PP_Q\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\x81\x16\x91\x90\x91\x14\x02\x91\x90PV[\x805s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\"\x9BW_\x80\xFD[\x91\x90PV[\x805b\xFF\xFF\xFF\x81\x16\x81\x14a\"\x9BW_\x80\xFD[_\x80_\x80_\x80`\xC0\x87\x89\x03\x12\x15a\"\xC7W_\x80\xFD[a\"\xD0\x87a\"xV[\x95Pa\"\xDE` \x88\x01a\"xV[\x94P`@\x87\x015a\xFF\xFF\x81\x16\x81\x14a\"\xF4W_\x80\xFD[\x93Pa#\x02``\x88\x01a\"\xA0V[\x92Pa#\x10`\x80\x88\x01a\"\xA0V[\x91Pa#\x1E`\xA0\x88\x01a\"\xA0V[\x90P\x92\x95P\x92\x95P\x92\x95V[_\x80` \x83\x85\x03\x12\x15a#;W_\x80\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a#QW_\x80\xFD[\x83\x01`\x1F\x81\x01\x85\x13a#aW_\x80\xFD[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a#wW_\x80\xFD[\x85` \x82`\x05\x1B\x84\x01\x01\x11\x15a#\x8BW_\x80\xFD[` \x91\x90\x91\x01\x95\x90\x94P\x92PPPV[_` \x82\x84\x03\x12\x15a#\xABW_\x80\xFD[\x815\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\x81\x16\x81\x14a#\xDAW_\x80\xFD[\x93\x92PPPV[_\x80_`@\x84\x86\x03\x12\x15a#\xF3W_\x80\xFD[a#\xFC\x84a\"xV[\x92P` \x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a$\x17W_\x80\xFD[\x84\x01`\x1F\x81\x01\x86\x13a$'W_\x80\xFD[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a$=W_\x80\xFD[\x86` \x82\x84\x01\x01\x11\x15a$NW_\x80\xFD[\x93\x96` \x91\x90\x91\x01\x95P\x92\x93PPPV[_\x80` \x83\x85\x03\x12\x15a$pW_\x80\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a$\x86W_\x80\xFD[\x83\x01`\x1F\x81\x01\x85\x13a$\x96W_\x80\xFD[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a$\xACW_\x80\xFD[\x85` `\xA0\x83\x02\x84\x01\x01\x11\x15a#\x8BW_\x80\xFD[_` \x82\x84\x03\x12\x15a$\xD0W_\x80\xFD[a#\xDA\x82a\"xV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[_` \x82\x84\x03\x12\x15a%\x16W_\x80\xFD[\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a%,W_\x80\xFD[\x82\x01`\x1F\x81\x01\x84\x13a%<W_\x80\xFD[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a%VWa%Va$\xD9V[\x80`\x05\x1B`@Q\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`?\x83\x01\x16\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a%\xA1Wa%\xA1a$\xD9V[`@R\x91\x82R` \x81\x84\x01\x81\x01\x92\x90\x81\x01\x87\x84\x11\x15a%\xBEW_\x80\xFD[` \x85\x01\x94P[\x83\x85\x10\x15a%\xE4Wa%\xD6\x85a\"xV[\x81R` \x94\x85\x01\x94\x01a%\xC5V[P\x96\x95PPPPPPV[` \x80\x82R\x82Q\x82\x82\x01\x81\x90R_\x91\x84\x01\x90`@\x84\x01\x90\x83[\x81\x81\x10\x15a&<W\x83Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x83R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a&\x08V[P\x90\x95\x94PPPPPV[_` \x82\x84\x03\x12\x15a&WW_\x80\xFD[P5\x91\x90PV[_\x80`@\x83\x85\x03\x12\x15a&oW_\x80\xFD[a&x\x83a\"xV[\x91Pa&\x86` \x84\x01a\"xV[\x90P\x92P\x92\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[_\x825\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xA1\x836\x03\x01\x81\x12a&\xEEW_\x80\xFD[\x91\x90\x91\x01\x92\x91PPV[_\x80\x835\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE1\x846\x03\x01\x81\x12a'+W_\x80\xFD[\x83\x01\x805\x91Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a'EW_\x80\xFD[` \x01\x91P`\x06\x81\x90\x1B6\x03\x82\x13\x15a'\\W_\x80\xFD[\x92P\x92\x90PV[\x81\x81\x03\x81\x81\x11\x15a'\x9BW\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[\x92\x91PPV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x16\x81R`@` \x82\x01R\x81`@\x82\x01R\x81\x83``\x83\x017_\x81\x83\x01``\x90\x81\x01\x91\x90\x91R`\x1F\x90\x92\x01\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x16\x01\x01\x92\x91PPV[_` \x82\x84\x03\x12\x15a(\x1AW_\x80\xFD[a#\xDA\x82a\"\xA0V[_`@\x82\x01s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x85\x16\x83R`@` \x84\x01R\x80\x84Q\x80\x83R``\x85\x01\x91P` \x86\x01\x92P_[\x81\x81\x10\x15a(\xDBW\x83Q\x80Q\x84R\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0` \x82\x01Q\x16` \x85\x01Rb\xFF\xFF\xFF`@\x82\x01Q\x16`@\x85\x01Rb\xFF\xFF\xFF``\x82\x01Q\x16``\x85\x01Rb\xFF\xFF\xFF`\x80\x82\x01Q\x16`\x80\x85\x01RP`\xA0\x83\x01\x92P` \x84\x01\x93P`\x01\x81\x01\x90Pa(\\V[P\x90\x96\x95PPPPPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`1`\x04R`$_\xFD[_` \x82\x84\x03\x12\x15a)$W_\x80\xFD[PQ\x91\x90PV\xFE\xA1dsolcC\0\x08\x1A\0\n",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405260043610610199575f3560e01c8063744b92e2116100dc578063ab3c7e5211610087578063f2fde38b11610062578063f2fde38b146104bd578063f8098f38146104d0578063f86ad98a14610503578063fee81cf414610517575f80fd5b8063ab3c7e5214610477578063b2b99ec91461048b578063f04e283e146104aa575f80fd5b80638da5cb5b116100b75780638da5cb5b146104035780639592d424146104365780639d95f1cc14610458575f80fd5b8063744b92e21461039a57806377e2bf8a146103b95780638b2704ec146103d8575f80fd5b80634d2bf47c116101475780635c1b182d116101225780635c1b182d146103065780635db82fa0146103255780636ce0c4b514610346578063715018a614610392575f80fd5b80634d2bf47c146102c057806354d1f13d146102df57806359baef40146102e7575f80fd5b806329adecf61161017757806329adecf6146101e557806333830e481461024957806343a9a71f14610268575f80fd5b8063138714651461019d578063182e6f39146101be57806325692962146101dd575b5f80fd5b3480156101a8575f80fd5b506101bc6101b73660046122b2565b610548565b005b3480156101c9575f80fd5b506101bc6101d836600461232a565b61088e565b6101bc610a7a565b3480156101f0575f80fd5b506102346101ff36600461239b565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffff0000000000165f90815260036020526040902054151590565b60405190151581526020015b60405180910390f35b348015610254575f80fd5b506101bc6102633660046123e1565b610ac7565b348015610273575f80fd5b5061029b7f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff9091168152602001610240565b3480156102cb575f80fd5b506101bc6102da36600461245f565b610b77565b6101bc610f2e565b3480156102f2575f80fd5b506101bc6103013660046124c0565b610f67565b348015610311575f80fd5b506101bc610320366004612506565b610fdb565b348015610330575f80fd5b506103396110dc565b60405161024091906125ef565b348015610351575f80fd5b50610365610360366004612647565b6110ed565b6040805173ffffffffffffffffffffffffffffffffffffffff938416815292909116602083015201610240565b6101bc61113d565b3480156103a5575f80fd5b506101bc6103b436600461265e565b61116f565b3480156103c4575f80fd5b506103656103d336600461239b565b6115fc565b3480156103e3575f80fd5b505f5461029b9073ffffffffffffffffffffffffffffffffffffffff1681565b34801561040e575f80fd5b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffff748739275461029b565b348015610441575f80fd5b5061044a6116c1565b604051908152602001610240565b348015610463575f80fd5b506101bc6104723660046124c0565b6116cc565b348015610482575f80fd5b5060025461044a565b348015610496575f80fd5b506101bc6104a53660046124c0565b611761565b6101bc6104b83660046124c0565b6117f3565b6101bc6104cb3660046124c0565b61113d565b3480156104db575f80fd5b5061029b7f000000000000000000000000000000000000000000000000000000000000000081565b34801561050e575f80fd5b506101bc61182d565b348015610522575f80fd5b5061044a6105313660046124c0565b63389a75e1600c9081525f91909152602090205490565b610550611962565b6127108362ffffff161115610591576040517f76a3f95d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6127108262ffffff1611156105d2576040517f76a3f95d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8473ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff16111561060a579394935b5f86815260208690526040812060281b7fffffffffffffffffffffffffffffffffffffffffffffffffffffff000000000081165f9081526003602052604081205491925081900361074d575060408051808201825273ffffffffffffffffffffffffffffffffffffffff808a1682528881166020808401918252600280546001810182555f82815295519082027f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace810180549287167fffffffffffffffffffffffff000000000000000000000000000000000000000093841617905593517f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5acf909401805494909516931692909217909255547fffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000008516835260039091529190208190555b6040805161ffff8816815262ffffff87811660208301528681168284015285166060820152905173ffffffffffffffffffffffffffffffffffffffff89811692908b16917ff325a037d71efc98bc41dc5257edefd43a1d1162e206373e53af271a7a3224e99181900360800190a36040517f1387146500000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8981166004830152888116602483015261ffff8816604483015262ffffff80881660648401528087166084840152851660a48301527f0000000000000000000000000000000000000000000000000000000000000000169063138714659060c4015f604051808303815f87803b15801561086e575f80fd5b505af1158015610880573d5f803e3d5ffd5b505050505050505050505050565b610896611a13565b805f5b81811015610a7457368484838181106108b4576108b461268f565b90506020028101906108c691906126bc565b90506020810180359073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000169063d9e17f989061091790856124c0565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b16815273ffffffffffffffffffffffffffffffffffffffff9091166004820152602481018490526044015f604051808303815f87803b158015610981575f80fd5b505af1158015610993573d5f803e3d5ffd5b505050505f5b6109a660408401846126f8565b9050811015610a3157366109bd60408501856126f8565b838181106109cd576109cd61268f565b604002919091019150610a1890506109e860208301836124c0565b602080840135906109fb908801886124c0565b73ffffffffffffffffffffffffffffffffffffffff169190611a4a565b610a26602082013584612763565b925050600101610999565b508015610a6a576040517fb21c63eb00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5050600101610899565b50505050565b5f6202a30067ffffffffffffffff164201905063389a75e1600c52335f52806020600c2055337fdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d5f80a250565b610acf611962565b6040517f33830e4800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016906333830e4890610b45908690869086906004016127a1565b5f604051808303815f87803b158015610b5c575f80fd5b505af1158015610b6e573d5f803e3d5ffd5b50505050505050565b610b7f611a9d565b5f8167ffffffffffffffff811115610b9957610b996124d9565b604051908082528060200260200182016040528015610c0f57816020015b6040805160a0810182525f808252602080830182905292820181905260608201819052608082015282527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff909201910181610bb75790505b5090505f5b82811015610e1b5736848483818110610c2f57610c2f61268f565b905060a002019050612710816040016020810190610c4d919061280a565b62ffffff161115610c8a576040517f76a3f95d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b612710610c9d608083016060840161280a565b62ffffff161115610cda576040517f76a3f95d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f80610ce960208401846124c0565b610cf960408501602086016124c0565b915091508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161115610d3357905b5f82815260208281526040808320815160a0810183527fffffffffffffffffffffffffffffffffffffffffffffffffffffff000000000060289290921b918216855260039093529220548190610d8b90600190612763565b81526020018264ffffffffff19168152602001856040016020810190610db1919061280a565b62ffffff168152602001610dcb608087016060880161280a565b62ffffff168152602001610de560a087016080880161280a565b62ffffff16815250868681518110610dff57610dff61268f565b6020026020010181905250505050508080600101915050610c14565b506040517fc93f1add41c218fa7665c10617033f441f8e3c16fa372796265445d7a1497c23905f90a15f610e847f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16611aee565b6040517f53b41c5500000000000000000000000000000000000000000000000000000000815290915073ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016906353b41c5590610efb9084908690600401612823565b5f604051808303815f87803b158015610f12575f80fd5b505af1158015610f24573d5f803e3d5ffd5b5050505050505050565b63389a75e1600c52335f525f6020600c2055337ffa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c925f80a2565b610f6f611a13565b5f80547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff8316908117825560405190917fcbcf384e26c16836177d0b6d8ce70541a86ff3091deecaf5b6e0fa5564c7825091a250565b60045460ff1615610fe95750565b600480547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001660011790555f5b81518110156110d8575f8282815181106110325761103261268f565b60200260200101519050611050816001611b8990919063ffffffff16565b611086576040517fef6f523600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61108f81611d0d565b60405173ffffffffffffffffffffffffffffffffffffffff8216907fb25d03aaf308d7291709be1ea28b800463cf3a9a4c4a5555d7333a964c1dfebd905f90a250600101611016565b5050565b60606110e86001611df4565b905090565b5f805f600284815481106111035761110361268f565b5f9182526020909120600290910201805460019091015473ffffffffffffffffffffffffffffffffffffffff918216969116945092505050565b6040517fbf24148800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b611177611a13565b8073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1611156111ad57905b5f82815260208290526040812060281b7fffffffffffffffffffffffffffffffffffffffffffffffffffffff000000000081165f9081526003602052604081205491925081900361124e576040517f02f51b3100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff80861660048301528416602482015260440160405180910390fd5b6002547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82019080831015611399575f600260018303815481106112945761129461268f565b5f9182526020808320604080518082018252600294909402909101805473ffffffffffffffffffffffffffffffffffffffff90811680865260019092015416848401819052908552909152822090925060281b905081600285815481106112fd576112fd61268f565b5f91825260208083208451600290930201805473ffffffffffffffffffffffffffffffffffffffff9384167fffffffffffffffffffffffff000000000000000000000000000000000000000091821617825594820151600190910180549190931694169390931790557fffffffffffffffffffffffffffffffffffffffffffffffffffffff000000000090921682526003905260409020849055505b7fffffffffffffffffffffffffffffffffffffffffffffffffffffff000000000084165f9081526003602052604081205560028054806113db576113db6128e7565b5f8281526020812060027fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9093019283020180547fffffffffffffffffffffffff000000000000000000000000000000000000000090811682556001919091018054909116905591556114837f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16611aee565b90505f806114a873ffffffffffffffffffffffffffffffffffffffff84168887611ec8565b915091508773ffffffffffffffffffffffffffffffffffffffff168973ffffffffffffffffffffffffffffffffffffffff167f79f612570217c00df128c1b828dd6b321b3a70ae4c61b7a97fe4a71fc19df9ba848460405161151e92919060029290920b825262ffffff16602082015260400190565b60405180910390a36040517fdd4d4cf60000000000000000000000000000000000000000000000000000000081527fffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000008816600482015273ffffffffffffffffffffffffffffffffffffffff8481166024830152604482018790527f0000000000000000000000000000000000000000000000000000000000000000169063dd4d4cf6906064015f604051808303815f87803b1580156115db575f80fd5b505af11580156115ed573d5f803e3d5ffd5b50505050505050505050505050565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffff000000000081165f908152600360205260408120548190808203611668576040517f5f3f479c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f6002611676600184612763565b815481106116865761168661268f565b5f9182526020909120600290910201805460019091015473ffffffffffffffffffffffffffffffffffffffff91821697911695509350505050565b5f6110e86001611f3f565b6116d4611a13565b6116df600182611b89565b611715576040517fef6f523600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60405173ffffffffffffffffffffffffffffffffffffffff8216907fb25d03aaf308d7291709be1ea28b800463cf3a9a4c4a5555d7333a964c1dfebd905f90a261175e81611d0d565b50565b611769611962565b611774600182611f90565b6117aa576040517f5cd26b6800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60405173ffffffffffffffffffffffffffffffffffffffff8216907fcfc24166db4bb677e857cacabd1541fb2b30645021b27c5130419589b84db52b905f90a261175e81611d0d565b6117fb611a13565b63389a75e1600c52805f526020600c20805442111561182157636f5e88185f526004601cfd5b5f905561175e81612104565b5f5473ffffffffffffffffffffffffffffffffffffffff16331461187d576040517fb0634a7600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f80547fffffffffffffffffffffffff000000000000000000000000000000000000000016815560405133917fab258afbe9ebb963a1baeadbb7265f37c95f67b6ca707ab7f56268bcb7d291c891a26040517f92eefe9b0000000000000000000000000000000000000000000000000000000081523360048201527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16906392eefe9b906024015f604051808303815f87803b158015611950575f80fd5b505af1158015610a74573d5f803e3d5ffd5b73ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001633036119a157565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffff748739275473ffffffffffffffffffffffffffffffffffffffff1633036119e157565b6040517f29ab190d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927543314611a48576382b429005f526004601cfd5b565b81601452806034526fa9059cbb0000000000000000000000005f5260205f604460105f875af18060015f511416611a9357803d853b151710611a93576390b8ec185f526004601cfd5b505f603452505050565b73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163303611adc57565b611ae7600133612169565b156119a157565b6040517f7cf98081000000000000000000000000000000000000000000000000000000008152600360048201525f90819073ffffffffffffffffffffffffffffffffffffffff841690637cf9808190602401602060405180830381865afa158015611b5b573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611b7f9190612914565b60401c9392505050565b63978aab926004525f8281526024812073ffffffffffffffffffffffffffffffffffffffff92909216917fffffffffffffffffffffffffffffffffffffffffffffff04498025ad2b4047418301611be75763f5a267f15f526004601cfd5b82611bf95768fbb67fda52d4bfb8bf92505b80546bffffffffffffffffffffffff81168260205280611cc0578160601c80611c2c578560601b84556001945050611d04565b858103611c395750611d04565b600184015460601c80611c5a578660601b6001860155600195505050611d04565b868103611c68575050611d04565b600285015460601c80611c8a578760601b600287015560019650505050611d04565b878103611c9957505050611d04565b5f928352604080842060019055918352818320600290558252902060039055506007908117905b845f5260405f208054611d0257600191821c808301825591945081611cee578560601b600317845550611d04565b8560601b8285015582600201845550611d04565b505b50505092915050565b6040805160018082528183019092525f916020808301908036833701905050905081815f81518110611d4157611d4161268f565b73ffffffffffffffffffffffffffffffffffffffff92831660209182029290920101526040517fd6cffd1e0000000000000000000000000000000000000000000000000000000081527f00000000000000000000000000000000000000000000000000000000000000009091169063d6cffd1e90611dc39084906004016125ef565b5f604051808303815f87803b158015611dda575f80fd5b505af1158015611dec573d5f803e3d5ffd5b505050505050565b63978aab926004525f818152602481206060915068fbb67fda52d4bfb8bf81548060a01b60a01c6040519450846020018260601c9250838314158302815281611e82578215611e7d57600191508185015460601c92508215611e7d578284141590920260208301525060028381015460601c918215611e7d576003915083831415830260408201525b611eb2565b600191821c915b82811015611eb0578581015460601c858114158102600583901b8401529350600101611e89565b505b8186528160051b81016040525050505050919050565b5f8080611eec73ffffffffffffffffffffffffffffffffffffffff8716868661223a565b905080611f25576040517f2f659e4400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61ffff601882901c169662ffffff90911695509350505050565b63978aab926004525f8181526024812080548060a01b60a01c8060011c9350808260601c1517611f8857600193508383015415611f8857600293508383015415611f8857600393505b505050919050565b63978aab926004525f8281526024812073ffffffffffffffffffffffffffffffffffffffff92909216917fffffffffffffffffffffffffffffffffffffffffffffff04498025ad2b4047418301611fee5763f5a267f15f526004601cfd5b826120005768fbb67fda52d4bfb8bf92505b80546bffffffffffffffffffffffff81168061207f5760019350848260601c0361203d5760018301805484556002840180549091555f9055611d04565b84600184015460601c0361205e5760028301805460018501555f9055611d04565b84600284015460601c03612077575f6002840155611d04565b5f9350611d04565b82602052845f5260405f20805480612098575050611d04565b60018360011c0392508260018203146120c8578285015460601c8060601b60018303870155805f52508060405f20555b5083547fffffffffffffffffffffffffffffffffffffffff00000000000000000000000016600192831b1782179093555f909255509392505050565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927805473ffffffffffffffffffffffffffffffffffffffff9092169182907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a355565b63978aab926004525f8281526024812073ffffffffffffffffffffffffffffffffffffffff92909216917fffffffffffffffffffffffffffffffffffffffffffffff04498025ad2b40474183016121c75763f5a267f15f526004601cfd5b826121d95768fbb67fda52d4bfb8bf92505b80546bffffffffffffffffffffffff81166122215760019250838160601c031561223257600182015460601c841461223257600282015460601c8414612232575f9250612232565b81602052835f5260405f2054151592505b505092915050565b5f6020826020026001015f863c50505f517fffffffffffffffffffffffffffffffffffffffffffffffffffffff000000000081169190911402919050565b803573ffffffffffffffffffffffffffffffffffffffff8116811461229b575f80fd5b919050565b803562ffffff8116811461229b575f80fd5b5f805f805f8060c087890312156122c7575f80fd5b6122d087612278565b95506122de60208801612278565b9450604087013561ffff811681146122f4575f80fd5b9350612302606088016122a0565b9250612310608088016122a0565b915061231e60a088016122a0565b90509295509295509295565b5f806020838503121561233b575f80fd5b823567ffffffffffffffff811115612351575f80fd5b8301601f81018513612361575f80fd5b803567ffffffffffffffff811115612377575f80fd5b8560208260051b840101111561238b575f80fd5b6020919091019590945092505050565b5f602082840312156123ab575f80fd5b81357fffffffffffffffffffffffffffffffffffffffffffffffffffffff0000000000811681146123da575f80fd5b9392505050565b5f805f604084860312156123f3575f80fd5b6123fc84612278565b9250602084013567ffffffffffffffff811115612417575f80fd5b8401601f81018613612427575f80fd5b803567ffffffffffffffff81111561243d575f80fd5b86602082840101111561244e575f80fd5b939660209190910195509293505050565b5f8060208385031215612470575f80fd5b823567ffffffffffffffff811115612486575f80fd5b8301601f81018513612496575f80fd5b803567ffffffffffffffff8111156124ac575f80fd5b85602060a08302840101111561238b575f80fd5b5f602082840312156124d0575f80fd5b6123da82612278565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b5f60208284031215612516575f80fd5b813567ffffffffffffffff81111561252c575f80fd5b8201601f8101841361253c575f80fd5b803567ffffffffffffffff811115612556576125566124d9565b8060051b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0603f830116810181811067ffffffffffffffff821117156125a1576125a16124d9565b6040529182526020818401810192908101878411156125be575f80fd5b6020850194505b838510156125e4576125d685612278565b8152602094850194016125c5565b509695505050505050565b602080825282518282018190525f918401906040840190835b8181101561263c57835173ffffffffffffffffffffffffffffffffffffffff16835260209384019390920191600101612608565b509095945050505050565b5f60208284031215612657575f80fd5b5035919050565b5f806040838503121561266f575f80fd5b61267883612278565b915061268660208401612278565b90509250929050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f82357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa18336030181126126ee575f80fd5b9190910192915050565b5f8083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe184360301811261272b575f80fd5b83018035915067ffffffffffffffff821115612745575f80fd5b6020019150600681901b360382131561275c575f80fd5b9250929050565b8181038181111561279b577f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b92915050565b73ffffffffffffffffffffffffffffffffffffffff8416815260406020820152816040820152818360608301375f818301606090810191909152601f9092017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016010192915050565b5f6020828403121561281a575f80fd5b6123da826122a0565b5f6040820173ffffffffffffffffffffffffffffffffffffffff85168352604060208401528084518083526060850191506020860192505f5b818110156128db578351805184527fffffffffffffffffffffffffffffffffffffffffffffffffffffff0000000000602082015116602085015262ffffff604082015116604085015262ffffff606082015116606085015262ffffff60808201511660808501525060a08301925060208401935060018101905061285c565b50909695505050505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603160045260245ffd5b5f60208284031215612924575f80fd5b505191905056fea164736f6c634300081a000a
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10a\x01\x99W_5`\xE0\x1C\x80ctK\x92\xE2\x11a\0\xDCW\x80c\xAB<~R\x11a\0\x87W\x80c\xF2\xFD\xE3\x8B\x11a\0bW\x80c\xF2\xFD\xE3\x8B\x14a\x04\xBDW\x80c\xF8\t\x8F8\x14a\x04\xD0W\x80c\xF8j\xD9\x8A\x14a\x05\x03W\x80c\xFE\xE8\x1C\xF4\x14a\x05\x17W_\x80\xFD[\x80c\xAB<~R\x14a\x04wW\x80c\xB2\xB9\x9E\xC9\x14a\x04\x8BW\x80c\xF0N(>\x14a\x04\xAAW_\x80\xFD[\x80c\x8D\xA5\xCB[\x11a\0\xB7W\x80c\x8D\xA5\xCB[\x14a\x04\x03W\x80c\x95\x92\xD4$\x14a\x046W\x80c\x9D\x95\xF1\xCC\x14a\x04XW_\x80\xFD[\x80ctK\x92\xE2\x14a\x03\x9AW\x80cw\xE2\xBF\x8A\x14a\x03\xB9W\x80c\x8B'\x04\xEC\x14a\x03\xD8W_\x80\xFD[\x80cM+\xF4|\x11a\x01GW\x80c\\\x1B\x18-\x11a\x01\"W\x80c\\\x1B\x18-\x14a\x03\x06W\x80c]\xB8/\xA0\x14a\x03%W\x80cl\xE0\xC4\xB5\x14a\x03FW\x80cqP\x18\xA6\x14a\x03\x92W_\x80\xFD[\x80cM+\xF4|\x14a\x02\xC0W\x80cT\xD1\xF1=\x14a\x02\xDFW\x80cY\xBA\xEF@\x14a\x02\xE7W_\x80\xFD[\x80c)\xAD\xEC\xF6\x11a\x01wW\x80c)\xAD\xEC\xF6\x14a\x01\xE5W\x80c3\x83\x0EH\x14a\x02IW\x80cC\xA9\xA7\x1F\x14a\x02hW_\x80\xFD[\x80c\x13\x87\x14e\x14a\x01\x9DW\x80c\x18.o9\x14a\x01\xBEW\x80c%i)b\x14a\x01\xDDW[_\x80\xFD[4\x80\x15a\x01\xA8W_\x80\xFD[Pa\x01\xBCa\x01\xB76`\x04a\"\xB2V[a\x05HV[\0[4\x80\x15a\x01\xC9W_\x80\xFD[Pa\x01\xBCa\x01\xD86`\x04a#*V[a\x08\x8EV[a\x01\xBCa\nzV[4\x80\x15a\x01\xF0W_\x80\xFD[Pa\x024a\x01\xFF6`\x04a#\x9BV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\x16_\x90\x81R`\x03` R`@\x90 T\x15\x15\x90V[`@Q\x90\x15\x15\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02TW_\x80\xFD[Pa\x01\xBCa\x02c6`\x04a#\xE1V[a\n\xC7V[4\x80\x15a\x02sW_\x80\xFD[Pa\x02\x9B\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16\x81R` \x01a\x02@V[4\x80\x15a\x02\xCBW_\x80\xFD[Pa\x01\xBCa\x02\xDA6`\x04a$_V[a\x0BwV[a\x01\xBCa\x0F.V[4\x80\x15a\x02\xF2W_\x80\xFD[Pa\x01\xBCa\x03\x016`\x04a$\xC0V[a\x0FgV[4\x80\x15a\x03\x11W_\x80\xFD[Pa\x01\xBCa\x03 6`\x04a%\x06V[a\x0F\xDBV[4\x80\x15a\x030W_\x80\xFD[Pa\x039a\x10\xDCV[`@Qa\x02@\x91\x90a%\xEFV[4\x80\x15a\x03QW_\x80\xFD[Pa\x03ea\x03`6`\x04a&GV[a\x10\xEDV[`@\x80Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x93\x84\x16\x81R\x92\x90\x91\x16` \x83\x01R\x01a\x02@V[a\x01\xBCa\x11=V[4\x80\x15a\x03\xA5W_\x80\xFD[Pa\x01\xBCa\x03\xB46`\x04a&^V[a\x11oV[4\x80\x15a\x03\xC4W_\x80\xFD[Pa\x03ea\x03\xD36`\x04a#\x9BV[a\x15\xFCV[4\x80\x15a\x03\xE3W_\x80\xFD[P_Ta\x02\x9B\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[4\x80\x15a\x04\x0EW_\x80\xFD[P\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFt\x879'Ta\x02\x9BV[4\x80\x15a\x04AW_\x80\xFD[Pa\x04Ja\x16\xC1V[`@Q\x90\x81R` \x01a\x02@V[4\x80\x15a\x04cW_\x80\xFD[Pa\x01\xBCa\x04r6`\x04a$\xC0V[a\x16\xCCV[4\x80\x15a\x04\x82W_\x80\xFD[P`\x02Ta\x04JV[4\x80\x15a\x04\x96W_\x80\xFD[Pa\x01\xBCa\x04\xA56`\x04a$\xC0V[a\x17aV[a\x01\xBCa\x04\xB86`\x04a$\xC0V[a\x17\xF3V[a\x01\xBCa\x04\xCB6`\x04a$\xC0V[a\x11=V[4\x80\x15a\x04\xDBW_\x80\xFD[Pa\x02\x9B\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[4\x80\x15a\x05\x0EW_\x80\xFD[Pa\x01\xBCa\x18-V[4\x80\x15a\x05\"W_\x80\xFD[Pa\x04Ja\x0516`\x04a$\xC0V[c8\x9Au\xE1`\x0C\x90\x81R_\x91\x90\x91R` \x90 T\x90V[a\x05Pa\x19bV[a'\x10\x83b\xFF\xFF\xFF\x16\x11\x15a\x05\x91W`@Q\x7Fv\xA3\xF9]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a'\x10\x82b\xFF\xFF\xFF\x16\x11\x15a\x05\xD2W`@Q\x7Fv\xA3\xF9]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x86s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x11\x15a\x06\nW\x93\x94\x93[_\x86\x81R` \x86\x90R`@\x81 `(\x1B\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\x81\x16_\x90\x81R`\x03` R`@\x81 T\x91\x92P\x81\x90\x03a\x07MWP`@\x80Q\x80\x82\x01\x82Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x8A\x16\x82R\x88\x81\x16` \x80\x84\x01\x91\x82R`\x02\x80T`\x01\x81\x01\x82U_\x82\x81R\x95Q\x90\x82\x02\x7F@W\x87\xFA\x12\xA8#\xE0\xF2\xB7c\x1C\xC4\x1B;\xA8\x82\x8B3!\xCA\x81\x11\x11\xFAu\xCD:\xA3\xBBZ\xCE\x81\x01\x80T\x92\x87\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x93\x84\x16\x17\x90U\x93Q\x7F@W\x87\xFA\x12\xA8#\xE0\xF2\xB7c\x1C\xC4\x1B;\xA8\x82\x8B3!\xCA\x81\x11\x11\xFAu\xCD:\xA3\xBBZ\xCF\x90\x94\x01\x80T\x94\x90\x95\x16\x93\x16\x92\x90\x92\x17\x90\x92UT\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\x85\x16\x83R`\x03\x90\x91R\x91\x90 \x81\x90U[`@\x80Qa\xFF\xFF\x88\x16\x81Rb\xFF\xFF\xFF\x87\x81\x16` \x83\x01R\x86\x81\x16\x82\x84\x01R\x85\x16``\x82\x01R\x90Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x89\x81\x16\x92\x90\x8B\x16\x91\x7F\xF3%\xA07\xD7\x1E\xFC\x98\xBCA\xDCRW\xED\xEF\xD4:\x1D\x11b\xE2\x067>S\xAF'\x1Az2$\xE9\x91\x81\x90\x03`\x80\x01\x90\xA3`@Q\x7F\x13\x87\x14e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x89\x81\x16`\x04\x83\x01R\x88\x81\x16`$\x83\x01Ra\xFF\xFF\x88\x16`D\x83\x01Rb\xFF\xFF\xFF\x80\x88\x16`d\x84\x01R\x80\x87\x16`\x84\x84\x01R\x85\x16`\xA4\x83\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c\x13\x87\x14e\x90`\xC4\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x08nW_\x80\xFD[PZ\xF1\x15\x80\x15a\x08\x80W=_\x80>=_\xFD[PPPPPPPPPPPPV[a\x08\x96a\x1A\x13V[\x80_[\x81\x81\x10\x15a\ntW6\x84\x84\x83\x81\x81\x10a\x08\xB4Wa\x08\xB4a&\x8FV[\x90P` \x02\x81\x01\x90a\x08\xC6\x91\x90a&\xBCV[\x90P` \x81\x01\x805\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c\xD9\xE1\x7F\x98\x90a\t\x17\x90\x85a$\xC0V[`@Q\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\xE0\x84\x90\x1B\x16\x81Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16`\x04\x82\x01R`$\x81\x01\x84\x90R`D\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\t\x81W_\x80\xFD[PZ\xF1\x15\x80\x15a\t\x93W=_\x80>=_\xFD[PPPP_[a\t\xA6`@\x84\x01\x84a&\xF8V[\x90P\x81\x10\x15a\n1W6a\t\xBD`@\x85\x01\x85a&\xF8V[\x83\x81\x81\x10a\t\xCDWa\t\xCDa&\x8FV[`@\x02\x91\x90\x91\x01\x91Pa\n\x18\x90Pa\t\xE8` \x83\x01\x83a$\xC0V[` \x80\x84\x015\x90a\t\xFB\x90\x88\x01\x88a$\xC0V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91\x90a\x1AJV[a\n&` \x82\x015\x84a'cV[\x92PP`\x01\x01a\t\x99V[P\x80\x15a\njW`@Q\x7F\xB2\x1Cc\xEB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PP`\x01\x01a\x08\x99V[PPPPV[_b\x02\xA3\0g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16B\x01\x90Pc8\x9Au\xE1`\x0CR3_R\x80` `\x0C U3\x7F\xDB\xF3j\x10}\xA1\x9EIRzqv\xA1\xBA\xBF\x96;K\x0F\xF8\xCD\xE3^\xE3]l\xD8\xF1\xF9\xAC~\x1D_\x80\xA2PV[a\n\xCFa\x19bV[`@Q\x7F3\x83\x0EH\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c3\x83\x0EH\x90a\x0BE\x90\x86\x90\x86\x90\x86\x90`\x04\x01a'\xA1V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x0B\\W_\x80\xFD[PZ\xF1\x15\x80\x15a\x0BnW=_\x80>=_\xFD[PPPPPPPV[a\x0B\x7Fa\x1A\x9DV[_\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x0B\x99Wa\x0B\x99a$\xD9V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x0C\x0FW\x81` \x01[`@\x80Q`\xA0\x81\x01\x82R_\x80\x82R` \x80\x83\x01\x82\x90R\x92\x82\x01\x81\x90R``\x82\x01\x81\x90R`\x80\x82\x01R\x82R\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x92\x01\x91\x01\x81a\x0B\xB7W\x90P[P\x90P_[\x82\x81\x10\x15a\x0E\x1BW6\x84\x84\x83\x81\x81\x10a\x0C/Wa\x0C/a&\x8FV[\x90P`\xA0\x02\x01\x90Pa'\x10\x81`@\x01` \x81\x01\x90a\x0CM\x91\x90a(\nV[b\xFF\xFF\xFF\x16\x11\x15a\x0C\x8AW`@Q\x7Fv\xA3\xF9]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a'\x10a\x0C\x9D`\x80\x83\x01``\x84\x01a(\nV[b\xFF\xFF\xFF\x16\x11\x15a\x0C\xDAW`@Q\x7Fv\xA3\xF9]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80a\x0C\xE9` \x84\x01\x84a$\xC0V[a\x0C\xF9`@\x85\x01` \x86\x01a$\xC0V[\x91P\x91P\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x11\x15a\r3W\x90[_\x82\x81R` \x82\x81R`@\x80\x83 \x81Q`\xA0\x81\x01\x83R\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0`(\x92\x90\x92\x1B\x91\x82\x16\x85R`\x03\x90\x93R\x92 T\x81\x90a\r\x8B\x90`\x01\x90a'cV[\x81R` \x01\x82d\xFF\xFF\xFF\xFF\xFF\x19\x16\x81R` \x01\x85`@\x01` \x81\x01\x90a\r\xB1\x91\x90a(\nV[b\xFF\xFF\xFF\x16\x81R` \x01a\r\xCB`\x80\x87\x01``\x88\x01a(\nV[b\xFF\xFF\xFF\x16\x81R` \x01a\r\xE5`\xA0\x87\x01`\x80\x88\x01a(\nV[b\xFF\xFF\xFF\x16\x81RP\x86\x86\x81Q\x81\x10a\r\xFFWa\r\xFFa&\x8FV[` \x02` \x01\x01\x81\x90RPPPPP\x80\x80`\x01\x01\x91PPa\x0C\x14V[P`@Q\x7F\xC9?\x1A\xDDA\xC2\x18\xFAve\xC1\x06\x17\x03?D\x1F\x8E<\x16\xFA7'\x96&TE\xD7\xA1I|#\x90_\x90\xA1_a\x0E\x84\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x1A\xEEV[`@Q\x7FS\xB4\x1CU\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\x90\x91Ps\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90cS\xB4\x1CU\x90a\x0E\xFB\x90\x84\x90\x86\x90`\x04\x01a(#V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x0F\x12W_\x80\xFD[PZ\xF1\x15\x80\x15a\x0F$W=_\x80>=_\xFD[PPPPPPPPV[c8\x9Au\xE1`\x0CR3_R_` `\x0C U3\x7F\xFA{\x8E\xAB}\xA6\x7FA,\xC9W^\xD44dF\x8F\x9B\xFB\xAE\x89\xD1gY\x174l\xA6\xD8\xFE<\x92_\x80\xA2V[a\x0Foa\x1A\x13V[_\x80T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16\x90\x81\x17\x82U`@Q\x90\x91\x7F\xCB\xCF8N&\xC1h6\x17}\x0Bm\x8C\xE7\x05A\xA8o\xF3\t\x1D\xEE\xCA\xF5\xB6\xE0\xFAUd\xC7\x82P\x91\xA2PV[`\x04T`\xFF\x16\x15a\x0F\xE9WPV[`\x04\x80T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\x16`\x01\x17\x90U_[\x81Q\x81\x10\x15a\x10\xD8W_\x82\x82\x81Q\x81\x10a\x102Wa\x102a&\x8FV[` \x02` \x01\x01Q\x90Pa\x10P\x81`\x01a\x1B\x89\x90\x91\x90c\xFF\xFF\xFF\xFF\x16V[a\x10\x86W`@Q\x7F\xEFoR6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x10\x8F\x81a\x1D\rV[`@Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90\x7F\xB2]\x03\xAA\xF3\x08\xD7)\x17\t\xBE\x1E\xA2\x8B\x80\x04c\xCF:\x9ALJUU\xD73:\x96L\x1D\xFE\xBD\x90_\x90\xA2P`\x01\x01a\x10\x16V[PPV[``a\x10\xE8`\x01a\x1D\xF4V[\x90P\x90V[_\x80_`\x02\x84\x81T\x81\x10a\x11\x03Wa\x11\x03a&\x8FV[_\x91\x82R` \x90\x91 `\x02\x90\x91\x02\x01\x80T`\x01\x90\x91\x01Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x91\x82\x16\x96\x91\x16\x94P\x92PPPV[`@Q\x7F\xBF$\x14\x88\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x11wa\x1A\x13V[\x80s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x11\x15a\x11\xADW\x90[_\x82\x81R` \x82\x90R`@\x81 `(\x1B\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\x81\x16_\x90\x81R`\x03` R`@\x81 T\x91\x92P\x81\x90\x03a\x12NW`@Q\x7F\x02\xF5\x1B1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x86\x16`\x04\x83\x01R\x84\x16`$\x82\x01R`D\x01`@Q\x80\x91\x03\x90\xFD[`\x02T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x01\x90\x80\x83\x10\x15a\x13\x99W_`\x02`\x01\x83\x03\x81T\x81\x10a\x12\x94Wa\x12\x94a&\x8FV[_\x91\x82R` \x80\x83 `@\x80Q\x80\x82\x01\x82R`\x02\x94\x90\x94\x02\x90\x91\x01\x80Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16\x80\x86R`\x01\x90\x92\x01T\x16\x84\x84\x01\x81\x90R\x90\x85R\x90\x91R\x82 \x90\x92P`(\x1B\x90P\x81`\x02\x85\x81T\x81\x10a\x12\xFDWa\x12\xFDa&\x8FV[_\x91\x82R` \x80\x83 \x84Q`\x02\x90\x93\x02\x01\x80Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x93\x84\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x82\x16\x17\x82U\x94\x82\x01Q`\x01\x90\x91\x01\x80T\x91\x90\x93\x16\x94\x16\x93\x90\x93\x17\x90U\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\x90\x92\x16\x82R`\x03\x90R`@\x90 \x84\x90UP[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\x84\x16_\x90\x81R`\x03` R`@\x81 U`\x02\x80T\x80a\x13\xDBWa\x13\xDBa(\xE7V[_\x82\x81R` \x81 `\x02\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x93\x01\x92\x83\x02\x01\x80T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x81\x16\x82U`\x01\x91\x90\x91\x01\x80T\x90\x91\x16\x90U\x91Ua\x14\x83\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x1A\xEEV[\x90P_\x80a\x14\xA8s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x16\x88\x87a\x1E\xC8V[\x91P\x91P\x87s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x89s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7Fy\xF6\x12W\x02\x17\xC0\r\xF1(\xC1\xB8(\xDDk2\x1B:p\xAELa\xB7\xA9\x7F\xE4\xA7\x1F\xC1\x9D\xF9\xBA\x84\x84`@Qa\x15\x1E\x92\x91\x90`\x02\x92\x90\x92\x0B\x82Rb\xFF\xFF\xFF\x16` \x82\x01R`@\x01\x90V[`@Q\x80\x91\x03\x90\xA3`@Q\x7F\xDDML\xF6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\x88\x16`\x04\x82\x01Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x81\x16`$\x83\x01R`D\x82\x01\x87\x90R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c\xDDML\xF6\x90`d\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x15\xDBW_\x80\xFD[PZ\xF1\x15\x80\x15a\x15\xEDW=_\x80>=_\xFD[PPPPPPPPPPPPPV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\x81\x16_\x90\x81R`\x03` R`@\x81 T\x81\x90\x80\x82\x03a\x16hW`@Q\x7F_?G\x9C\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_`\x02a\x16v`\x01\x84a'cV[\x81T\x81\x10a\x16\x86Wa\x16\x86a&\x8FV[_\x91\x82R` \x90\x91 `\x02\x90\x91\x02\x01\x80T`\x01\x90\x91\x01Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x91\x82\x16\x97\x91\x16\x95P\x93PPPPV[_a\x10\xE8`\x01a\x1F?V[a\x16\xD4a\x1A\x13V[a\x16\xDF`\x01\x82a\x1B\x89V[a\x17\x15W`@Q\x7F\xEFoR6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90\x7F\xB2]\x03\xAA\xF3\x08\xD7)\x17\t\xBE\x1E\xA2\x8B\x80\x04c\xCF:\x9ALJUU\xD73:\x96L\x1D\xFE\xBD\x90_\x90\xA2a\x17^\x81a\x1D\rV[PV[a\x17ia\x19bV[a\x17t`\x01\x82a\x1F\x90V[a\x17\xAAW`@Q\x7F\\\xD2kh\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90\x7F\xCF\xC2Af\xDBK\xB6w\xE8W\xCA\xCA\xBD\x15A\xFB+0dP!\xB2|Q0A\x95\x89\xB8M\xB5+\x90_\x90\xA2a\x17^\x81a\x1D\rV[a\x17\xFBa\x1A\x13V[c8\x9Au\xE1`\x0CR\x80_R` `\x0C \x80TB\x11\x15a\x18!Wco^\x88\x18_R`\x04`\x1C\xFD[_\x90Ua\x17^\x81a!\x04V[_Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163\x14a\x18}W`@Q\x7F\xB0cJv\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x81U`@Q3\x91\x7F\xAB%\x8A\xFB\xE9\xEB\xB9c\xA1\xBA\xEA\xDB\xB7&_7\xC9_g\xB6\xCApz\xB7\xF5bh\xBC\xB7\xD2\x91\xC8\x91\xA2`@Q\x7F\x92\xEE\xFE\x9B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R3`\x04\x82\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90c\x92\xEE\xFE\x9B\x90`$\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x19PW_\x80\xFD[PZ\xF1\x15\x80\x15a\ntW=_\x80>=_\xFD[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x163\x03a\x19\xA1WV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFt\x879'Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163\x03a\x19\xE1WV[`@Q\x7F)\xAB\x19\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFt\x879'T3\x14a\x1AHWc\x82\xB4)\0_R`\x04`\x1C\xFD[V[\x81`\x14R\x80`4Ro\xA9\x05\x9C\xBB\0\0\0\0\0\0\0\0\0\0\0\0_R` _`D`\x10_\x87Z\xF1\x80`\x01_Q\x14\x16a\x1A\x93W\x80=\x85;\x15\x17\x10a\x1A\x93Wc\x90\xB8\xEC\x18_R`\x04`\x1C\xFD[P_`4RPPPV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x163\x03a\x1A\xDCWV[a\x1A\xE7`\x013a!iV[\x15a\x19\xA1WV[`@Q\x7F|\xF9\x80\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x03`\x04\x82\x01R_\x90\x81\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x16\x90c|\xF9\x80\x81\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x1B[W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1B\x7F\x91\x90a)\x14V[`@\x1C\x93\x92PPPV[c\x97\x8A\xAB\x92`\x04R_\x82\x81R`$\x81 s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x92\x90\x92\x16\x91\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x04I\x80%\xAD+@GA\x83\x01a\x1B\xE7Wc\xF5\xA2g\xF1_R`\x04`\x1C\xFD[\x82a\x1B\xF9Wh\xFB\xB6\x7F\xDAR\xD4\xBF\xB8\xBF\x92P[\x80Tk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x82` R\x80a\x1C\xC0W\x81``\x1C\x80a\x1C,W\x85``\x1B\x84U`\x01\x94PPa\x1D\x04V[\x85\x81\x03a\x1C9WPa\x1D\x04V[`\x01\x84\x01T``\x1C\x80a\x1CZW\x86``\x1B`\x01\x86\x01U`\x01\x95PPPa\x1D\x04V[\x86\x81\x03a\x1ChWPPa\x1D\x04V[`\x02\x85\x01T``\x1C\x80a\x1C\x8AW\x87``\x1B`\x02\x87\x01U`\x01\x96PPPPa\x1D\x04V[\x87\x81\x03a\x1C\x99WPPPa\x1D\x04V[_\x92\x83R`@\x80\x84 `\x01\x90U\x91\x83R\x81\x83 `\x02\x90U\x82R\x90 `\x03\x90UP`\x07\x90\x81\x17\x90[\x84_R`@_ \x80Ta\x1D\x02W`\x01\x91\x82\x1C\x80\x83\x01\x82U\x91\x94P\x81a\x1C\xEEW\x85``\x1B`\x03\x17\x84UPa\x1D\x04V[\x85``\x1B\x82\x85\x01U\x82`\x02\x01\x84UPa\x1D\x04V[P[PPP\x92\x91PPV[`@\x80Q`\x01\x80\x82R\x81\x83\x01\x90\x92R_\x91` \x80\x83\x01\x90\x806\x837\x01\x90PP\x90P\x81\x81_\x81Q\x81\x10a\x1DAWa\x1DAa&\x8FV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x92\x83\x16` \x91\x82\x02\x92\x90\x92\x01\x01R`@Q\x7F\xD6\xCF\xFD\x1E\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x91\x16\x90c\xD6\xCF\xFD\x1E\x90a\x1D\xC3\x90\x84\x90`\x04\x01a%\xEFV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x1D\xDAW_\x80\xFD[PZ\xF1\x15\x80\x15a\x1D\xECW=_\x80>=_\xFD[PPPPPPV[c\x97\x8A\xAB\x92`\x04R_\x81\x81R`$\x81 ``\x91Ph\xFB\xB6\x7F\xDAR\xD4\xBF\xB8\xBF\x81T\x80`\xA0\x1B`\xA0\x1C`@Q\x94P\x84` \x01\x82``\x1C\x92P\x83\x83\x14\x15\x83\x02\x81R\x81a\x1E\x82W\x82\x15a\x1E}W`\x01\x91P\x81\x85\x01T``\x1C\x92P\x82\x15a\x1E}W\x82\x84\x14\x15\x90\x92\x02` \x83\x01RP`\x02\x83\x81\x01T``\x1C\x91\x82\x15a\x1E}W`\x03\x91P\x83\x83\x14\x15\x83\x02`@\x82\x01R[a\x1E\xB2V[`\x01\x91\x82\x1C\x91[\x82\x81\x10\x15a\x1E\xB0W\x85\x81\x01T``\x1C\x85\x81\x14\x15\x81\x02`\x05\x83\x90\x1B\x84\x01R\x93P`\x01\x01a\x1E\x89V[P[\x81\x86R\x81`\x05\x1B\x81\x01`@RPPPPP\x91\x90PV[_\x80\x80a\x1E\xECs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x87\x16\x86\x86a\":V[\x90P\x80a\x1F%W`@Q\x7F/e\x9ED\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\xFF\xFF`\x18\x82\x90\x1C\x16\x96b\xFF\xFF\xFF\x90\x91\x16\x95P\x93PPPPV[c\x97\x8A\xAB\x92`\x04R_\x81\x81R`$\x81 \x80T\x80`\xA0\x1B`\xA0\x1C\x80`\x01\x1C\x93P\x80\x82``\x1C\x15\x17a\x1F\x88W`\x01\x93P\x83\x83\x01T\x15a\x1F\x88W`\x02\x93P\x83\x83\x01T\x15a\x1F\x88W`\x03\x93P[PPP\x91\x90PV[c\x97\x8A\xAB\x92`\x04R_\x82\x81R`$\x81 s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x92\x90\x92\x16\x91\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x04I\x80%\xAD+@GA\x83\x01a\x1F\xEEWc\xF5\xA2g\xF1_R`\x04`\x1C\xFD[\x82a \0Wh\xFB\xB6\x7F\xDAR\xD4\xBF\xB8\xBF\x92P[\x80Tk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x80a \x7FW`\x01\x93P\x84\x82``\x1C\x03a =W`\x01\x83\x01\x80T\x84U`\x02\x84\x01\x80T\x90\x91U_\x90Ua\x1D\x04V[\x84`\x01\x84\x01T``\x1C\x03a ^W`\x02\x83\x01\x80T`\x01\x85\x01U_\x90Ua\x1D\x04V[\x84`\x02\x84\x01T``\x1C\x03a wW_`\x02\x84\x01Ua\x1D\x04V[_\x93Pa\x1D\x04V[\x82` R\x84_R`@_ \x80T\x80a \x98WPPa\x1D\x04V[`\x01\x83`\x01\x1C\x03\x92P\x82`\x01\x82\x03\x14a \xC8W\x82\x85\x01T``\x1C\x80``\x1B`\x01\x83\x03\x87\x01U\x80_RP\x80`@_ U[P\x83T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\x16`\x01\x92\x83\x1B\x17\x82\x17\x90\x93U_\x90\x92UP\x93\x92PPPV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFt\x879'\x80Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x92\x16\x91\x82\x90\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0_\x80\xA3UV[c\x97\x8A\xAB\x92`\x04R_\x82\x81R`$\x81 s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x92\x90\x92\x16\x91\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x04I\x80%\xAD+@GA\x83\x01a!\xC7Wc\xF5\xA2g\xF1_R`\x04`\x1C\xFD[\x82a!\xD9Wh\xFB\xB6\x7F\xDAR\xD4\xBF\xB8\xBF\x92P[\x80Tk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16a\"!W`\x01\x92P\x83\x81``\x1C\x03\x15a\"2W`\x01\x82\x01T``\x1C\x84\x14a\"2W`\x02\x82\x01T``\x1C\x84\x14a\"2W_\x92Pa\"2V[\x81` R\x83_R`@_ T\x15\x15\x92P[PP\x92\x91PPV[_` \x82` \x02`\x01\x01_\x86<PP_Q\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\x81\x16\x91\x90\x91\x14\x02\x91\x90PV[\x805s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\"\x9BW_\x80\xFD[\x91\x90PV[\x805b\xFF\xFF\xFF\x81\x16\x81\x14a\"\x9BW_\x80\xFD[_\x80_\x80_\x80`\xC0\x87\x89\x03\x12\x15a\"\xC7W_\x80\xFD[a\"\xD0\x87a\"xV[\x95Pa\"\xDE` \x88\x01a\"xV[\x94P`@\x87\x015a\xFF\xFF\x81\x16\x81\x14a\"\xF4W_\x80\xFD[\x93Pa#\x02``\x88\x01a\"\xA0V[\x92Pa#\x10`\x80\x88\x01a\"\xA0V[\x91Pa#\x1E`\xA0\x88\x01a\"\xA0V[\x90P\x92\x95P\x92\x95P\x92\x95V[_\x80` \x83\x85\x03\x12\x15a#;W_\x80\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a#QW_\x80\xFD[\x83\x01`\x1F\x81\x01\x85\x13a#aW_\x80\xFD[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a#wW_\x80\xFD[\x85` \x82`\x05\x1B\x84\x01\x01\x11\x15a#\x8BW_\x80\xFD[` \x91\x90\x91\x01\x95\x90\x94P\x92PPPV[_` \x82\x84\x03\x12\x15a#\xABW_\x80\xFD[\x815\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\x81\x16\x81\x14a#\xDAW_\x80\xFD[\x93\x92PPPV[_\x80_`@\x84\x86\x03\x12\x15a#\xF3W_\x80\xFD[a#\xFC\x84a\"xV[\x92P` \x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a$\x17W_\x80\xFD[\x84\x01`\x1F\x81\x01\x86\x13a$'W_\x80\xFD[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a$=W_\x80\xFD[\x86` \x82\x84\x01\x01\x11\x15a$NW_\x80\xFD[\x93\x96` \x91\x90\x91\x01\x95P\x92\x93PPPV[_\x80` \x83\x85\x03\x12\x15a$pW_\x80\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a$\x86W_\x80\xFD[\x83\x01`\x1F\x81\x01\x85\x13a$\x96W_\x80\xFD[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a$\xACW_\x80\xFD[\x85` `\xA0\x83\x02\x84\x01\x01\x11\x15a#\x8BW_\x80\xFD[_` \x82\x84\x03\x12\x15a$\xD0W_\x80\xFD[a#\xDA\x82a\"xV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[_` \x82\x84\x03\x12\x15a%\x16W_\x80\xFD[\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a%,W_\x80\xFD[\x82\x01`\x1F\x81\x01\x84\x13a%<W_\x80\xFD[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a%VWa%Va$\xD9V[\x80`\x05\x1B`@Q\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`?\x83\x01\x16\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a%\xA1Wa%\xA1a$\xD9V[`@R\x91\x82R` \x81\x84\x01\x81\x01\x92\x90\x81\x01\x87\x84\x11\x15a%\xBEW_\x80\xFD[` \x85\x01\x94P[\x83\x85\x10\x15a%\xE4Wa%\xD6\x85a\"xV[\x81R` \x94\x85\x01\x94\x01a%\xC5V[P\x96\x95PPPPPPV[` \x80\x82R\x82Q\x82\x82\x01\x81\x90R_\x91\x84\x01\x90`@\x84\x01\x90\x83[\x81\x81\x10\x15a&<W\x83Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x83R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a&\x08V[P\x90\x95\x94PPPPPV[_` \x82\x84\x03\x12\x15a&WW_\x80\xFD[P5\x91\x90PV[_\x80`@\x83\x85\x03\x12\x15a&oW_\x80\xFD[a&x\x83a\"xV[\x91Pa&\x86` \x84\x01a\"xV[\x90P\x92P\x92\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[_\x825\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xA1\x836\x03\x01\x81\x12a&\xEEW_\x80\xFD[\x91\x90\x91\x01\x92\x91PPV[_\x80\x835\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE1\x846\x03\x01\x81\x12a'+W_\x80\xFD[\x83\x01\x805\x91Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a'EW_\x80\xFD[` \x01\x91P`\x06\x81\x90\x1B6\x03\x82\x13\x15a'\\W_\x80\xFD[\x92P\x92\x90PV[\x81\x81\x03\x81\x81\x11\x15a'\x9BW\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[\x92\x91PPV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x16\x81R`@` \x82\x01R\x81`@\x82\x01R\x81\x83``\x83\x017_\x81\x83\x01``\x90\x81\x01\x91\x90\x91R`\x1F\x90\x92\x01\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x16\x01\x01\x92\x91PPV[_` \x82\x84\x03\x12\x15a(\x1AW_\x80\xFD[a#\xDA\x82a\"\xA0V[_`@\x82\x01s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x85\x16\x83R`@` \x84\x01R\x80\x84Q\x80\x83R``\x85\x01\x91P` \x86\x01\x92P_[\x81\x81\x10\x15a(\xDBW\x83Q\x80Q\x84R\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0` \x82\x01Q\x16` \x85\x01Rb\xFF\xFF\xFF`@\x82\x01Q\x16`@\x85\x01Rb\xFF\xFF\xFF``\x82\x01Q\x16``\x85\x01Rb\xFF\xFF\xFF`\x80\x82\x01Q\x16`\x80\x85\x01RP`\xA0\x83\x01\x92P` \x84\x01\x93P`\x01\x81\x01\x90Pa(\\V[P\x90\x96\x95PPPPPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`1`\x04R`$_\xFD[_` \x82\x84\x03\x12\x15a)$W_\x80\xFD[PQ\x91\x90PV\xFE\xA1dsolcC\0\x08\x1A\0\n",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct StoreKey(alloy::sol_types::private::FixedBytes<27>);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<StoreKey>
        for alloy::sol_types::private::FixedBytes<27> {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::FixedBytes<
                27,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::FixedBytes<27>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::FixedBytes<
                    27,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::FixedBytes<
                    27,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::FixedBytes<
                    27,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        #[automatically_derived]
        impl StoreKey {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from(value: alloy::sol_types::private::FixedBytes<27>) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into(self) -> alloy::sol_types::private::FixedBytes<27> {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for StoreKey {
            type RustType = alloy::sol_types::private::FixedBytes<27>;
            type Token<'a> = <alloy::sol_types::sol_data::FixedBytes<
                27,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::FixedBytes<
                27,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::FixedBytes<
                27,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::FixedBytes<
                    27,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::FixedBytes<
                    27,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for StoreKey {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::FixedBytes<
                    27,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::FixedBytes<
                    27,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::FixedBytes<
                    27,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct Asset { address addr; uint256 total; Distribution[] dists; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Asset {
        #[allow(missing_docs)]
        pub addr: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub total: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub dists: alloy::sol_types::private::Vec<
            <Distribution as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<Distribution>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <Distribution as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Asset> for UnderlyingRustTuple<'_> {
            fn from(value: Asset) -> Self {
                (value.addr, value.total, value.dists)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Asset {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    addr: tuple.0,
                    total: tuple.1,
                    dists: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Asset {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Asset {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.addr,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.total),
                    <alloy::sol_types::sol_data::Array<
                        Distribution,
                    > as alloy_sol_types::SolType>::tokenize(&self.dists),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Asset {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Asset {
            const NAME: &'static str = "Asset";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Asset(address addr,uint256 total,Distribution[] dists)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <Distribution as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <Distribution as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.addr,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.total)
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        Distribution,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.dists)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Asset {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.addr,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.total)
                    + <alloy::sol_types::sol_data::Array<
                        Distribution,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.dists)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.addr,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.total,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    Distribution,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.dists,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct Distribution { address to; uint256 amount; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Distribution {
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Distribution> for UnderlyingRustTuple<'_> {
            fn from(value: Distribution) -> Self {
                (value.to, value.amount)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Distribution {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    to: tuple.0,
                    amount: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Distribution {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Distribution {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Distribution {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Distribution {
            const NAME: &'static str = "Distribution";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Distribution(address to,uint256 amount)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.to,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Distribution {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.to,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.to,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct PoolUpdate { address assetA; address assetB; uint24 bundleFee; uint24 unlockedFee; uint24 protocolUnlockedFee; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PoolUpdate {
        #[allow(missing_docs)]
        pub assetA: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub assetB: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub bundleFee: alloy::sol_types::private::primitives::aliases::U24,
        #[allow(missing_docs)]
        pub unlockedFee: alloy::sol_types::private::primitives::aliases::U24,
        #[allow(missing_docs)]
        pub protocolUnlockedFee: alloy::sol_types::private::primitives::aliases::U24,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<24>,
            alloy::sol_types::sol_data::Uint<24>,
            alloy::sol_types::sol_data::Uint<24>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U24,
            alloy::sol_types::private::primitives::aliases::U24,
            alloy::sol_types::private::primitives::aliases::U24,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<PoolUpdate> for UnderlyingRustTuple<'_> {
            fn from(value: PoolUpdate) -> Self {
                (
                    value.assetA,
                    value.assetB,
                    value.bundleFee,
                    value.unlockedFee,
                    value.protocolUnlockedFee,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for PoolUpdate {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    assetA: tuple.0,
                    assetB: tuple.1,
                    bundleFee: tuple.2,
                    unlockedFee: tuple.3,
                    protocolUnlockedFee: tuple.4,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for PoolUpdate {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for PoolUpdate {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.assetA,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.assetB,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self.bundleFee),
                    <alloy::sol_types::sol_data::Uint<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self.unlockedFee),
                    <alloy::sol_types::sol_data::Uint<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self.protocolUnlockedFee),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for PoolUpdate {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for PoolUpdate {
            const NAME: &'static str = "PoolUpdate";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "PoolUpdate(address assetA,address assetB,uint24 bundleFee,uint24 unlockedFee,uint24 protocolUnlockedFee)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.assetA,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.assetB,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        24,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.bundleFee)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        24,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.unlockedFee)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        24,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.protocolUnlockedFee,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for PoolUpdate {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.assetA,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.assetB,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        24,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.bundleFee,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        24,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.unlockedFee,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        24,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.protocolUnlockedFee,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.assetA,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.assetB,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    24,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.bundleFee,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    24,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.unlockedFee,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    24,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.protocolUnlockedFee,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AlreadyInitialized()` and selector `0x0dc149f0`.
```solidity
error AlreadyInitialized();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AlreadyInitialized {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AlreadyInitialized> for UnderlyingRustTuple<'_> {
            fn from(value: AlreadyInitialized) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AlreadyInitialized {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AlreadyInitialized {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AlreadyInitialized()";
            const SELECTOR: [u8; 4] = [13u8, 193u8, 73u8, 240u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AlreadyNode()` and selector `0xef6f5236`.
```solidity
error AlreadyNode();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AlreadyNode {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AlreadyNode> for UnderlyingRustTuple<'_> {
            fn from(value: AlreadyNode) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AlreadyNode {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AlreadyNode {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AlreadyNode()";
            const SELECTOR: [u8; 4] = [239u8, 111u8, 82u8, 54u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `FeeAboveMax()` and selector `0x76a3f95d`.
```solidity
error FeeAboveMax();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FeeAboveMax {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<FeeAboveMax> for UnderlyingRustTuple<'_> {
            fn from(value: FeeAboveMax) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for FeeAboveMax {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for FeeAboveMax {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "FeeAboveMax()";
            const SELECTOR: [u8; 4] = [118u8, 163u8, 249u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `FunctionDisabled()` and selector `0xbf241488`.
```solidity
error FunctionDisabled();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FunctionDisabled {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<FunctionDisabled> for UnderlyingRustTuple<'_> {
            fn from(value: FunctionDisabled) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for FunctionDisabled {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for FunctionDisabled {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "FunctionDisabled()";
            const SELECTOR: [u8; 4] = [191u8, 36u8, 20u8, 136u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `KeyNotFound()` and selector `0x5f3f479c`.
```solidity
error KeyNotFound();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct KeyNotFound {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<KeyNotFound> for UnderlyingRustTuple<'_> {
            fn from(value: KeyNotFound) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for KeyNotFound {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for KeyNotFound {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "KeyNotFound()";
            const SELECTOR: [u8; 4] = [95u8, 63u8, 71u8, 156u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NewOwnerIsZeroAddress()` and selector `0x7448fbae`.
```solidity
error NewOwnerIsZeroAddress();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NewOwnerIsZeroAddress {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NewOwnerIsZeroAddress> for UnderlyingRustTuple<'_> {
            fn from(value: NewOwnerIsZeroAddress) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NewOwnerIsZeroAddress {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NewOwnerIsZeroAddress {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NewOwnerIsZeroAddress()";
            const SELECTOR: [u8; 4] = [116u8, 72u8, 251u8, 174u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NoEntry()` and selector `0x2f659e44`.
```solidity
error NoEntry();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NoEntry {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NoEntry> for UnderlyingRustTuple<'_> {
            fn from(value: NoEntry) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NoEntry {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NoEntry {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NoEntry()";
            const SELECTOR: [u8; 4] = [47u8, 101u8, 158u8, 68u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NoHandoverRequest()` and selector `0x6f5e8818`.
```solidity
error NoHandoverRequest();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NoHandoverRequest {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NoHandoverRequest> for UnderlyingRustTuple<'_> {
            fn from(value: NoHandoverRequest) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NoHandoverRequest {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NoHandoverRequest {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NoHandoverRequest()";
            const SELECTOR: [u8; 4] = [111u8, 94u8, 136u8, 24u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NonexistentPool(address,address)` and selector `0x02f51b31`.
```solidity
error NonexistentPool(address asset0, address asset1);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NonexistentPool {
        #[allow(missing_docs)]
        pub asset0: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub asset1: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NonexistentPool> for UnderlyingRustTuple<'_> {
            fn from(value: NonexistentPool) -> Self {
                (value.asset0, value.asset1)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NonexistentPool {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    asset0: tuple.0,
                    asset1: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NonexistentPool {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NonexistentPool(address,address)";
            const SELECTOR: [u8; 4] = [2u8, 245u8, 27u8, 49u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.asset0,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.asset1,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotNode()` and selector `0x5cd26b68`.
```solidity
error NotNode();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotNode {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotNode> for UnderlyingRustTuple<'_> {
            fn from(value: NotNode) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotNode {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotNode {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotNode()";
            const SELECTOR: [u8; 4] = [92u8, 210u8, 107u8, 104u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotNodeOrOwner()` and selector `0x29ab190d`.
```solidity
error NotNodeOrOwner();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotNodeOrOwner {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotNodeOrOwner> for UnderlyingRustTuple<'_> {
            fn from(value: NotNodeOrOwner) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotNodeOrOwner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotNodeOrOwner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotNodeOrOwner()";
            const SELECTOR: [u8; 4] = [41u8, 171u8, 25u8, 13u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotSetController()` and selector `0xb0634a76`.
```solidity
error NotSetController();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotSetController {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotSetController> for UnderlyingRustTuple<'_> {
            fn from(value: NotSetController) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotSetController {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotSetController {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotSetController()";
            const SELECTOR: [u8; 4] = [176u8, 99u8, 74u8, 118u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `TotalNotDistributed()` and selector `0xb21c63eb`.
```solidity
error TotalNotDistributed();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TotalNotDistributed {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TotalNotDistributed> for UnderlyingRustTuple<'_> {
            fn from(value: TotalNotDistributed) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for TotalNotDistributed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for TotalNotDistributed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TotalNotDistributed()";
            const SELECTOR: [u8; 4] = [178u8, 28u8, 99u8, 235u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `Unauthorized()` and selector `0x82b42900`.
```solidity
error Unauthorized();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Unauthorized {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Unauthorized> for UnderlyingRustTuple<'_> {
            fn from(value: Unauthorized) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Unauthorized {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for Unauthorized {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "Unauthorized()";
            const SELECTOR: [u8; 4] = [130u8, 180u8, 41u8, 0u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `NewControllerAccepted(address)` and selector `0xab258afbe9ebb963a1baeadbb7265f37c95f67b6ca707ab7f56268bcb7d291c8`.
```solidity
event NewControllerAccepted(address indexed newController);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct NewControllerAccepted {
        #[allow(missing_docs)]
        pub newController: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for NewControllerAccepted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "NewControllerAccepted(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                171u8, 37u8, 138u8, 251u8, 233u8, 235u8, 185u8, 99u8, 161u8, 186u8,
                234u8, 219u8, 183u8, 38u8, 95u8, 55u8, 201u8, 95u8, 103u8, 182u8, 202u8,
                112u8, 122u8, 183u8, 245u8, 98u8, 104u8, 188u8, 183u8, 210u8, 145u8,
                200u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { newController: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.newController.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newController,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for NewControllerAccepted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&NewControllerAccepted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &NewControllerAccepted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `NewControllerSet(address)` and selector `0xcbcf384e26c16836177d0b6d8ce70541a86ff3091deecaf5b6e0fa5564c78250`.
```solidity
event NewControllerSet(address indexed newController);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct NewControllerSet {
        #[allow(missing_docs)]
        pub newController: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for NewControllerSet {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "NewControllerSet(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                203u8, 207u8, 56u8, 78u8, 38u8, 193u8, 104u8, 54u8, 23u8, 125u8, 11u8,
                109u8, 140u8, 231u8, 5u8, 65u8, 168u8, 111u8, 243u8, 9u8, 29u8, 238u8,
                202u8, 245u8, 182u8, 224u8, 250u8, 85u8, 100u8, 199u8, 130u8, 80u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { newController: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.newController.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newController,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for NewControllerSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&NewControllerSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &NewControllerSet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `NodeAdded(address)` and selector `0xb25d03aaf308d7291709be1ea28b800463cf3a9a4c4a5555d7333a964c1dfebd`.
```solidity
event NodeAdded(address indexed node);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct NodeAdded {
        #[allow(missing_docs)]
        pub node: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for NodeAdded {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "NodeAdded(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                178u8, 93u8, 3u8, 170u8, 243u8, 8u8, 215u8, 41u8, 23u8, 9u8, 190u8, 30u8,
                162u8, 139u8, 128u8, 4u8, 99u8, 207u8, 58u8, 154u8, 76u8, 74u8, 85u8,
                85u8, 215u8, 51u8, 58u8, 150u8, 76u8, 29u8, 254u8, 189u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { node: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.node.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.node,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for NodeAdded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&NodeAdded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &NodeAdded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `NodeRemoved(address)` and selector `0xcfc24166db4bb677e857cacabd1541fb2b30645021b27c5130419589b84db52b`.
```solidity
event NodeRemoved(address indexed node);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct NodeRemoved {
        #[allow(missing_docs)]
        pub node: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for NodeRemoved {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "NodeRemoved(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                207u8, 194u8, 65u8, 102u8, 219u8, 75u8, 182u8, 119u8, 232u8, 87u8, 202u8,
                202u8, 189u8, 21u8, 65u8, 251u8, 43u8, 48u8, 100u8, 80u8, 33u8, 178u8,
                124u8, 81u8, 48u8, 65u8, 149u8, 137u8, 184u8, 77u8, 181u8, 43u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { node: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.node.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.node,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for NodeRemoved {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&NodeRemoved> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &NodeRemoved) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `OpaqueBatchPoolUpdate()` and selector `0xc93f1add41c218fa7665c10617033f441f8e3c16fa372796265445d7a1497c23`.
```solidity
event OpaqueBatchPoolUpdate();
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OpaqueBatchPoolUpdate {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OpaqueBatchPoolUpdate {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "OpaqueBatchPoolUpdate()";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                201u8, 63u8, 26u8, 221u8, 65u8, 194u8, 24u8, 250u8, 118u8, 101u8, 193u8,
                6u8, 23u8, 3u8, 63u8, 68u8, 31u8, 142u8, 60u8, 22u8, 250u8, 55u8, 39u8,
                150u8, 38u8, 84u8, 69u8, 215u8, 161u8, 73u8, 124u8, 35u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {}
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OpaqueBatchPoolUpdate {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OpaqueBatchPoolUpdate> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OpaqueBatchPoolUpdate) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `OwnershipHandoverCanceled(address)` and selector `0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92`.
```solidity
event OwnershipHandoverCanceled(address indexed pendingOwner);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OwnershipHandoverCanceled {
        #[allow(missing_docs)]
        pub pendingOwner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipHandoverCanceled {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipHandoverCanceled(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                250u8, 123u8, 142u8, 171u8, 125u8, 166u8, 127u8, 65u8, 44u8, 201u8, 87u8,
                94u8, 212u8, 52u8, 100u8, 70u8, 143u8, 155u8, 251u8, 174u8, 137u8, 209u8,
                103u8, 89u8, 23u8, 52u8, 108u8, 166u8, 216u8, 254u8, 60u8, 146u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { pendingOwner: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.pendingOwner.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.pendingOwner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OwnershipHandoverCanceled {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OwnershipHandoverCanceled> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &OwnershipHandoverCanceled,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `OwnershipHandoverRequested(address)` and selector `0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d`.
```solidity
event OwnershipHandoverRequested(address indexed pendingOwner);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OwnershipHandoverRequested {
        #[allow(missing_docs)]
        pub pendingOwner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipHandoverRequested {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipHandoverRequested(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                219u8, 243u8, 106u8, 16u8, 125u8, 161u8, 158u8, 73u8, 82u8, 122u8, 113u8,
                118u8, 161u8, 186u8, 191u8, 150u8, 59u8, 75u8, 15u8, 248u8, 205u8, 227u8,
                94u8, 227u8, 93u8, 108u8, 216u8, 241u8, 249u8, 172u8, 126u8, 29u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { pendingOwner: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.pendingOwner.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.pendingOwner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OwnershipHandoverRequested {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OwnershipHandoverRequested> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &OwnershipHandoverRequested,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `OwnershipTransferred(address,address)` and selector `0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0`.
```solidity
event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OwnershipTransferred {
        #[allow(missing_docs)]
        pub oldOwner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipTransferred {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipTransferred(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                139u8, 224u8, 7u8, 156u8, 83u8, 22u8, 89u8, 20u8, 19u8, 68u8, 205u8,
                31u8, 208u8, 164u8, 242u8, 132u8, 25u8, 73u8, 127u8, 151u8, 34u8, 163u8,
                218u8, 175u8, 227u8, 180u8, 24u8, 111u8, 107u8, 100u8, 87u8, 224u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    oldOwner: topics.1,
                    newOwner: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.oldOwner.clone(),
                    self.newOwner.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.oldOwner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newOwner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OwnershipTransferred {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OwnershipTransferred> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OwnershipTransferred) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `PoolConfigured(address,address,uint16,uint24,uint24,uint24)` and selector `0xf325a037d71efc98bc41dc5257edefd43a1d1162e206373e53af271a7a3224e9`.
```solidity
event PoolConfigured(address indexed asset0, address indexed asset1, uint16 tickSpacing, uint24 bundleFee, uint24 unlockedFee, uint24 protocolUnlockedFee);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct PoolConfigured {
        #[allow(missing_docs)]
        pub asset0: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub asset1: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub tickSpacing: u16,
        #[allow(missing_docs)]
        pub bundleFee: alloy::sol_types::private::primitives::aliases::U24,
        #[allow(missing_docs)]
        pub unlockedFee: alloy::sol_types::private::primitives::aliases::U24,
        #[allow(missing_docs)]
        pub protocolUnlockedFee: alloy::sol_types::private::primitives::aliases::U24,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for PoolConfigured {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<16>,
                alloy::sol_types::sol_data::Uint<24>,
                alloy::sol_types::sol_data::Uint<24>,
                alloy::sol_types::sol_data::Uint<24>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "PoolConfigured(address,address,uint16,uint24,uint24,uint24)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                243u8, 37u8, 160u8, 55u8, 215u8, 30u8, 252u8, 152u8, 188u8, 65u8, 220u8,
                82u8, 87u8, 237u8, 239u8, 212u8, 58u8, 29u8, 17u8, 98u8, 226u8, 6u8,
                55u8, 62u8, 83u8, 175u8, 39u8, 26u8, 122u8, 50u8, 36u8, 233u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    asset0: topics.1,
                    asset1: topics.2,
                    tickSpacing: data.0,
                    bundleFee: data.1,
                    unlockedFee: data.2,
                    protocolUnlockedFee: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(&self.tickSpacing),
                    <alloy::sol_types::sol_data::Uint<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self.bundleFee),
                    <alloy::sol_types::sol_data::Uint<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self.unlockedFee),
                    <alloy::sol_types::sol_data::Uint<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self.protocolUnlockedFee),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.asset0.clone(), self.asset1.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.asset0,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.asset1,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for PoolConfigured {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&PoolConfigured> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &PoolConfigured) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `PoolRemoved(address,address,int24,uint24)` and selector `0x79f612570217c00df128c1b828dd6b321b3a70ae4c61b7a97fe4a71fc19df9ba`.
```solidity
event PoolRemoved(address indexed asset0, address indexed asset1, int24 tickSpacing, uint24 feeInE6);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct PoolRemoved {
        #[allow(missing_docs)]
        pub asset0: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub asset1: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub tickSpacing: alloy::sol_types::private::primitives::aliases::I24,
        #[allow(missing_docs)]
        pub feeInE6: alloy::sol_types::private::primitives::aliases::U24,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for PoolRemoved {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Int<24>,
                alloy::sol_types::sol_data::Uint<24>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "PoolRemoved(address,address,int24,uint24)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                121u8, 246u8, 18u8, 87u8, 2u8, 23u8, 192u8, 13u8, 241u8, 40u8, 193u8,
                184u8, 40u8, 221u8, 107u8, 50u8, 27u8, 58u8, 112u8, 174u8, 76u8, 97u8,
                183u8, 169u8, 127u8, 228u8, 167u8, 31u8, 193u8, 157u8, 249u8, 186u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    asset0: topics.1,
                    asset1: topics.2,
                    tickSpacing: data.0,
                    feeInE6: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Int<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self.tickSpacing),
                    <alloy::sol_types::sol_data::Uint<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self.feeInE6),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.asset0.clone(), self.asset1.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.asset0,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.asset1,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for PoolRemoved {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&PoolRemoved> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &PoolRemoved) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(address angstrom, address initialOwner, address _fastOwner);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub angstrom: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub initialOwner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _fastOwner: alloy::sol_types::private::Address,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (value.angstrom, value.initialOwner, value._fastOwner)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        angstrom: tuple.0,
                        initialOwner: tuple.1,
                        _fastOwner: tuple.2,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.angstrom,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.initialOwner,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._fastOwner,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `ANGSTROM()` and selector `0xf8098f38`.
```solidity
function ANGSTROM() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ANGSTROMCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`ANGSTROM()`](ANGSTROMCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ANGSTROMReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ANGSTROMCall> for UnderlyingRustTuple<'_> {
                fn from(value: ANGSTROMCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ANGSTROMCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ANGSTROMReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ANGSTROMReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ANGSTROMReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ANGSTROMCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ANGSTROMReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ANGSTROM()";
            const SELECTOR: [u8; 4] = [248u8, 9u8, 143u8, 56u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `acceptNewController()` and selector `0xf86ad98a`.
```solidity
function acceptNewController() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct acceptNewControllerCall {}
    ///Container type for the return parameters of the [`acceptNewController()`](acceptNewControllerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct acceptNewControllerReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<acceptNewControllerCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: acceptNewControllerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for acceptNewControllerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<acceptNewControllerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: acceptNewControllerReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for acceptNewControllerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for acceptNewControllerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = acceptNewControllerReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "acceptNewController()";
            const SELECTOR: [u8; 4] = [248u8, 106u8, 217u8, 138u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `addNode(address)` and selector `0x9d95f1cc`.
```solidity
function addNode(address node) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addNodeCall {
        #[allow(missing_docs)]
        pub node: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`addNode(address)`](addNodeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addNodeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addNodeCall> for UnderlyingRustTuple<'_> {
                fn from(value: addNodeCall) -> Self {
                    (value.node,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addNodeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { node: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addNodeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: addNodeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addNodeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for addNodeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = addNodeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "addNode(address)";
            const SELECTOR: [u8; 4] = [157u8, 149u8, 241u8, 204u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.node,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `batchUpdatePools((address,address,uint24,uint24,uint24)[])` and selector `0x4d2bf47c`.
```solidity
function batchUpdatePools(PoolUpdate[] memory updates) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct batchUpdatePoolsCall {
        #[allow(missing_docs)]
        pub updates: alloy::sol_types::private::Vec<
            <PoolUpdate as alloy::sol_types::SolType>::RustType,
        >,
    }
    ///Container type for the return parameters of the [`batchUpdatePools((address,address,uint24,uint24,uint24)[])`](batchUpdatePoolsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct batchUpdatePoolsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<PoolUpdate>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    <PoolUpdate as alloy::sol_types::SolType>::RustType,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<batchUpdatePoolsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: batchUpdatePoolsCall) -> Self {
                    (value.updates,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for batchUpdatePoolsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { updates: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<batchUpdatePoolsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: batchUpdatePoolsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for batchUpdatePoolsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for batchUpdatePoolsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Array<PoolUpdate>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = batchUpdatePoolsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "batchUpdatePools((address,address,uint24,uint24,uint24)[])";
            const SELECTOR: [u8; 4] = [77u8, 43u8, 244u8, 124u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        PoolUpdate,
                    > as alloy_sol_types::SolType>::tokenize(&self.updates),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `cancelOwnershipHandover()` and selector `0x54d1f13d`.
```solidity
function cancelOwnershipHandover() external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct cancelOwnershipHandoverCall {}
    ///Container type for the return parameters of the [`cancelOwnershipHandover()`](cancelOwnershipHandoverCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct cancelOwnershipHandoverReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<cancelOwnershipHandoverCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: cancelOwnershipHandoverCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for cancelOwnershipHandoverCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<cancelOwnershipHandoverReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: cancelOwnershipHandoverReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for cancelOwnershipHandoverReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for cancelOwnershipHandoverCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = cancelOwnershipHandoverReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "cancelOwnershipHandover()";
            const SELECTOR: [u8; 4] = [84u8, 209u8, 241u8, 61u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `collect_unlock_swap_fees(address,bytes)` and selector `0x33830e48`.
```solidity
function collect_unlock_swap_fees(address to, bytes memory packed_assets) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct collect_unlock_swap_feesCall {
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub packed_assets: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`collect_unlock_swap_fees(address,bytes)`](collect_unlock_swap_feesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct collect_unlock_swap_feesReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<collect_unlock_swap_feesCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: collect_unlock_swap_feesCall) -> Self {
                    (value.to, value.packed_assets)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for collect_unlock_swap_feesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        to: tuple.0,
                        packed_assets: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<collect_unlock_swap_feesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: collect_unlock_swap_feesReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for collect_unlock_swap_feesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for collect_unlock_swap_feesCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = collect_unlock_swap_feesReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "collect_unlock_swap_fees(address,bytes)";
            const SELECTOR: [u8; 4] = [51u8, 131u8, 14u8, 72u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.packed_assets,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `completeOwnershipHandover(address)` and selector `0xf04e283e`.
```solidity
function completeOwnershipHandover(address pendingOwner) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct completeOwnershipHandoverCall {
        #[allow(missing_docs)]
        pub pendingOwner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`completeOwnershipHandover(address)`](completeOwnershipHandoverCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct completeOwnershipHandoverReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<completeOwnershipHandoverCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: completeOwnershipHandoverCall) -> Self {
                    (value.pendingOwner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for completeOwnershipHandoverCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { pendingOwner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<completeOwnershipHandoverReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: completeOwnershipHandoverReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for completeOwnershipHandoverReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for completeOwnershipHandoverCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = completeOwnershipHandoverReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "completeOwnershipHandover(address)";
            const SELECTOR: [u8; 4] = [240u8, 78u8, 40u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.pendingOwner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `configurePool(address,address,uint16,uint24,uint24,uint24)` and selector `0x13871465`.
```solidity
function configurePool(address asset0, address asset1, uint16 tickSpacing, uint24 bundleFee, uint24 unlockedFee, uint24 protocolUnlockedFee) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct configurePoolCall {
        #[allow(missing_docs)]
        pub asset0: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub asset1: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub tickSpacing: u16,
        #[allow(missing_docs)]
        pub bundleFee: alloy::sol_types::private::primitives::aliases::U24,
        #[allow(missing_docs)]
        pub unlockedFee: alloy::sol_types::private::primitives::aliases::U24,
        #[allow(missing_docs)]
        pub protocolUnlockedFee: alloy::sol_types::private::primitives::aliases::U24,
    }
    ///Container type for the return parameters of the [`configurePool(address,address,uint16,uint24,uint24,uint24)`](configurePoolCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct configurePoolReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<16>,
                alloy::sol_types::sol_data::Uint<24>,
                alloy::sol_types::sol_data::Uint<24>,
                alloy::sol_types::sol_data::Uint<24>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                u16,
                alloy::sol_types::private::primitives::aliases::U24,
                alloy::sol_types::private::primitives::aliases::U24,
                alloy::sol_types::private::primitives::aliases::U24,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<configurePoolCall> for UnderlyingRustTuple<'_> {
                fn from(value: configurePoolCall) -> Self {
                    (
                        value.asset0,
                        value.asset1,
                        value.tickSpacing,
                        value.bundleFee,
                        value.unlockedFee,
                        value.protocolUnlockedFee,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for configurePoolCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        asset0: tuple.0,
                        asset1: tuple.1,
                        tickSpacing: tuple.2,
                        bundleFee: tuple.3,
                        unlockedFee: tuple.4,
                        protocolUnlockedFee: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<configurePoolReturn> for UnderlyingRustTuple<'_> {
                fn from(value: configurePoolReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for configurePoolReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for configurePoolCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<16>,
                alloy::sol_types::sol_data::Uint<24>,
                alloy::sol_types::sol_data::Uint<24>,
                alloy::sol_types::sol_data::Uint<24>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = configurePoolReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "configurePool(address,address,uint16,uint24,uint24,uint24)";
            const SELECTOR: [u8; 4] = [19u8, 135u8, 20u8, 101u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.asset0,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.asset1,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(&self.tickSpacing),
                    <alloy::sol_types::sol_data::Uint<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self.bundleFee),
                    <alloy::sol_types::sol_data::Uint<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self.unlockedFee),
                    <alloy::sol_types::sol_data::Uint<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self.protocolUnlockedFee),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `distributeFees((address,uint256,(address,uint256)[])[])` and selector `0x182e6f39`.
```solidity
function distributeFees(Asset[] memory assets) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct distributeFeesCall {
        #[allow(missing_docs)]
        pub assets: alloy::sol_types::private::Vec<
            <Asset as alloy::sol_types::SolType>::RustType,
        >,
    }
    ///Container type for the return parameters of the [`distributeFees((address,uint256,(address,uint256)[])[])`](distributeFeesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct distributeFeesReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Array<Asset>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    <Asset as alloy::sol_types::SolType>::RustType,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<distributeFeesCall> for UnderlyingRustTuple<'_> {
                fn from(value: distributeFeesCall) -> Self {
                    (value.assets,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for distributeFeesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { assets: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<distributeFeesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: distributeFeesReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for distributeFeesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for distributeFeesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Array<Asset>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = distributeFeesReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "distributeFees((address,uint256,(address,uint256)[])[])";
            const SELECTOR: [u8; 4] = [24u8, 46u8, 111u8, 57u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        Asset,
                    > as alloy_sol_types::SolType>::tokenize(&self.assets),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fastOwner()` and selector `0x43a9a71f`.
```solidity
function fastOwner() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fastOwnerCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`fastOwner()`](fastOwnerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fastOwnerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fastOwnerCall> for UnderlyingRustTuple<'_> {
                fn from(value: fastOwnerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fastOwnerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fastOwnerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fastOwnerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fastOwnerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fastOwnerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = fastOwnerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fastOwner()";
            const SELECTOR: [u8; 4] = [67u8, 169u8, 167u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getPoolByIndex(uint256)` and selector `0x6ce0c4b5`.
```solidity
function getPoolByIndex(uint256 index) external view returns (address asset0, address asset1);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPoolByIndexCall {
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getPoolByIndex(uint256)`](getPoolByIndexCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPoolByIndexReturn {
        #[allow(missing_docs)]
        pub asset0: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub asset1: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPoolByIndexCall> for UnderlyingRustTuple<'_> {
                fn from(value: getPoolByIndexCall) -> Self {
                    (value.index,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getPoolByIndexCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { index: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPoolByIndexReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPoolByIndexReturn) -> Self {
                    (value.asset0, value.asset1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPoolByIndexReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        asset0: tuple.0,
                        asset1: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getPoolByIndexCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getPoolByIndexReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getPoolByIndex(uint256)";
            const SELECTOR: [u8; 4] = [108u8, 224u8, 196u8, 181u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getPoolByKey(bytes27)` and selector `0x77e2bf8a`.
```solidity
function getPoolByKey(StoreKey key) external view returns (address asset0, address asset1);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPoolByKeyCall {
        #[allow(missing_docs)]
        pub key: <StoreKey as alloy::sol_types::SolType>::RustType,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getPoolByKey(bytes27)`](getPoolByKeyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPoolByKeyReturn {
        #[allow(missing_docs)]
        pub asset0: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub asset1: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (StoreKey,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <StoreKey as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPoolByKeyCall> for UnderlyingRustTuple<'_> {
                fn from(value: getPoolByKeyCall) -> Self {
                    (value.key,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getPoolByKeyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { key: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPoolByKeyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getPoolByKeyReturn) -> Self {
                    (value.asset0, value.asset1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getPoolByKeyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        asset0: tuple.0,
                        asset1: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getPoolByKeyCall {
            type Parameters<'a> = (StoreKey,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getPoolByKeyReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getPoolByKey(bytes27)";
            const SELECTOR: [u8; 4] = [119u8, 226u8, 191u8, 138u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<StoreKey as alloy_sol_types::SolType>::tokenize(&self.key),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `initStartNodes(address[])` and selector `0x5c1b182d`.
```solidity
function initStartNodes(address[] memory initNodes) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initStartNodesCall {
        #[allow(missing_docs)]
        pub initNodes: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
    }
    ///Container type for the return parameters of the [`initStartNodes(address[])`](initStartNodesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initStartNodesReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initStartNodesCall> for UnderlyingRustTuple<'_> {
                fn from(value: initStartNodesCall) -> Self {
                    (value.initNodes,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initStartNodesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { initNodes: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initStartNodesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: initStartNodesReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initStartNodesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initStartNodesCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initStartNodesReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initStartNodes(address[])";
            const SELECTOR: [u8; 4] = [92u8, 27u8, 24u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.initNodes),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `keyExists(bytes27)` and selector `0x29adecf6`.
```solidity
function keyExists(StoreKey key) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct keyExistsCall {
        #[allow(missing_docs)]
        pub key: <StoreKey as alloy::sol_types::SolType>::RustType,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`keyExists(bytes27)`](keyExistsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct keyExistsReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (StoreKey,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <StoreKey as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<keyExistsCall> for UnderlyingRustTuple<'_> {
                fn from(value: keyExistsCall) -> Self {
                    (value.key,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for keyExistsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { key: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<keyExistsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: keyExistsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for keyExistsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for keyExistsCall {
            type Parameters<'a> = (StoreKey,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = keyExistsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "keyExists(bytes27)";
            const SELECTOR: [u8; 4] = [41u8, 173u8, 236u8, 246u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<StoreKey as alloy_sol_types::SolType>::tokenize(&self.key),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `nodes()` and selector `0x5db82fa0`.
```solidity
function nodes() external view returns (address[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nodesCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`nodes()`](nodesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nodesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nodesCall> for UnderlyingRustTuple<'_> {
                fn from(value: nodesCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for nodesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nodesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: nodesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for nodesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for nodesCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = nodesReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "nodes()";
            const SELECTOR: [u8; 4] = [93u8, 184u8, 47u8, 160u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `owner()` and selector `0x8da5cb5b`.
```solidity
function owner() external view returns (address result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`owner()`](ownerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerCall> for UnderlyingRustTuple<'_> {
                fn from(value: ownerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ownerReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ownerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ownerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "owner()";
            const SELECTOR: [u8; 4] = [141u8, 165u8, 203u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `ownershipHandoverExpiresAt(address)` and selector `0xfee81cf4`.
```solidity
function ownershipHandoverExpiresAt(address pendingOwner) external view returns (uint256 result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownershipHandoverExpiresAtCall {
        #[allow(missing_docs)]
        pub pendingOwner: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`ownershipHandoverExpiresAt(address)`](ownershipHandoverExpiresAtCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownershipHandoverExpiresAtReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownershipHandoverExpiresAtCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: ownershipHandoverExpiresAtCall) -> Self {
                    (value.pendingOwner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for ownershipHandoverExpiresAtCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { pendingOwner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownershipHandoverExpiresAtReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: ownershipHandoverExpiresAtReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for ownershipHandoverExpiresAtReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ownershipHandoverExpiresAtCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ownershipHandoverExpiresAtReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ownershipHandoverExpiresAt(address)";
            const SELECTOR: [u8; 4] = [254u8, 232u8, 28u8, 244u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.pendingOwner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `removeNode(address)` and selector `0xb2b99ec9`.
```solidity
function removeNode(address node) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeNodeCall {
        #[allow(missing_docs)]
        pub node: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`removeNode(address)`](removeNodeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeNodeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeNodeCall> for UnderlyingRustTuple<'_> {
                fn from(value: removeNodeCall) -> Self {
                    (value.node,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for removeNodeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { node: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeNodeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: removeNodeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for removeNodeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for removeNodeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = removeNodeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "removeNode(address)";
            const SELECTOR: [u8; 4] = [178u8, 185u8, 158u8, 201u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.node,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `removePool(address,address)` and selector `0x744b92e2`.
```solidity
function removePool(address asset0, address asset1) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removePoolCall {
        #[allow(missing_docs)]
        pub asset0: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub asset1: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`removePool(address,address)`](removePoolCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removePoolReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removePoolCall> for UnderlyingRustTuple<'_> {
                fn from(value: removePoolCall) -> Self {
                    (value.asset0, value.asset1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for removePoolCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        asset0: tuple.0,
                        asset1: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removePoolReturn> for UnderlyingRustTuple<'_> {
                fn from(value: removePoolReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for removePoolReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for removePoolCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = removePoolReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "removePool(address,address)";
            const SELECTOR: [u8; 4] = [116u8, 75u8, 146u8, 226u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.asset0,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.asset1,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `renounceOwnership()` and selector `0x715018a6`.
```solidity
function renounceOwnership() external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipCall {}
    ///Container type for the return parameters of the [`renounceOwnership()`](renounceOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceOwnershipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceOwnership()";
            const SELECTOR: [u8; 4] = [113u8, 80u8, 24u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `requestOwnershipHandover()` and selector `0x25692962`.
```solidity
function requestOwnershipHandover() external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct requestOwnershipHandoverCall {}
    ///Container type for the return parameters of the [`requestOwnershipHandover()`](requestOwnershipHandoverCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct requestOwnershipHandoverReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<requestOwnershipHandoverCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: requestOwnershipHandoverCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for requestOwnershipHandoverCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<requestOwnershipHandoverReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: requestOwnershipHandoverReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for requestOwnershipHandoverReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for requestOwnershipHandoverCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = requestOwnershipHandoverReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "requestOwnershipHandover()";
            const SELECTOR: [u8; 4] = [37u8, 105u8, 41u8, 98u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setController()` and selector `0x8b2704ec`.
```solidity
function setController() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setControllerCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`setController()`](setControllerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setControllerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setControllerCall> for UnderlyingRustTuple<'_> {
                fn from(value: setControllerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setControllerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setControllerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setControllerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setControllerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setControllerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setControllerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setController()";
            const SELECTOR: [u8; 4] = [139u8, 39u8, 4u8, 236u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setNewController(address)` and selector `0x59baef40`.
```solidity
function setNewController(address newController) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setNewControllerCall {
        #[allow(missing_docs)]
        pub newController: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setNewController(address)`](setNewControllerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setNewControllerReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setNewControllerCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setNewControllerCall) -> Self {
                    (value.newController,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setNewControllerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newController: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setNewControllerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setNewControllerReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setNewControllerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setNewControllerCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setNewControllerReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setNewController(address)";
            const SELECTOR: [u8; 4] = [89u8, 186u8, 239u8, 64u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newController,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `totalNodes()` and selector `0x9592d424`.
```solidity
function totalNodes() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalNodesCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`totalNodes()`](totalNodesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalNodesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalNodesCall> for UnderlyingRustTuple<'_> {
                fn from(value: totalNodesCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for totalNodesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalNodesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: totalNodesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for totalNodesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for totalNodesCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = totalNodesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "totalNodes()";
            const SELECTOR: [u8; 4] = [149u8, 146u8, 212u8, 36u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `totalPools()` and selector `0xab3c7e52`.
```solidity
function totalPools() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalPoolsCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`totalPools()`](totalPoolsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalPoolsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalPoolsCall> for UnderlyingRustTuple<'_> {
                fn from(value: totalPoolsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for totalPoolsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalPoolsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: totalPoolsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for totalPoolsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for totalPoolsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = totalPoolsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "totalPools()";
            const SELECTOR: [u8; 4] = [171u8, 60u8, 126u8, 82u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `transferOwnership(address)` and selector `0xf2fde38b`.
```solidity
function transferOwnership(address) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`transferOwnership(address)`](transferOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferOwnershipCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferOwnership(address)";
            const SELECTOR: [u8; 4] = [242u8, 253u8, 227u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`ControllerV1`](self) function calls.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    pub enum ControllerV1Calls {
        #[allow(missing_docs)]
        ANGSTROM(ANGSTROMCall),
        #[allow(missing_docs)]
        acceptNewController(acceptNewControllerCall),
        #[allow(missing_docs)]
        addNode(addNodeCall),
        #[allow(missing_docs)]
        batchUpdatePools(batchUpdatePoolsCall),
        #[allow(missing_docs)]
        cancelOwnershipHandover(cancelOwnershipHandoverCall),
        #[allow(missing_docs)]
        collect_unlock_swap_fees(collect_unlock_swap_feesCall),
        #[allow(missing_docs)]
        completeOwnershipHandover(completeOwnershipHandoverCall),
        #[allow(missing_docs)]
        configurePool(configurePoolCall),
        #[allow(missing_docs)]
        distributeFees(distributeFeesCall),
        #[allow(missing_docs)]
        fastOwner(fastOwnerCall),
        #[allow(missing_docs)]
        getPoolByIndex(getPoolByIndexCall),
        #[allow(missing_docs)]
        getPoolByKey(getPoolByKeyCall),
        #[allow(missing_docs)]
        initStartNodes(initStartNodesCall),
        #[allow(missing_docs)]
        keyExists(keyExistsCall),
        #[allow(missing_docs)]
        nodes(nodesCall),
        #[allow(missing_docs)]
        owner(ownerCall),
        #[allow(missing_docs)]
        ownershipHandoverExpiresAt(ownershipHandoverExpiresAtCall),
        #[allow(missing_docs)]
        removeNode(removeNodeCall),
        #[allow(missing_docs)]
        removePool(removePoolCall),
        #[allow(missing_docs)]
        renounceOwnership(renounceOwnershipCall),
        #[allow(missing_docs)]
        requestOwnershipHandover(requestOwnershipHandoverCall),
        #[allow(missing_docs)]
        setController(setControllerCall),
        #[allow(missing_docs)]
        setNewController(setNewControllerCall),
        #[allow(missing_docs)]
        totalNodes(totalNodesCall),
        #[allow(missing_docs)]
        totalPools(totalPoolsCall),
        #[allow(missing_docs)]
        transferOwnership(transferOwnershipCall),
    }
    #[automatically_derived]
    impl ControllerV1Calls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [19u8, 135u8, 20u8, 101u8],
            [24u8, 46u8, 111u8, 57u8],
            [37u8, 105u8, 41u8, 98u8],
            [41u8, 173u8, 236u8, 246u8],
            [51u8, 131u8, 14u8, 72u8],
            [67u8, 169u8, 167u8, 31u8],
            [77u8, 43u8, 244u8, 124u8],
            [84u8, 209u8, 241u8, 61u8],
            [89u8, 186u8, 239u8, 64u8],
            [92u8, 27u8, 24u8, 45u8],
            [93u8, 184u8, 47u8, 160u8],
            [108u8, 224u8, 196u8, 181u8],
            [113u8, 80u8, 24u8, 166u8],
            [116u8, 75u8, 146u8, 226u8],
            [119u8, 226u8, 191u8, 138u8],
            [139u8, 39u8, 4u8, 236u8],
            [141u8, 165u8, 203u8, 91u8],
            [149u8, 146u8, 212u8, 36u8],
            [157u8, 149u8, 241u8, 204u8],
            [171u8, 60u8, 126u8, 82u8],
            [178u8, 185u8, 158u8, 201u8],
            [240u8, 78u8, 40u8, 62u8],
            [242u8, 253u8, 227u8, 139u8],
            [248u8, 9u8, 143u8, 56u8],
            [248u8, 106u8, 217u8, 138u8],
            [254u8, 232u8, 28u8, 244u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for ControllerV1Calls {
        const NAME: &'static str = "ControllerV1Calls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 26usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::ANGSTROM(_) => <ANGSTROMCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::acceptNewController(_) => {
                    <acceptNewControllerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::addNode(_) => <addNodeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::batchUpdatePools(_) => {
                    <batchUpdatePoolsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::cancelOwnershipHandover(_) => {
                    <cancelOwnershipHandoverCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::collect_unlock_swap_fees(_) => {
                    <collect_unlock_swap_feesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::completeOwnershipHandover(_) => {
                    <completeOwnershipHandoverCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::configurePool(_) => {
                    <configurePoolCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::distributeFees(_) => {
                    <distributeFeesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::fastOwner(_) => {
                    <fastOwnerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getPoolByIndex(_) => {
                    <getPoolByIndexCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getPoolByKey(_) => {
                    <getPoolByKeyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::initStartNodes(_) => {
                    <initStartNodesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::keyExists(_) => {
                    <keyExistsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::nodes(_) => <nodesCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::owner(_) => <ownerCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::ownershipHandoverExpiresAt(_) => {
                    <ownershipHandoverExpiresAtCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::removeNode(_) => {
                    <removeNodeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::removePool(_) => {
                    <removePoolCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::renounceOwnership(_) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::requestOwnershipHandover(_) => {
                    <requestOwnershipHandoverCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setController(_) => {
                    <setControllerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setNewController(_) => {
                    <setNewControllerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::totalNodes(_) => {
                    <totalNodesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::totalPools(_) => {
                    <totalPoolsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transferOwnership(_) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<ControllerV1Calls>] = &[
                {
                    fn configurePool(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Calls> {
                        <configurePoolCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Calls::configurePool)
                    }
                    configurePool
                },
                {
                    fn distributeFees(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Calls> {
                        <distributeFeesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Calls::distributeFees)
                    }
                    distributeFees
                },
                {
                    fn requestOwnershipHandover(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Calls> {
                        <requestOwnershipHandoverCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Calls::requestOwnershipHandover)
                    }
                    requestOwnershipHandover
                },
                {
                    fn keyExists(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Calls> {
                        <keyExistsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Calls::keyExists)
                    }
                    keyExists
                },
                {
                    fn collect_unlock_swap_fees(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Calls> {
                        <collect_unlock_swap_feesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Calls::collect_unlock_swap_fees)
                    }
                    collect_unlock_swap_fees
                },
                {
                    fn fastOwner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Calls> {
                        <fastOwnerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Calls::fastOwner)
                    }
                    fastOwner
                },
                {
                    fn batchUpdatePools(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Calls> {
                        <batchUpdatePoolsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Calls::batchUpdatePools)
                    }
                    batchUpdatePools
                },
                {
                    fn cancelOwnershipHandover(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Calls> {
                        <cancelOwnershipHandoverCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Calls::cancelOwnershipHandover)
                    }
                    cancelOwnershipHandover
                },
                {
                    fn setNewController(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Calls> {
                        <setNewControllerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Calls::setNewController)
                    }
                    setNewController
                },
                {
                    fn initStartNodes(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Calls> {
                        <initStartNodesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Calls::initStartNodes)
                    }
                    initStartNodes
                },
                {
                    fn nodes(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Calls> {
                        <nodesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Calls::nodes)
                    }
                    nodes
                },
                {
                    fn getPoolByIndex(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Calls> {
                        <getPoolByIndexCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Calls::getPoolByIndex)
                    }
                    getPoolByIndex
                },
                {
                    fn renounceOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Calls> {
                        <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Calls::renounceOwnership)
                    }
                    renounceOwnership
                },
                {
                    fn removePool(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Calls> {
                        <removePoolCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Calls::removePool)
                    }
                    removePool
                },
                {
                    fn getPoolByKey(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Calls> {
                        <getPoolByKeyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Calls::getPoolByKey)
                    }
                    getPoolByKey
                },
                {
                    fn setController(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Calls> {
                        <setControllerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Calls::setController)
                    }
                    setController
                },
                {
                    fn owner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Calls> {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Calls::owner)
                    }
                    owner
                },
                {
                    fn totalNodes(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Calls> {
                        <totalNodesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Calls::totalNodes)
                    }
                    totalNodes
                },
                {
                    fn addNode(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Calls> {
                        <addNodeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Calls::addNode)
                    }
                    addNode
                },
                {
                    fn totalPools(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Calls> {
                        <totalPoolsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Calls::totalPools)
                    }
                    totalPools
                },
                {
                    fn removeNode(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Calls> {
                        <removeNodeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Calls::removeNode)
                    }
                    removeNode
                },
                {
                    fn completeOwnershipHandover(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Calls> {
                        <completeOwnershipHandoverCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Calls::completeOwnershipHandover)
                    }
                    completeOwnershipHandover
                },
                {
                    fn transferOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Calls> {
                        <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Calls::transferOwnership)
                    }
                    transferOwnership
                },
                {
                    fn ANGSTROM(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Calls> {
                        <ANGSTROMCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Calls::ANGSTROM)
                    }
                    ANGSTROM
                },
                {
                    fn acceptNewController(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Calls> {
                        <acceptNewControllerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Calls::acceptNewController)
                    }
                    acceptNewController
                },
                {
                    fn ownershipHandoverExpiresAt(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Calls> {
                        <ownershipHandoverExpiresAtCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Calls::ownershipHandoverExpiresAt)
                    }
                    ownershipHandoverExpiresAt
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::ANGSTROM(inner) => {
                    <ANGSTROMCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::acceptNewController(inner) => {
                    <acceptNewControllerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::addNode(inner) => {
                    <addNodeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::batchUpdatePools(inner) => {
                    <batchUpdatePoolsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::cancelOwnershipHandover(inner) => {
                    <cancelOwnershipHandoverCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::collect_unlock_swap_fees(inner) => {
                    <collect_unlock_swap_feesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::completeOwnershipHandover(inner) => {
                    <completeOwnershipHandoverCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::configurePool(inner) => {
                    <configurePoolCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::distributeFees(inner) => {
                    <distributeFeesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::fastOwner(inner) => {
                    <fastOwnerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getPoolByIndex(inner) => {
                    <getPoolByIndexCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getPoolByKey(inner) => {
                    <getPoolByKeyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::initStartNodes(inner) => {
                    <initStartNodesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::keyExists(inner) => {
                    <keyExistsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::nodes(inner) => {
                    <nodesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::ownershipHandoverExpiresAt(inner) => {
                    <ownershipHandoverExpiresAtCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::removeNode(inner) => {
                    <removeNodeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::removePool(inner) => {
                    <removePoolCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::requestOwnershipHandover(inner) => {
                    <requestOwnershipHandoverCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setController(inner) => {
                    <setControllerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setNewController(inner) => {
                    <setNewControllerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::totalNodes(inner) => {
                    <totalNodesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::totalPools(inner) => {
                    <totalPoolsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::ANGSTROM(inner) => {
                    <ANGSTROMCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::acceptNewController(inner) => {
                    <acceptNewControllerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::addNode(inner) => {
                    <addNodeCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::batchUpdatePools(inner) => {
                    <batchUpdatePoolsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::cancelOwnershipHandover(inner) => {
                    <cancelOwnershipHandoverCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::collect_unlock_swap_fees(inner) => {
                    <collect_unlock_swap_feesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::completeOwnershipHandover(inner) => {
                    <completeOwnershipHandoverCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::configurePool(inner) => {
                    <configurePoolCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::distributeFees(inner) => {
                    <distributeFeesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::fastOwner(inner) => {
                    <fastOwnerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getPoolByIndex(inner) => {
                    <getPoolByIndexCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getPoolByKey(inner) => {
                    <getPoolByKeyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::initStartNodes(inner) => {
                    <initStartNodesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::keyExists(inner) => {
                    <keyExistsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::nodes(inner) => {
                    <nodesCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::ownershipHandoverExpiresAt(inner) => {
                    <ownershipHandoverExpiresAtCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::removeNode(inner) => {
                    <removeNodeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::removePool(inner) => {
                    <removePoolCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::requestOwnershipHandover(inner) => {
                    <requestOwnershipHandoverCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setController(inner) => {
                    <setControllerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setNewController(inner) => {
                    <setNewControllerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::totalNodes(inner) => {
                    <totalNodesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::totalPools(inner) => {
                    <totalPoolsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`ControllerV1`](self) custom errors.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum ControllerV1Errors {
        #[allow(missing_docs)]
        AlreadyInitialized(AlreadyInitialized),
        #[allow(missing_docs)]
        AlreadyNode(AlreadyNode),
        #[allow(missing_docs)]
        FeeAboveMax(FeeAboveMax),
        #[allow(missing_docs)]
        FunctionDisabled(FunctionDisabled),
        #[allow(missing_docs)]
        KeyNotFound(KeyNotFound),
        #[allow(missing_docs)]
        NewOwnerIsZeroAddress(NewOwnerIsZeroAddress),
        #[allow(missing_docs)]
        NoEntry(NoEntry),
        #[allow(missing_docs)]
        NoHandoverRequest(NoHandoverRequest),
        #[allow(missing_docs)]
        NonexistentPool(NonexistentPool),
        #[allow(missing_docs)]
        NotNode(NotNode),
        #[allow(missing_docs)]
        NotNodeOrOwner(NotNodeOrOwner),
        #[allow(missing_docs)]
        NotSetController(NotSetController),
        #[allow(missing_docs)]
        TotalNotDistributed(TotalNotDistributed),
        #[allow(missing_docs)]
        Unauthorized(Unauthorized),
    }
    #[automatically_derived]
    impl ControllerV1Errors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [2u8, 245u8, 27u8, 49u8],
            [13u8, 193u8, 73u8, 240u8],
            [41u8, 171u8, 25u8, 13u8],
            [47u8, 101u8, 158u8, 68u8],
            [92u8, 210u8, 107u8, 104u8],
            [95u8, 63u8, 71u8, 156u8],
            [111u8, 94u8, 136u8, 24u8],
            [116u8, 72u8, 251u8, 174u8],
            [118u8, 163u8, 249u8, 93u8],
            [130u8, 180u8, 41u8, 0u8],
            [176u8, 99u8, 74u8, 118u8],
            [178u8, 28u8, 99u8, 235u8],
            [191u8, 36u8, 20u8, 136u8],
            [239u8, 111u8, 82u8, 54u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for ControllerV1Errors {
        const NAME: &'static str = "ControllerV1Errors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 14usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AlreadyInitialized(_) => {
                    <AlreadyInitialized as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AlreadyNode(_) => {
                    <AlreadyNode as alloy_sol_types::SolError>::SELECTOR
                }
                Self::FeeAboveMax(_) => {
                    <FeeAboveMax as alloy_sol_types::SolError>::SELECTOR
                }
                Self::FunctionDisabled(_) => {
                    <FunctionDisabled as alloy_sol_types::SolError>::SELECTOR
                }
                Self::KeyNotFound(_) => {
                    <KeyNotFound as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NewOwnerIsZeroAddress(_) => {
                    <NewOwnerIsZeroAddress as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NoEntry(_) => <NoEntry as alloy_sol_types::SolError>::SELECTOR,
                Self::NoHandoverRequest(_) => {
                    <NoHandoverRequest as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NonexistentPool(_) => {
                    <NonexistentPool as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotNode(_) => <NotNode as alloy_sol_types::SolError>::SELECTOR,
                Self::NotNodeOrOwner(_) => {
                    <NotNodeOrOwner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotSetController(_) => {
                    <NotSetController as alloy_sol_types::SolError>::SELECTOR
                }
                Self::TotalNotDistributed(_) => {
                    <TotalNotDistributed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::Unauthorized(_) => {
                    <Unauthorized as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<ControllerV1Errors>] = &[
                {
                    fn NonexistentPool(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Errors> {
                        <NonexistentPool as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Errors::NonexistentPool)
                    }
                    NonexistentPool
                },
                {
                    fn AlreadyInitialized(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Errors> {
                        <AlreadyInitialized as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Errors::AlreadyInitialized)
                    }
                    AlreadyInitialized
                },
                {
                    fn NotNodeOrOwner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Errors> {
                        <NotNodeOrOwner as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Errors::NotNodeOrOwner)
                    }
                    NotNodeOrOwner
                },
                {
                    fn NoEntry(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Errors> {
                        <NoEntry as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Errors::NoEntry)
                    }
                    NoEntry
                },
                {
                    fn NotNode(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Errors> {
                        <NotNode as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Errors::NotNode)
                    }
                    NotNode
                },
                {
                    fn KeyNotFound(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Errors> {
                        <KeyNotFound as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Errors::KeyNotFound)
                    }
                    KeyNotFound
                },
                {
                    fn NoHandoverRequest(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Errors> {
                        <NoHandoverRequest as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Errors::NoHandoverRequest)
                    }
                    NoHandoverRequest
                },
                {
                    fn NewOwnerIsZeroAddress(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Errors> {
                        <NewOwnerIsZeroAddress as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Errors::NewOwnerIsZeroAddress)
                    }
                    NewOwnerIsZeroAddress
                },
                {
                    fn FeeAboveMax(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Errors> {
                        <FeeAboveMax as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Errors::FeeAboveMax)
                    }
                    FeeAboveMax
                },
                {
                    fn Unauthorized(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Errors> {
                        <Unauthorized as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Errors::Unauthorized)
                    }
                    Unauthorized
                },
                {
                    fn NotSetController(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Errors> {
                        <NotSetController as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Errors::NotSetController)
                    }
                    NotSetController
                },
                {
                    fn TotalNotDistributed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Errors> {
                        <TotalNotDistributed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Errors::TotalNotDistributed)
                    }
                    TotalNotDistributed
                },
                {
                    fn FunctionDisabled(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Errors> {
                        <FunctionDisabled as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Errors::FunctionDisabled)
                    }
                    FunctionDisabled
                },
                {
                    fn AlreadyNode(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ControllerV1Errors> {
                        <AlreadyNode as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ControllerV1Errors::AlreadyNode)
                    }
                    AlreadyNode
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AlreadyInitialized(inner) => {
                    <AlreadyInitialized as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AlreadyNode(inner) => {
                    <AlreadyNode as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::FeeAboveMax(inner) => {
                    <FeeAboveMax as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::FunctionDisabled(inner) => {
                    <FunctionDisabled as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::KeyNotFound(inner) => {
                    <KeyNotFound as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::NewOwnerIsZeroAddress(inner) => {
                    <NewOwnerIsZeroAddress as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NoEntry(inner) => {
                    <NoEntry as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::NoHandoverRequest(inner) => {
                    <NoHandoverRequest as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NonexistentPool(inner) => {
                    <NonexistentPool as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotNode(inner) => {
                    <NotNode as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::NotNodeOrOwner(inner) => {
                    <NotNodeOrOwner as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotSetController(inner) => {
                    <NotSetController as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TotalNotDistributed(inner) => {
                    <TotalNotDistributed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::Unauthorized(inner) => {
                    <Unauthorized as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AlreadyInitialized(inner) => {
                    <AlreadyInitialized as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AlreadyNode(inner) => {
                    <AlreadyNode as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::FeeAboveMax(inner) => {
                    <FeeAboveMax as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::FunctionDisabled(inner) => {
                    <FunctionDisabled as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::KeyNotFound(inner) => {
                    <KeyNotFound as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NewOwnerIsZeroAddress(inner) => {
                    <NewOwnerIsZeroAddress as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NoEntry(inner) => {
                    <NoEntry as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::NoHandoverRequest(inner) => {
                    <NoHandoverRequest as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NonexistentPool(inner) => {
                    <NonexistentPool as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotNode(inner) => {
                    <NotNode as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::NotNodeOrOwner(inner) => {
                    <NotNodeOrOwner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotSetController(inner) => {
                    <NotSetController as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TotalNotDistributed(inner) => {
                    <TotalNotDistributed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::Unauthorized(inner) => {
                    <Unauthorized as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`ControllerV1`](self) events.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum ControllerV1Events {
        #[allow(missing_docs)]
        NewControllerAccepted(NewControllerAccepted),
        #[allow(missing_docs)]
        NewControllerSet(NewControllerSet),
        #[allow(missing_docs)]
        NodeAdded(NodeAdded),
        #[allow(missing_docs)]
        NodeRemoved(NodeRemoved),
        #[allow(missing_docs)]
        OpaqueBatchPoolUpdate(OpaqueBatchPoolUpdate),
        #[allow(missing_docs)]
        OwnershipHandoverCanceled(OwnershipHandoverCanceled),
        #[allow(missing_docs)]
        OwnershipHandoverRequested(OwnershipHandoverRequested),
        #[allow(missing_docs)]
        OwnershipTransferred(OwnershipTransferred),
        #[allow(missing_docs)]
        PoolConfigured(PoolConfigured),
        #[allow(missing_docs)]
        PoolRemoved(PoolRemoved),
    }
    #[automatically_derived]
    impl ControllerV1Events {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                121u8, 246u8, 18u8, 87u8, 2u8, 23u8, 192u8, 13u8, 241u8, 40u8, 193u8,
                184u8, 40u8, 221u8, 107u8, 50u8, 27u8, 58u8, 112u8, 174u8, 76u8, 97u8,
                183u8, 169u8, 127u8, 228u8, 167u8, 31u8, 193u8, 157u8, 249u8, 186u8,
            ],
            [
                139u8, 224u8, 7u8, 156u8, 83u8, 22u8, 89u8, 20u8, 19u8, 68u8, 205u8,
                31u8, 208u8, 164u8, 242u8, 132u8, 25u8, 73u8, 127u8, 151u8, 34u8, 163u8,
                218u8, 175u8, 227u8, 180u8, 24u8, 111u8, 107u8, 100u8, 87u8, 224u8,
            ],
            [
                171u8, 37u8, 138u8, 251u8, 233u8, 235u8, 185u8, 99u8, 161u8, 186u8,
                234u8, 219u8, 183u8, 38u8, 95u8, 55u8, 201u8, 95u8, 103u8, 182u8, 202u8,
                112u8, 122u8, 183u8, 245u8, 98u8, 104u8, 188u8, 183u8, 210u8, 145u8,
                200u8,
            ],
            [
                178u8, 93u8, 3u8, 170u8, 243u8, 8u8, 215u8, 41u8, 23u8, 9u8, 190u8, 30u8,
                162u8, 139u8, 128u8, 4u8, 99u8, 207u8, 58u8, 154u8, 76u8, 74u8, 85u8,
                85u8, 215u8, 51u8, 58u8, 150u8, 76u8, 29u8, 254u8, 189u8,
            ],
            [
                201u8, 63u8, 26u8, 221u8, 65u8, 194u8, 24u8, 250u8, 118u8, 101u8, 193u8,
                6u8, 23u8, 3u8, 63u8, 68u8, 31u8, 142u8, 60u8, 22u8, 250u8, 55u8, 39u8,
                150u8, 38u8, 84u8, 69u8, 215u8, 161u8, 73u8, 124u8, 35u8,
            ],
            [
                203u8, 207u8, 56u8, 78u8, 38u8, 193u8, 104u8, 54u8, 23u8, 125u8, 11u8,
                109u8, 140u8, 231u8, 5u8, 65u8, 168u8, 111u8, 243u8, 9u8, 29u8, 238u8,
                202u8, 245u8, 182u8, 224u8, 250u8, 85u8, 100u8, 199u8, 130u8, 80u8,
            ],
            [
                207u8, 194u8, 65u8, 102u8, 219u8, 75u8, 182u8, 119u8, 232u8, 87u8, 202u8,
                202u8, 189u8, 21u8, 65u8, 251u8, 43u8, 48u8, 100u8, 80u8, 33u8, 178u8,
                124u8, 81u8, 48u8, 65u8, 149u8, 137u8, 184u8, 77u8, 181u8, 43u8,
            ],
            [
                219u8, 243u8, 106u8, 16u8, 125u8, 161u8, 158u8, 73u8, 82u8, 122u8, 113u8,
                118u8, 161u8, 186u8, 191u8, 150u8, 59u8, 75u8, 15u8, 248u8, 205u8, 227u8,
                94u8, 227u8, 93u8, 108u8, 216u8, 241u8, 249u8, 172u8, 126u8, 29u8,
            ],
            [
                243u8, 37u8, 160u8, 55u8, 215u8, 30u8, 252u8, 152u8, 188u8, 65u8, 220u8,
                82u8, 87u8, 237u8, 239u8, 212u8, 58u8, 29u8, 17u8, 98u8, 226u8, 6u8,
                55u8, 62u8, 83u8, 175u8, 39u8, 26u8, 122u8, 50u8, 36u8, 233u8,
            ],
            [
                250u8, 123u8, 142u8, 171u8, 125u8, 166u8, 127u8, 65u8, 44u8, 201u8, 87u8,
                94u8, 212u8, 52u8, 100u8, 70u8, 143u8, 155u8, 251u8, 174u8, 137u8, 209u8,
                103u8, 89u8, 23u8, 52u8, 108u8, 166u8, 216u8, 254u8, 60u8, 146u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for ControllerV1Events {
        const NAME: &'static str = "ControllerV1Events";
        const COUNT: usize = 10usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(
                    <NewControllerAccepted as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <NewControllerAccepted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::NewControllerAccepted)
                }
                Some(<NewControllerSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <NewControllerSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::NewControllerSet)
                }
                Some(<NodeAdded as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <NodeAdded as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::NodeAdded)
                }
                Some(<NodeRemoved as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <NodeRemoved as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::NodeRemoved)
                }
                Some(
                    <OpaqueBatchPoolUpdate as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OpaqueBatchPoolUpdate as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::OpaqueBatchPoolUpdate)
                }
                Some(
                    <OwnershipHandoverCanceled as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OwnershipHandoverCanceled as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::OwnershipHandoverCanceled)
                }
                Some(
                    <OwnershipHandoverRequested as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OwnershipHandoverRequested as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::OwnershipHandoverRequested)
                }
                Some(
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::OwnershipTransferred)
                }
                Some(<PoolConfigured as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <PoolConfigured as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::PoolConfigured)
                }
                Some(<PoolRemoved as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <PoolRemoved as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::PoolRemoved)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for ControllerV1Events {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::NewControllerAccepted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::NewControllerSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::NodeAdded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::NodeRemoved(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OpaqueBatchPoolUpdate(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OwnershipHandoverCanceled(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OwnershipHandoverRequested(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::PoolConfigured(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::PoolRemoved(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::NewControllerAccepted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::NewControllerSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::NodeAdded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::NodeRemoved(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OpaqueBatchPoolUpdate(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OwnershipHandoverCanceled(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OwnershipHandoverRequested(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::PoolConfigured(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::PoolRemoved(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`ControllerV1`](self) contract instance.

See the [wrapper's documentation](`ControllerV1Instance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> ControllerV1Instance<T, P, N> {
        ControllerV1Instance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        angstrom: alloy::sol_types::private::Address,
        initialOwner: alloy::sol_types::private::Address,
        _fastOwner: alloy::sol_types::private::Address,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<ControllerV1Instance<T, P, N>>,
    > {
        ControllerV1Instance::<
            T,
            P,
            N,
        >::deploy(provider, angstrom, initialOwner, _fastOwner)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        angstrom: alloy::sol_types::private::Address,
        initialOwner: alloy::sol_types::private::Address,
        _fastOwner: alloy::sol_types::private::Address,
    ) -> alloy_contract::RawCallBuilder<T, P, N> {
        ControllerV1Instance::<
            T,
            P,
            N,
        >::deploy_builder(provider, angstrom, initialOwner, _fastOwner)
    }
    /**A [`ControllerV1`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`ControllerV1`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct ControllerV1Instance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for ControllerV1Instance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("ControllerV1Instance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > ControllerV1Instance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`ControllerV1`](self) contract instance.

See the [wrapper's documentation](`ControllerV1Instance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            angstrom: alloy::sol_types::private::Address,
            initialOwner: alloy::sol_types::private::Address,
            _fastOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::Result<ControllerV1Instance<T, P, N>> {
            let call_builder = Self::deploy_builder(
                provider,
                angstrom,
                initialOwner,
                _fastOwner,
            );
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            angstrom: alloy::sol_types::private::Address,
            initialOwner: alloy::sol_types::private::Address,
            _fastOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            angstrom,
                            initialOwner,
                            _fastOwner,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> ControllerV1Instance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> ControllerV1Instance<T, P, N> {
            ControllerV1Instance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > ControllerV1Instance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`ANGSTROM`] function.
        pub fn ANGSTROM(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, ANGSTROMCall, N> {
            self.call_builder(&ANGSTROMCall {})
        }
        ///Creates a new call builder for the [`acceptNewController`] function.
        pub fn acceptNewController(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, acceptNewControllerCall, N> {
            self.call_builder(&acceptNewControllerCall {})
        }
        ///Creates a new call builder for the [`addNode`] function.
        pub fn addNode(
            &self,
            node: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, addNodeCall, N> {
            self.call_builder(&addNodeCall { node })
        }
        ///Creates a new call builder for the [`batchUpdatePools`] function.
        pub fn batchUpdatePools(
            &self,
            updates: alloy::sol_types::private::Vec<
                <PoolUpdate as alloy::sol_types::SolType>::RustType,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, batchUpdatePoolsCall, N> {
            self.call_builder(&batchUpdatePoolsCall { updates })
        }
        ///Creates a new call builder for the [`cancelOwnershipHandover`] function.
        pub fn cancelOwnershipHandover(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, cancelOwnershipHandoverCall, N> {
            self.call_builder(&cancelOwnershipHandoverCall {})
        }
        ///Creates a new call builder for the [`collect_unlock_swap_fees`] function.
        pub fn collect_unlock_swap_fees(
            &self,
            to: alloy::sol_types::private::Address,
            packed_assets: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, collect_unlock_swap_feesCall, N> {
            self.call_builder(
                &collect_unlock_swap_feesCall {
                    to,
                    packed_assets,
                },
            )
        }
        ///Creates a new call builder for the [`completeOwnershipHandover`] function.
        pub fn completeOwnershipHandover(
            &self,
            pendingOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, completeOwnershipHandoverCall, N> {
            self.call_builder(
                &completeOwnershipHandoverCall {
                    pendingOwner,
                },
            )
        }
        ///Creates a new call builder for the [`configurePool`] function.
        pub fn configurePool(
            &self,
            asset0: alloy::sol_types::private::Address,
            asset1: alloy::sol_types::private::Address,
            tickSpacing: u16,
            bundleFee: alloy::sol_types::private::primitives::aliases::U24,
            unlockedFee: alloy::sol_types::private::primitives::aliases::U24,
            protocolUnlockedFee: alloy::sol_types::private::primitives::aliases::U24,
        ) -> alloy_contract::SolCallBuilder<T, &P, configurePoolCall, N> {
            self.call_builder(
                &configurePoolCall {
                    asset0,
                    asset1,
                    tickSpacing,
                    bundleFee,
                    unlockedFee,
                    protocolUnlockedFee,
                },
            )
        }
        ///Creates a new call builder for the [`distributeFees`] function.
        pub fn distributeFees(
            &self,
            assets: alloy::sol_types::private::Vec<
                <Asset as alloy::sol_types::SolType>::RustType,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, distributeFeesCall, N> {
            self.call_builder(&distributeFeesCall { assets })
        }
        ///Creates a new call builder for the [`fastOwner`] function.
        pub fn fastOwner(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, fastOwnerCall, N> {
            self.call_builder(&fastOwnerCall {})
        }
        ///Creates a new call builder for the [`getPoolByIndex`] function.
        pub fn getPoolByIndex(
            &self,
            index: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getPoolByIndexCall, N> {
            self.call_builder(&getPoolByIndexCall { index })
        }
        ///Creates a new call builder for the [`getPoolByKey`] function.
        pub fn getPoolByKey(
            &self,
            key: <StoreKey as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, getPoolByKeyCall, N> {
            self.call_builder(&getPoolByKeyCall { key })
        }
        ///Creates a new call builder for the [`initStartNodes`] function.
        pub fn initStartNodes(
            &self,
            initNodes: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
        ) -> alloy_contract::SolCallBuilder<T, &P, initStartNodesCall, N> {
            self.call_builder(&initStartNodesCall { initNodes })
        }
        ///Creates a new call builder for the [`keyExists`] function.
        pub fn keyExists(
            &self,
            key: <StoreKey as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, keyExistsCall, N> {
            self.call_builder(&keyExistsCall { key })
        }
        ///Creates a new call builder for the [`nodes`] function.
        pub fn nodes(&self) -> alloy_contract::SolCallBuilder<T, &P, nodesCall, N> {
            self.call_builder(&nodesCall {})
        }
        ///Creates a new call builder for the [`owner`] function.
        pub fn owner(&self) -> alloy_contract::SolCallBuilder<T, &P, ownerCall, N> {
            self.call_builder(&ownerCall {})
        }
        ///Creates a new call builder for the [`ownershipHandoverExpiresAt`] function.
        pub fn ownershipHandoverExpiresAt(
            &self,
            pendingOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, ownershipHandoverExpiresAtCall, N> {
            self.call_builder(
                &ownershipHandoverExpiresAtCall {
                    pendingOwner,
                },
            )
        }
        ///Creates a new call builder for the [`removeNode`] function.
        pub fn removeNode(
            &self,
            node: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, removeNodeCall, N> {
            self.call_builder(&removeNodeCall { node })
        }
        ///Creates a new call builder for the [`removePool`] function.
        pub fn removePool(
            &self,
            asset0: alloy::sol_types::private::Address,
            asset1: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, removePoolCall, N> {
            self.call_builder(&removePoolCall { asset0, asset1 })
        }
        ///Creates a new call builder for the [`renounceOwnership`] function.
        pub fn renounceOwnership(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, renounceOwnershipCall, N> {
            self.call_builder(&renounceOwnershipCall {})
        }
        ///Creates a new call builder for the [`requestOwnershipHandover`] function.
        pub fn requestOwnershipHandover(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, requestOwnershipHandoverCall, N> {
            self.call_builder(&requestOwnershipHandoverCall {})
        }
        ///Creates a new call builder for the [`setController`] function.
        pub fn setController(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, setControllerCall, N> {
            self.call_builder(&setControllerCall {})
        }
        ///Creates a new call builder for the [`setNewController`] function.
        pub fn setNewController(
            &self,
            newController: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, setNewControllerCall, N> {
            self.call_builder(
                &setNewControllerCall {
                    newController,
                },
            )
        }
        ///Creates a new call builder for the [`totalNodes`] function.
        pub fn totalNodes(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, totalNodesCall, N> {
            self.call_builder(&totalNodesCall {})
        }
        ///Creates a new call builder for the [`totalPools`] function.
        pub fn totalPools(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, totalPoolsCall, N> {
            self.call_builder(&totalPoolsCall {})
        }
        ///Creates a new call builder for the [`transferOwnership`] function.
        pub fn transferOwnership(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferOwnershipCall, N> {
            self.call_builder(&transferOwnershipCall { _0 })
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > ControllerV1Instance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`NewControllerAccepted`] event.
        pub fn NewControllerAccepted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, NewControllerAccepted, N> {
            self.event_filter::<NewControllerAccepted>()
        }
        ///Creates a new event filter for the [`NewControllerSet`] event.
        pub fn NewControllerSet_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, NewControllerSet, N> {
            self.event_filter::<NewControllerSet>()
        }
        ///Creates a new event filter for the [`NodeAdded`] event.
        pub fn NodeAdded_filter(&self) -> alloy_contract::Event<T, &P, NodeAdded, N> {
            self.event_filter::<NodeAdded>()
        }
        ///Creates a new event filter for the [`NodeRemoved`] event.
        pub fn NodeRemoved_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, NodeRemoved, N> {
            self.event_filter::<NodeRemoved>()
        }
        ///Creates a new event filter for the [`OpaqueBatchPoolUpdate`] event.
        pub fn OpaqueBatchPoolUpdate_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OpaqueBatchPoolUpdate, N> {
            self.event_filter::<OpaqueBatchPoolUpdate>()
        }
        ///Creates a new event filter for the [`OwnershipHandoverCanceled`] event.
        pub fn OwnershipHandoverCanceled_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OwnershipHandoverCanceled, N> {
            self.event_filter::<OwnershipHandoverCanceled>()
        }
        ///Creates a new event filter for the [`OwnershipHandoverRequested`] event.
        pub fn OwnershipHandoverRequested_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OwnershipHandoverRequested, N> {
            self.event_filter::<OwnershipHandoverRequested>()
        }
        ///Creates a new event filter for the [`OwnershipTransferred`] event.
        pub fn OwnershipTransferred_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OwnershipTransferred, N> {
            self.event_filter::<OwnershipTransferred>()
        }
        ///Creates a new event filter for the [`PoolConfigured`] event.
        pub fn PoolConfigured_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, PoolConfigured, N> {
            self.event_filter::<PoolConfigured>()
        }
        ///Creates a new event filter for the [`PoolRemoved`] event.
        pub fn PoolRemoved_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, PoolRemoved, N> {
            self.event_filter::<PoolRemoved>()
        }
    }
}
