{"language":"Solidity","sources":{"src/Angstrom.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.26;\n\nimport {EIP712} from \"solady/src/utils/EIP712.sol\";\nimport {TopLevelAuth} from \"./modules/TopLevelAuth.sol\";\nimport {Settlement} from \"./modules/Settlement.sol\";\nimport {PoolUpdates} from \"./modules/PoolUpdates.sol\";\nimport {UnlockHook} from \"./modules/UnlockHook.sol\";\nimport {OrderInvalidation} from \"./modules/OrderInvalidation.sol\";\nimport {IPoolManager} from \"v4-core/src/interfaces/IPoolManager.sol\";\nimport {UniConsumer} from \"./modules/UniConsumer.sol\";\nimport {PermitSubmitterHook} from \"./modules/PermitSubmitterHook.sol\";\nimport {IUnlockCallback} from \"v4-core/src/interfaces/callback/IUnlockCallback.sol\";\n\nimport {CalldataReader, CalldataReaderLib} from \"./types/CalldataReader.sol\";\nimport {AssetArray, AssetLib} from \"./types/Asset.sol\";\nimport {PairArray, PairLib} from \"./types/Pair.sol\";\nimport {TypedDataHasher, TypedDataHasherLib} from \"./types/TypedDataHasher.sol\";\nimport {HookBuffer, HookBufferLib} from \"./types/HookBuffer.sol\";\nimport {SignatureLib} from \"./libraries/SignatureLib.sol\";\nimport {\n    PriceAB as PriceOutVsIn, AmountA as AmountOut, AmountB as AmountIn\n} from \"./types/Price.sol\";\nimport {ToBOrderBuffer} from \"./types/ToBOrderBuffer.sol\";\nimport {ToBOrderVariantMap} from \"./types/ToBOrderVariantMap.sol\";\nimport {UserOrderBuffer} from \"./types/UserOrderBuffer.sol\";\nimport {UserOrderVariantMap} from \"./types/UserOrderVariantMap.sol\";\n\n/// @author philogy <https://github.com/philogy>\ncontract Angstrom is\n    EIP712,\n    OrderInvalidation,\n    Settlement,\n    PoolUpdates,\n    UnlockHook,\n    IUnlockCallback,\n    PermitSubmitterHook\n{\n    error LimitViolated();\n    error ToBGasUsedAboveMax();\n\n    constructor(IPoolManager uniV4, address controller)\n        UniConsumer(uniV4)\n        TopLevelAuth(controller)\n    {\n        _checkAngstromHookFlags();\n    }\n\n    /// @dev Angstrom entry point, use empty payload to short-circuit empty bundles and just unlock.\n    function execute(bytes calldata encoded) external {\n        _nodeBundleLock();\n        if (encoded.length == 0) return;\n        UNI_V4.unlock(encoded);\n    }\n\n    function unlockCallback(bytes calldata data) external override returns (bytes memory) {\n        _onlyUniV4();\n\n        CalldataReader reader = CalldataReaderLib.from(data);\n\n        AssetArray assets;\n        (reader, assets) = AssetLib.readFromAndValidate(reader);\n        PairArray pairs;\n        (reader, pairs) = PairLib.readFromAndValidate(reader, assets, _configStore);\n\n        _takeAssets(assets);\n\n        reader = _updatePools(reader, pairs);\n        reader = _validateAndExecuteToBOrders(reader, pairs);\n        reader = _validateAndExecuteUserOrders(reader, pairs);\n        reader.requireAtEndOf(data);\n        _saveAndSettle(assets);\n\n        // Return empty bytes.\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x20) // Dynamic type relative offset\n            mstore(0x20, 0x00) // Bytes length\n            return(0x00, 0x40)\n        }\n    }\n\n    /// @dev Load arbitrary storage slot from this contract, enables on-chain introspection without\n    /// view methods.\n    function extsload(uint256 slot) external view returns (uint256) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, sload(slot))\n            return(0x00, 0x20)\n        }\n    }\n\n    function _validateAndExecuteToBOrders(CalldataReader reader, PairArray pairs)\n        internal\n        returns (CalldataReader)\n    {\n        CalldataReader end;\n        (reader, end) = reader.readU24End();\n\n        TypedDataHasher typedHasher = _erc712Hasher();\n        ToBOrderBuffer memory buffer;\n        buffer.init();\n\n        // Purposefully devolve into an endless loop if the specified length isn't exactly used s.t.\n        // `reader == end` at some point.\n        while (reader != end) {\n            reader = _validateAndExecuteToBOrder(reader, buffer, typedHasher, pairs);\n        }\n\n        return reader;\n    }\n\n    function _validateAndExecuteToBOrder(\n        CalldataReader reader,\n        ToBOrderBuffer memory buffer,\n        TypedDataHasher typedHasher,\n        PairArray pairs\n    ) internal returns (CalldataReader) {\n        // Load `TopOfBlockOrder` PADE variant map which will inform later variable-type encoding.\n        ToBOrderVariantMap variantMap;\n        {\n            uint8 variantByte;\n            (reader, variantByte) = reader.readU8();\n            variantMap = ToBOrderVariantMap.wrap(variantByte);\n        }\n\n        buffer.useInternal = variantMap.useInternal();\n\n        (reader, buffer.quantityIn) = reader.readU128();\n        (reader, buffer.quantityOut) = reader.readU128();\n        (reader, buffer.maxGasAsset0) = reader.readU128();\n        // Decode, validate & apply gas fee.\n        uint128 gasUsedAsset0;\n        (reader, gasUsedAsset0) = reader.readU128();\n        if (gasUsedAsset0 > buffer.maxGasAsset0) revert ToBGasUsedAboveMax();\n\n        {\n            uint16 pairIndex;\n            (reader, pairIndex) = reader.readU16();\n            (buffer.assetIn, buffer.assetOut) =\n                pairs.get(pairIndex).getAssets(variantMap.zeroForOne());\n        }\n\n        (reader, buffer.recipient) =\n            variantMap.recipientIsSome() ? reader.readAddr() : (reader, address(0));\n\n        bytes32 orderHash = typedHasher.hashTypedData(buffer.hash());\n\n        address from;\n        (reader, from) = variantMap.isEcdsa()\n            ? SignatureLib.readAndCheckEcdsa(reader, orderHash)\n            : SignatureLib.readAndCheckERC1271(reader, orderHash);\n\n        _invalidateOrderHash(orderHash, from);\n\n        address to = buffer.recipient;\n        assembly (\"memory-safe\") {\n            to := or(mul(iszero(to), from), to)\n        }\n\n        if (variantMap.zeroForOne()) {\n            buffer.quantityIn += gasUsedAsset0;\n        } else {\n            buffer.quantityOut -= gasUsedAsset0;\n        }\n        _settleOrderIn(from, buffer.assetIn, AmountIn.wrap(buffer.quantityIn), buffer.useInternal);\n        _settleOrderOut(to, buffer.assetOut, AmountOut.wrap(buffer.quantityOut), buffer.useInternal);\n\n        return reader;\n    }\n\n    function _validateAndExecuteUserOrders(CalldataReader reader, PairArray pairs)\n        internal\n        returns (CalldataReader)\n    {\n        TypedDataHasher typedHasher = _erc712Hasher();\n        UserOrderBuffer memory buffer;\n\n        CalldataReader end;\n        (reader, end) = reader.readU24End();\n\n        // Purposefully devolve into an endless loop if the specified length isn't exactly used s.t.\n        // `reader == end` at some point.\n        while (reader != end) {\n            reader = _validateAndExecuteUserOrder(reader, buffer, typedHasher, pairs);\n        }\n\n        return reader;\n    }\n\n    function _validateAndExecuteUserOrder(\n        CalldataReader reader,\n        UserOrderBuffer memory buffer,\n        TypedDataHasher typedHasher,\n        PairArray pairs\n    ) internal returns (CalldataReader) {\n        UserOrderVariantMap variantMap;\n        // Load variant map, ref id and set use internal.\n        (reader, variantMap) = buffer.init(reader);\n\n        // Load and lookup asset in/out and dependent values.\n        PriceOutVsIn price;\n        {\n            uint256 priceOutVsIn;\n            uint16 pairIndex;\n            (reader, pairIndex) = reader.readU16();\n            (buffer.assetIn, buffer.assetOut, priceOutVsIn) =\n                pairs.get(pairIndex).getSwapInfo(variantMap.zeroForOne());\n            price = PriceOutVsIn.wrap(priceOutVsIn);\n        }\n\n        (reader, buffer.minPrice) = reader.readU256();\n        if (price.into() < buffer.minPrice) revert LimitViolated();\n\n        (reader, buffer.recipient) =\n            variantMap.recipientIsSome() ? reader.readAddr() : (reader, address(0));\n\n        HookBuffer hook;\n        (reader, hook, buffer.hookDataHash) = HookBufferLib.readFrom(reader, variantMap.noHook());\n\n        // For flash orders sets the current block number as `validForBlock` so that it's\n        // implicitly validated via hashing later.\n        reader = buffer.readOrderValidation(reader, variantMap);\n        AmountIn amountIn;\n        AmountOut amountOut;\n        (reader, amountIn, amountOut) = buffer.loadAndComputeQuantity(reader, variantMap, price);\n\n        bytes32 orderHash = typedHasher.hashTypedData(buffer.structHash(variantMap));\n\n        address from;\n        (reader, from) = variantMap.isEcdsa()\n            ? SignatureLib.readAndCheckEcdsa(reader, orderHash)\n            : SignatureLib.readAndCheckERC1271(reader, orderHash);\n\n        if (variantMap.isStanding()) {\n            _checkDeadline(buffer.deadline_or_empty);\n            _invalidateNonce(from, buffer.nonce_or_validForBlock);\n        } else {\n            _invalidateOrderHash(orderHash, from);\n        }\n\n        // Push before hook as a potential loan.\n        address to = buffer.recipient;\n        assembly (\"memory-safe\") {\n            to := or(mul(iszero(to), from), to)\n        }\n        _settleOrderOut(to, buffer.assetOut, amountOut, buffer.useInternal);\n\n        hook.tryTrigger(from);\n\n        _settleOrderIn(from, buffer.assetIn, amountIn, buffer.useInternal);\n\n        return reader;\n    }\n\n    function _domainNameAndVersion()\n        internal\n        pure\n        override\n        returns (string memory, string memory)\n    {\n        return (\"Angstrom\", \"v1\");\n    }\n\n    function _erc712Hasher() internal view returns (TypedDataHasher) {\n        return TypedDataHasherLib.init(_domainSeparator());\n    }\n}\n"},"lib/solady/src/utils/EIP712.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Contract for EIP-712 typed structured data hashing and signing.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/EIP712.sol)\n/// @author Modified from Solbase (https://github.com/Sol-DAO/solbase/blob/main/src/utils/EIP712.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/EIP712.sol)\n///\n/// @dev Note, this implementation:\n/// - Uses `address(this)` for the `verifyingContract` field.\n/// - Does NOT use the optional EIP-712 salt.\n/// - Does NOT use any EIP-712 extensions.\n/// This is for simplicity and to save gas.\n/// If you need to customize, please fork / modify accordingly.\nabstract contract EIP712 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  CONSTANTS AND IMMUTABLES                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev `keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")`.\n    bytes32 internal constant _DOMAIN_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    uint256 private immutable _cachedThis;\n    uint256 private immutable _cachedChainId;\n    bytes32 private immutable _cachedNameHash;\n    bytes32 private immutable _cachedVersionHash;\n    bytes32 private immutable _cachedDomainSeparator;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CONSTRUCTOR                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Cache the hashes for cheaper runtime gas costs.\n    /// In the case of upgradeable contracts (i.e. proxies),\n    /// or if the chain id changes due to a hard fork,\n    /// the domain separator will be seamlessly calculated on-the-fly.\n    constructor() {\n        _cachedThis = uint256(uint160(address(this)));\n        _cachedChainId = block.chainid;\n\n        string memory name;\n        string memory version;\n        if (!_domainNameAndVersionMayChange()) (name, version) = _domainNameAndVersion();\n        bytes32 nameHash = _domainNameAndVersionMayChange() ? bytes32(0) : keccak256(bytes(name));\n        bytes32 versionHash = _domainNameAndVersionMayChange() ? bytes32(0) : keccak256(bytes(version));\n        _cachedNameHash = nameHash;\n        _cachedVersionHash = versionHash;\n\n        bytes32 separator;\n        if (!_domainNameAndVersionMayChange()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let m := mload(0x40) // Load the free memory pointer.\n                mstore(m, _DOMAIN_TYPEHASH)\n                mstore(add(m, 0x20), nameHash)\n                mstore(add(m, 0x40), versionHash)\n                mstore(add(m, 0x60), chainid())\n                mstore(add(m, 0x80), address())\n                separator := keccak256(m, 0xa0)\n            }\n        }\n        _cachedDomainSeparator = separator;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   FUNCTIONS TO OVERRIDE                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Please override this function to return the domain name and version.\n    /// ```\n    ///     function _domainNameAndVersion()\n    ///         internal\n    ///         pure\n    ///         virtual\n    ///         returns (string memory name, string memory version)\n    ///     {\n    ///         name = \"Solady\";\n    ///         version = \"1\";\n    ///     }\n    /// ```\n    ///\n    /// Note: If the returned result may change after the contract has been deployed,\n    /// you must override `_domainNameAndVersionMayChange()` to return true.\n    function _domainNameAndVersion() internal view virtual returns (string memory name, string memory version);\n\n    /// @dev Returns if `_domainNameAndVersion()` may change\n    /// after the contract has been deployed (i.e. after the constructor).\n    /// Default: false.\n    function _domainNameAndVersionMayChange() internal pure virtual returns (bool result) {}\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     HASHING OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the EIP-712 domain separator.\n    function _domainSeparator() internal view virtual returns (bytes32 separator) {\n        if (_domainNameAndVersionMayChange()) {\n            separator = _buildDomainSeparator();\n        } else {\n            separator = _cachedDomainSeparator;\n            if (_cachedDomainSeparatorInvalidated()) separator = _buildDomainSeparator();\n        }\n    }\n\n    /// @dev Returns the hash of the fully encoded EIP-712 message for this domain,\n    /// given `structHash`, as defined in\n    /// https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct.\n    ///\n    /// The hash can be used together with {ECDSA-recover} to obtain the signer of a message:\n    /// ```\n    ///     bytes32 digest = _hashTypedData(keccak256(abi.encode(\n    ///         keccak256(\"Mail(address to,string contents)\"),\n    ///         mailTo,\n    ///         keccak256(bytes(mailContents))\n    ///     )));\n    ///     address signer = ECDSA.recover(digest, signature);\n    /// ```\n    function _hashTypedData(bytes32 structHash) internal view virtual returns (bytes32 digest) {\n        // We will use `digest` to store the domain separator to save a bit of gas.\n        if (_domainNameAndVersionMayChange()) {\n            digest = _buildDomainSeparator();\n        } else {\n            digest = _cachedDomainSeparator;\n            if (_cachedDomainSeparatorInvalidated()) digest = _buildDomainSeparator();\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the digest.\n            mstore(0x00, 0x1901000000000000) // Store \"\\x19\\x01\".\n            mstore(0x1a, digest) // Store the domain separator.\n            mstore(0x3a, structHash) // Store the struct hash.\n            digest := keccak256(0x18, 0x42)\n            // Restore the part of the free memory slot that was overwritten.\n            mstore(0x3a, 0)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    EIP-5267 OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev See: https://eips.ethereum.org/EIPS/eip-5267\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        fields = hex\"0f\"; // `0b01111`.\n        (name, version) = _domainNameAndVersion();\n        chainId = block.chainid;\n        verifyingContract = address(this);\n        salt = salt; // `bytes32(0)`.\n        extensions = extensions; // `new uint256[](0)`.\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the EIP-712 domain separator.\n    function _buildDomainSeparator() private view returns (bytes32 separator) {\n        // We will use `separator` to store the name hash to save a bit of gas.\n        bytes32 versionHash;\n        if (_domainNameAndVersionMayChange()) {\n            (string memory name, string memory version) = _domainNameAndVersion();\n            separator = keccak256(bytes(name));\n            versionHash = keccak256(bytes(version));\n        } else {\n            separator = _cachedNameHash;\n            versionHash = _cachedVersionHash;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Load the free memory pointer.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), separator) // Name hash.\n            mstore(add(m, 0x40), versionHash)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            separator := keccak256(m, 0xa0)\n        }\n    }\n\n    /// @dev Returns if the cached domain separator has been invalidated.\n    function _cachedDomainSeparatorInvalidated() private view returns (bool result) {\n        uint256 cachedChainId = _cachedChainId;\n        uint256 cachedThis = _cachedThis;\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := iszero(and(eq(chainid(), cachedChainId), eq(address(), cachedThis)))\n        }\n    }\n}\n"},"src/modules/TopLevelAuth.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {IAngstromAuth, ConfigEntryUpdate} from \"../interfaces/IAngstromAuth.sol\";\nimport {UniConsumer} from \"./UniConsumer.sol\";\nimport {EIP712} from \"solady/src/utils/EIP712.sol\";\n\nimport {PoolConfigStore, PoolConfigStoreLib} from \"../libraries/PoolConfigStore.sol\";\nimport {StoreKey, StoreKeyLib} from \"../types/StoreKey.sol\";\nimport {ConfigEntry, ConfigEntryLib} from \"../types/ConfigEntry.sol\";\nimport {ConfigBuffer} from \"../types/ConfigBuffer.sol\";\nimport {IHooks} from \"v4-core/src/interfaces/IHooks.sol\";\nimport {PoolKey} from \"v4-core/src/types/PoolKey.sol\";\nimport {SafeCastLib} from \"solady/src/utils/SafeCastLib.sol\";\nimport {LPFeeLibrary} from \"v4-core/src/libraries/LPFeeLibrary.sol\";\nimport {SafeTransferLib} from \"solady/src/utils/SafeTransferLib.sol\";\nimport {SignatureCheckerLib} from \"solady/src/utils/SignatureCheckerLib.sol\";\nimport {UnlockSwapFeeCollector} from \"./UnlockSwapFeeCollector.sol\";\n\n/// @dev Maximum fee that the `bundleFee` for any given pool should be settable to.\nuint256 constant MAX_UNLOCK_FEE_E6 = 0.4e6;\n\n/// @author philogy <https://github.com/philogy>\n/// @author Will Smith <https://github.com/Will-Smith11>\nabstract contract TopLevelAuth is EIP712, UniConsumer, IAngstromAuth {\n    using LPFeeLibrary for uint24;\n    using SafeTransferLib for address;\n\n    error AssetsUnordered();\n    error NotController();\n    error UnlockedFeeNotSet(StoreKey key);\n    error OnlyOncePerBlock();\n    error NotNode();\n    error IndexMayHaveChanged();\n    error InvalidSignature();\n    error UnlockFeeAboveMax();\n\n    /// @dev `keccak256(\"AttestAngstromBlockEmpty(uint64 block_number)\")`\n    uint256 internal constant ATTEST_EMPTY_BLOCK_TYPE_HASH =\n        0x3f25e551746414ff93f076a7dd83828ff53735b39366c74015637e004fcb0223;\n\n    UnlockSwapFeeCollector internal immutable FEE_COLLECTOR;\n\n    /// @dev Contract that manages all special privileges for contract (setting new nodes,\n    /// configuring pools, pulling fees).\n    address internal _controller;\n\n    mapping(address => bool) internal _isNode;\n\n    struct UnlockedFees {\n        uint24 unlockedFee;\n        uint24 protocolUnlockedFee;\n    }\n\n    /// @dev Stores the unlocked fees.\n    mapping(StoreKey => UnlockedFees) internal _unlockedFees;\n\n    uint64 internal _lastBlockUpdated;\n    PoolConfigStore internal _configStore;\n\n    constructor(address controller) {\n        _controller = controller;\n        FEE_COLLECTOR = new UnlockSwapFeeCollector(UNI_V4);\n    }\n\n    function setController(address newController) public override {\n        _onlyController();\n        _controller = newController;\n    }\n\n    function collect_unlock_swap_fees(address to, bytes calldata packed_assets) external override {\n        _onlyController();\n        FEE_COLLECTOR.withdraw_to(to, packed_assets);\n    }\n\n    /// @dev Configure an existing pool or allow the creation of a new pool. Permissioned, only\n    /// controller should be allowed to configure.\n    function configurePool(\n        address asset0,\n        address asset1,\n        uint16 tickSpacing,\n        uint24 bundleFee,\n        uint24 unlockedFee,\n        uint24 protocolUnlockedFee\n    ) external override {\n        _onlyController();\n\n        if (asset0 >= asset1) revert AssetsUnordered();\n\n        StoreKey key = StoreKeyLib.keyFromAssetsUnchecked(asset0, asset1);\n\n        ConfigBuffer memory buffer = _configStore.read_to_buffer(1);\n        uint256 i = 0;\n        uint256 entry_count = buffer.entries.length;\n\n        // Search existing entries and modify the respective entry if found.\n        for (; i < entry_count; i++) {\n            ConfigEntry entry = buffer.entries[i];\n            if (entry.key() == key) {\n                buffer.entries[i] =\n                    buffer.entries[i].setTickSpacing(tickSpacing).setBundleFee(bundleFee);\n                break;\n            }\n        }\n        // If not found push new entry.\n        if (i == entry_count) {\n            // Safety: Know that `key` is unique because every other key was checked.\n            buffer.unsafe_add(ConfigEntryLib.init(key, tickSpacing, bundleFee));\n        }\n\n        _configStore = PoolConfigStoreLib.store_from_buffer(buffer);\n\n        _unlockedFees[key] =\n            UnlockedFees({unlockedFee: unlockedFee, protocolUnlockedFee: protocolUnlockedFee});\n\n        protocolUnlockedFee.validate();\n        unlockedFee.validate();\n    }\n\n    function initializePool(\n        address assetA,\n        address assetB,\n        uint256 storeIndex,\n        uint160 sqrtPriceX96\n    ) public {\n        if (assetA > assetB) (assetA, assetB) = (assetB, assetA);\n        StoreKey key = StoreKeyLib.keyFromAssetsUnchecked(assetA, assetB);\n        (int24 tickSpacing,) = _configStore.get(key, storeIndex);\n        UNI_V4.initialize(\n            PoolKey(_c(assetA), _c(assetB), INIT_HOOK_FEE, tickSpacing, IHooks(address(this))),\n            sqrtPriceX96\n        );\n    }\n\n    function removePool(StoreKey key, PoolConfigStore expected_store, uint256 store_index)\n        external\n        override\n    {\n        _onlyController();\n\n        PoolConfigStore store = _configStore;\n        if (store != expected_store) revert IndexMayHaveChanged();\n\n        ConfigBuffer memory buffer = _configStore.read_to_buffer();\n        buffer.remove_entry(key, store_index);\n        _configStore = PoolConfigStoreLib.store_from_buffer(buffer);\n\n        delete _unlockedFees[key];\n    }\n\n    function batchUpdatePools(PoolConfigStore expected_store, ConfigEntryUpdate[] calldata updates)\n        external\n        override\n    {\n        _onlyController();\n\n        PoolConfigStore store = _configStore;\n        if (store != expected_store) revert IndexMayHaveChanged();\n\n        ConfigBuffer memory buffer = _configStore.read_to_buffer(0);\n\n        for (uint256 i = 0; i < updates.length; i++) {\n            ConfigEntryUpdate calldata update = updates[i];\n            buffer.entries[update.index] =\n                buffer.get(update.key, update.index).setBundleFee(update.bundleFee);\n\n            update.unlockedFee.validate();\n            update.protocolUnlockedFee.validate();\n\n            _unlockedFees[update.key] = UnlockedFees({\n                unlockedFee: update.unlockedFee,\n                protocolUnlockedFee: update.protocolUnlockedFee\n            });\n        }\n\n        _configStore = PoolConfigStoreLib.store_from_buffer(buffer);\n    }\n\n    /// @dev Function to allow controller to pull an arbitrary amount of tokens from the contract.\n    /// Assumed to be accrued validator fees.\n    function pullFee(address asset, uint256 amount) external override {\n        _onlyController();\n        asset.safeTransfer(msg.sender, amount);\n    }\n\n    function toggleNodes(address[] calldata nodes) external override {\n        _onlyController();\n        for (uint256 i = 0; i < nodes.length; i++) {\n            address node = nodes[i];\n            _isNode[node] = !_isNode[node];\n        }\n    }\n\n    function unlockWithEmptyAttestation(address node, bytes calldata signature) public {\n        if (_isUnlocked()) revert OnlyOncePerBlock();\n        if (!_isNode[node]) revert NotNode();\n\n        bytes32 attestationStructHash;\n        assembly (\"memory-safe\") {\n            mstore(0x00, ATTEST_EMPTY_BLOCK_TYPE_HASH)\n            mstore(0x20, number())\n            attestationStructHash := keccak256(0x00, 0x40)\n        }\n\n        bytes32 digest = _hashTypedData(attestationStructHash);\n        if (!SignatureCheckerLib.isValidSignatureNowCalldata(node, digest, signature)) {\n            revert InvalidSignature();\n        }\n\n        _lastBlockUpdated = SafeCastLib.toUint64(block.number);\n    }\n\n    function _isUnlocked() internal view returns (bool) {\n        return _lastBlockUpdated == block.number;\n    }\n\n    function _onlyController() internal view {\n        if (msg.sender != _controller) revert NotController();\n    }\n\n    /// @dev Validates that the caller is a node and that the last call is at least 1 block old.\n    /// Blocks reentrant calls as well as separate calls in the same block.\n    function _nodeBundleLock() internal {\n        if (_lastBlockUpdated == block.number) revert OnlyOncePerBlock();\n        if (!_isNode[msg.sender]) revert NotNode();\n        _lastBlockUpdated = SafeCastLib.toUint64(block.number);\n    }\n}\n"},"src/modules/Settlement.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {UniConsumer} from \"./UniConsumer.sol\";\nimport {IERC20} from \"forge-std/interfaces/IERC20.sol\";\n\nimport {DeltaTracker} from \"../types/DeltaTracker.sol\";\nimport {AssetArray, Asset, FEE_SUMMARY_ENTRY_SIZE} from \"../types/Asset.sol\";\nimport {AmountA as AmountOut, AmountB as AmountIn} from \"../types/Price.sol\";\nimport {SafeTransferLib} from \"solady/src/utils/SafeTransferLib.sol\";\n\n/// @author philogy <https://github.com/philogy>\n/// @dev Handles settlement as well as maintaining Angstrom's solvency invariant.\nabstract contract Settlement is UniConsumer {\n    using SafeTransferLib for address;\n\n    error BundlDeltaUnresolved(address asset);\n\n    DeltaTracker internal bundleDeltas;\n\n    mapping(address asset => mapping(address owner => uint256 balance)) internal _balances;\n\n    /// @notice Pulls tokens from the caller and credits them to the caller for trading.\n    /// @dev WARN: Assumes `asset` charges 0 fees upon transfers and is not rebasing.\n    function deposit(address asset, uint256 amount) external {\n        asset.safeTransferFrom(msg.sender, address(this), amount);\n        _balances[asset][msg.sender] += amount;\n    }\n\n    /// @notice Pulls tokens from the caller and credits them to the `to` address for trading.\n    /// @dev WARN: Assumes `asset` charges 0 fees upon transfers and is not rebasing.\n    function deposit(address asset, address to, uint256 amount) external {\n        asset.safeTransferFrom(msg.sender, address(this), amount);\n        _balances[asset][to] += amount;\n    }\n\n    function withdraw(address asset, uint256 amount) external {\n        _balances[asset][msg.sender] -= amount;\n        asset.safeTransfer(msg.sender, amount);\n    }\n\n    function withdraw(address asset, address to, uint256 amount) external {\n        _balances[asset][msg.sender] -= amount;\n        asset.safeTransfer(to, amount);\n    }\n\n    function _takeAssets(AssetArray assets) internal {\n        uint256 length = assets.len();\n        for (uint256 i = 0; i < length; i++) {\n            _take(assets.getUnchecked(i));\n        }\n    }\n\n    function _take(Asset asset) internal {\n        uint256 amount = asset.take();\n        if (amount > 0) {\n            address addr = asset.addr();\n            UNI_V4.take(_c(addr), address(this), amount);\n            bundleDeltas.add(addr, amount);\n        }\n    }\n\n    function _saveAndSettle(AssetArray assets) internal {\n        uint256 length = assets.len();\n\n        // Allocate fee summary buffer.\n        uint256 raw_feeSummaryStartPtr;\n        assembly (\"memory-safe\") {\n            raw_feeSummaryStartPtr := mload(0x40)\n            mstore(0x40, add(raw_feeSummaryStartPtr, mul(length, FEE_SUMMARY_ENTRY_SIZE)))\n        }\n        uint256 raw_feeSummaryPtr = raw_feeSummaryStartPtr;\n\n        for (uint256 i = 0; i < length; i++) {\n            Asset asset = assets.getUnchecked(i);\n            address addr = asset.addr();\n            uint256 saving = asset.save();\n            uint256 settle = asset.settle();\n\n            int256 delta = bundleDeltas.sub(addr, saving + settle);\n\n            if (delta != 0) {\n                revert BundlDeltaUnresolved(addr);\n            }\n\n            if (settle > 0) {\n                UNI_V4.sync(_c(addr));\n                addr.safeTransfer(address(UNI_V4), settle);\n                UNI_V4.settle();\n            }\n\n            asset.raw_copyFeeEntryToMemory(raw_feeSummaryPtr);\n            unchecked {\n                raw_feeSummaryPtr += FEE_SUMMARY_ENTRY_SIZE;\n            }\n        }\n\n        // Hash buffer and emit unique log.\n        assembly (\"memory-safe\") {\n            mstore(0x00, keccak256(raw_feeSummaryStartPtr, mul(length, FEE_SUMMARY_ENTRY_SIZE)))\n            log0(0x00, 0x20)\n        }\n    }\n\n    function _settleOrderIn(address from, address asset, AmountIn amountIn, bool useInternal)\n        internal\n    {\n        uint256 amount = amountIn.into();\n\n        bundleDeltas.add(asset, amount);\n        if (useInternal) {\n            _balances[asset][from] -= amount;\n        } else {\n            asset.safeTransferFrom(from, address(this), amount);\n        }\n    }\n\n    function _settleOrderOut(address to, address asset, AmountOut amountOut, bool useInternal)\n        internal\n    {\n        uint256 amount = amountOut.into();\n        bundleDeltas.sub(asset, amount);\n        if (useInternal) {\n            _balances[asset][to] += amount;\n        } else {\n            asset.safeTransfer(to, amount);\n        }\n    }\n}\n"},"src/modules/PoolUpdates.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {GrowthOutsideUpdater} from \"./GrowthOutsideUpdater.sol\";\nimport {UniConsumer} from \"./UniConsumer.sol\";\nimport {Settlement} from \"./Settlement.sol\";\nimport {TopLevelAuth} from \"./TopLevelAuth.sol\";\nimport {IBeforeAddLiquidityHook, IBeforeRemoveLiquidityHook} from \"../interfaces/IHooks.sol\";\n\nimport {PairArray} from \"../types/Pair.sol\";\nimport {CalldataReader} from \"../types/CalldataReader.sol\";\nimport {PoolRewards} from \"../types/PoolRewards.sol\";\nimport {Positions, Position} from \"../types/Positions.sol\";\nimport {SwapCall, SwapCallLib} from \"../types/SwapCall.sol\";\nimport {PoolUpdateVariantMap} from \"../types/PoolUpdateVariantMap.sol\";\n\nimport {SignedUnsignedLib} from \"super-sol/libraries/SignedUnsignedLib.sol\";\nimport {SafeTransferLib} from \"solady/src/utils/SafeTransferLib.sol\";\nimport {IUniV4} from \"../interfaces/IUniV4.sol\";\nimport {IPoolManager} from \"../interfaces/IUniV4.sol\";\nimport {PoolId} from \"v4-core/src/types/PoolId.sol\";\nimport {PoolKey} from \"v4-core/src/types/PoolKey.sol\";\nimport {Currency} from \"v4-core/src/types/Currency.sol\";\nimport {FixedPointMathLib} from \"solady/src/utils/FixedPointMathLib.sol\";\nimport {X128MathLib} from \"../libraries/X128MathLib.sol\";\nimport {SafeCastLib} from \"solady/src/utils/SafeCastLib.sol\";\n\n/// @author philogy <https://github.com/philogy>\n/// @dev Top-level entry point for updating any state related to the underlying hooked Uniswap V4\n/// pools. Updates individual positions rewards, initiates swaps and reward distribution.\nabstract contract PoolUpdates is\n    UniConsumer,\n    GrowthOutsideUpdater,\n    TopLevelAuth,\n    Settlement,\n    IBeforeAddLiquidityHook,\n    IBeforeRemoveLiquidityHook\n{\n    using SafeTransferLib for address;\n    using X128MathLib for uint256;\n    using SafeCastLib for uint256;\n\n    using IUniV4 for IPoolManager;\n    using SignedUnsignedLib for *;\n\n    Positions internal positions;\n    mapping(PoolId id => PoolRewards) internal poolRewards;\n\n    /// @dev Maintain reward growth & `poolRewards` values such that no one's owed rewards change.\n    function beforeAddLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        bytes calldata\n    ) external override returns (bytes4) {\n        _onlyUniV4();\n\n        PoolId id = _toId(key);\n        PoolRewards storage rewards = poolRewards[id];\n\n        uint256 growthInside;\n        {\n            int24 currentTick = UNI_V4.getSlot0(id).tick();\n            uint256 lowerGrowth = rewards.rewardGrowthOutside[uint24(params.tickLower)];\n            uint256 upperGrowth = rewards.rewardGrowthOutside[uint24(params.tickUpper)];\n\n            if (currentTick < params.tickLower) {\n                unchecked {\n                    growthInside = lowerGrowth - upperGrowth;\n                }\n            } else if (params.tickUpper <= currentTick) {\n                // Following Uniswap's convention, if tick is below and uninitialized initialize growth\n                // outside to global accumulator.\n                if (!UNI_V4.isInitialized(id, params.tickLower, key.tickSpacing)) {\n                    rewards.rewardGrowthOutside[uint24(params.tickLower)] =\n                        lowerGrowth = rewards.globalGrowth;\n                }\n                if (!UNI_V4.isInitialized(id, params.tickUpper, key.tickSpacing)) {\n                    rewards.rewardGrowthOutside[uint24(params.tickUpper)] =\n                        upperGrowth = rewards.globalGrowth;\n                }\n                unchecked {\n                    growthInside = upperGrowth - lowerGrowth;\n                }\n            } else {\n                if (!UNI_V4.isInitialized(id, params.tickLower, key.tickSpacing)) {\n                    rewards.rewardGrowthOutside[uint24(params.tickLower)] =\n                        lowerGrowth = rewards.globalGrowth;\n                }\n                unchecked {\n                    growthInside = rewards.globalGrowth - lowerGrowth - upperGrowth;\n                }\n            }\n        }\n\n        (Position storage position, bytes32 positionKey) =\n            positions.get(id, sender, params.tickLower, params.tickUpper, params.salt);\n\n        uint128 lastLiquidity = UNI_V4.getPositionLiquidity(id, positionKey);\n        uint128 liquidityDelta = uint128(uint256(params.liquidityDelta));\n        uint128 newLiquidity = lastLiquidity + liquidityDelta;\n\n        if (lastLiquidity == 0) {\n            position.lastGrowthInside = growthInside;\n        } else {\n            // We want to update `lastGrowthInside` such that any previously accrued rewards are\n            // preserved:\n            // rewards' == rewards\n            // (growth_inside - last') * L' = (growth_inside - last) * L\n            //  growth_inside - last' = (growth_inside - last) * L / L'\n            // last' = growth_inside - (growth_inside - last) * L / L'\n            unchecked {\n                uint256 lastGrowthAdjustment = FixedPointMathLib.fullMulDiv(\n                    growthInside - position.lastGrowthInside, lastLiquidity, newLiquidity\n                );\n                position.lastGrowthInside = growthInside - lastGrowthAdjustment;\n            }\n        }\n\n        return this.beforeAddLiquidity.selector;\n    }\n\n    function beforeRemoveLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        bytes calldata\n    ) external override returns (bytes4) {\n        _onlyUniV4();\n\n        unchecked {\n            PoolId id = _toId(key);\n            (Position storage position, bytes32 positionKey) =\n                positions.get(id, sender, params.tickLower, params.tickUpper, params.salt);\n            int24 currentTick = UNI_V4.getSlot0(id).tick();\n            uint256 growthInside =\n                poolRewards[id].getGrowthInside(currentTick, params.tickLower, params.tickUpper);\n\n            uint128 positionTotalLiquidity = UNI_V4.getPositionLiquidity(id, positionKey);\n            uint256 rewards = X128MathLib.fullMulX128(\n                growthInside - position.lastGrowthInside, positionTotalLiquidity\n            );\n\n            if (rewards > 0) {\n                // Pay rewards to owner via uniswap delta => assumes that router is not malicious.\n                UNI_V4.sync(key.currency0);\n                Currency.unwrap(key.currency0).safeTransfer(address(UNI_V4), rewards);\n                UNI_V4.settleFor(sender);\n\n                position.lastGrowthInside = growthInside;\n            }\n        }\n\n        return this.beforeRemoveLiquidity.selector;\n    }\n\n    function _updatePools(CalldataReader reader, PairArray pairs)\n        internal\n        returns (CalldataReader)\n    {\n        CalldataReader end;\n        (reader, end) = reader.readU24End();\n        SwapCall memory swapCall = SwapCallLib.newSwapCall(address(this));\n        while (reader != end) {\n            reader = _updatePool(reader, swapCall, pairs);\n        }\n\n        return reader;\n    }\n\n    function _updatePool(CalldataReader reader, SwapCall memory swapCall, PairArray pairs)\n        internal\n        returns (CalldataReader)\n    {\n        PoolUpdateVariantMap variantMap;\n        {\n            uint8 variantByte;\n            (reader, variantByte) = reader.readU8();\n            variantMap = PoolUpdateVariantMap.wrap(variantByte);\n        }\n        swapCall.setZeroForOne(variantMap.zeroForOne());\n        uint16 pairIndex;\n        (reader, pairIndex) = reader.readU16();\n        (swapCall.asset0, swapCall.asset1, swapCall.tickSpacing) =\n            pairs.get(pairIndex).getPoolInfo();\n\n        PoolId id = swapCall.getId();\n\n        uint256 amountIn;\n        (reader, amountIn) = reader.readU128();\n\n        int24 currentTick;\n        if (amountIn > 0) {\n            int24 tickBefore = UNI_V4.getSlot0(id).tick();\n            swapCall.amountSpecified = SignedUnsignedLib.neg(amountIn);\n            // The swap delta is tracked on Uniswap's side so we don't need to here. It's accounted for in the asset\n            // take & settle steps.\n            swapCall.call(UNI_V4);\n\n            currentTick = UNI_V4.getSlot0(id).tick();\n\n            poolRewards[id].updateAfterTickMove(\n                id, UNI_V4, tickBefore, currentTick, swapCall.tickSpacing\n            );\n        } else {\n            currentTick = UNI_V4.getSlot0(id).tick();\n        }\n\n        uint256 rewardTotal;\n        (reader, rewardTotal) = _decodeAndReward(\n            variantMap.currentOnly(), reader, poolRewards[id], id, swapCall.tickSpacing, currentTick\n        );\n        bundleDeltas.sub(swapCall.asset0, rewardTotal);\n\n        return reader;\n    }\n\n    function _toId(PoolKey calldata poolKey) internal pure returns (PoolId id) {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, poolKey, mul(32, 5))\n            id := keccak256(ptr, mul(32, 5))\n        }\n    }\n}\n"},"src/modules/UnlockHook.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IBeforeSwapHook, IAfterSwapHook, SimplePoolKey} from \"../interfaces/IHooks.sol\";\nimport {UniConsumer} from \"./UniConsumer.sol\";\nimport {TopLevelAuth} from \"./TopLevelAuth.sol\";\nimport {PoolConfigStoreLib} from \"../libraries/PoolConfigStore.sol\";\nimport {StoreKey, StoreKeyLib} from \"../types/StoreKey.sol\";\n\nimport {IPoolManager} from \"v4-core/src/interfaces/IPoolManager.sol\";\nimport {BeforeSwapDelta} from \"v4-core/src/types/BeforeSwapDelta.sol\";\nimport {BalanceDelta} from \"v4-core/src/types/BalanceDelta.sol\";\nimport {LPFeeLibrary} from \"v4-core/src/libraries/LPFeeLibrary.sol\";\n\n/// @author philogy <https://github.com/philogy>\n/// @author Will Smith <https://github.com/Will-Smith11>\nabstract contract UnlockHook is UniConsumer, TopLevelAuth, IBeforeSwapHook, IAfterSwapHook {\n    error UnlockDataTooShort();\n    error CannotSwapWhileLocked();\n\n    function beforeSwap(\n        address,\n        SimplePoolKey calldata key,\n        IPoolManager.SwapParams calldata,\n        bytes calldata optionalUnlockData\n    ) external returns (bytes4 response, BeforeSwapDelta, uint24 swapFee) {\n        _onlyUniV4();\n\n        if (!_isUnlocked()) {\n            if (optionalUnlockData.length < 20) {\n                if (optionalUnlockData.length == 0) {\n                    revert CannotSwapWhileLocked();\n                }\n                revert UnlockDataTooShort();\n            } else {\n                address node = address(bytes20(optionalUnlockData[:20]));\n                bytes calldata signature = optionalUnlockData[20:];\n                unlockWithEmptyAttestation(node, signature);\n            }\n        }\n\n        StoreKey storeKey = StoreKeyLib.keyFromAssetsUnchecked(key.asset0, key.asset1);\n\n        swapFee = _unlockedFees[storeKey].unlockedFee | LPFeeLibrary.OVERRIDE_FEE_FLAG;\n\n        return (IBeforeSwapHook.beforeSwap.selector, BeforeSwapDelta.wrap(0), swapFee);\n    }\n\n    function afterSwap(\n        address,\n        SimplePoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        BalanceDelta swap_delta,\n        bytes calldata\n    ) external returns (bytes4, int128) {\n        _onlyUniV4();\n\n        StoreKey storeKey = StoreKeyLib.keyFromAssetsUnchecked(key.asset0, key.asset1);\n        int24 fee_rate_e6 = int24(_unlockedFees[storeKey].protocolUnlockedFee);\n        bool exactIn = params.amountSpecified < 0;\n\n        int128 target_amount =\n            exactIn != params.zeroForOne ? swap_delta.amount0() : swap_delta.amount1();\n        int128 fee = ((target_amount < 0 ? -target_amount : target_amount) * fee_rate_e6) / 1e6;\n\n        UNI_V4.mint(\n            address(FEE_COLLECTOR),\n            uint160(exactIn != params.zeroForOne ? key.asset0 : key.asset1),\n            uint128(fee)\n        );\n\n        return (IAfterSwapHook.afterSwap.selector, fee);\n    }\n}\n"},"src/modules/OrderInvalidation.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @author philogy <https://github.com/philogy>\nabstract contract OrderInvalidation {\n    error NonceReuse();\n    error OrderAlreadyExecuted();\n    error Expired();\n\n    /// @dev `keccak256(\"angstrom-v1_0.unordered-nonces.slot\")[0:4]`\n    uint256 private constant UNORDERED_NONCES_SLOT = 0xdaa050e9;\n\n    function invalidateNonce(uint64 nonce) external {\n        _invalidateNonce(msg.sender, nonce);\n    }\n\n    function _checkDeadline(uint256 deadline) internal view {\n        if (block.timestamp > deadline) revert Expired();\n    }\n\n    function _invalidateNonce(address owner, uint64 nonce) internal {\n        assembly (\"memory-safe\") {\n            mstore(12, nonce)\n            mstore(4, UNORDERED_NONCES_SLOT)\n            mstore(0, owner)\n            // Memory slice implicitly chops off last byte of `nonce` so that it's the nonce word\n            // index (nonce >> 8).\n            let bitmapPtr := keccak256(12, 31)\n            let flag := shl(and(nonce, 0xff), 1)\n            let updated := xor(sload(bitmapPtr), flag)\n\n            if iszero(and(updated, flag)) {\n                mstore(0x00, 0x8cb88872 /* NonceReuse() */ )\n                revert(0x1c, 0x04)\n            }\n\n            sstore(bitmapPtr, updated)\n        }\n    }\n\n    function _invalidateOrderHash(bytes32 orderHash, address from) internal {\n        assembly (\"memory-safe\") {\n            mstore(20, from)\n            mstore(0, orderHash)\n            let slot := keccak256(0, 52)\n            if tload(slot) {\n                mstore(0x00, 0x8a2ef116 /* OrderAlreadyExecuted() */ )\n                revert(0x1c, 0x04)\n            }\n            tstore(slot, 1)\n        }\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/interfaces/IPoolManager.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {Currency} from \"../types/Currency.sol\";\nimport {PoolKey} from \"../types/PoolKey.sol\";\nimport {IHooks} from \"./IHooks.sol\";\nimport {IERC6909Claims} from \"./external/IERC6909Claims.sol\";\nimport {IProtocolFees} from \"./IProtocolFees.sol\";\nimport {BalanceDelta} from \"../types/BalanceDelta.sol\";\nimport {PoolId} from \"../types/PoolId.sol\";\nimport {IExtsload} from \"./IExtsload.sol\";\nimport {IExttload} from \"./IExttload.sol\";\n\n/// @notice Interface for the PoolManager\ninterface IPoolManager is IProtocolFees, IERC6909Claims, IExtsload, IExttload {\n    /// @notice Thrown when a currency is not netted out after the contract is unlocked\n    error CurrencyNotSettled();\n\n    /// @notice Thrown when trying to interact with a non-initialized pool\n    error PoolNotInitialized();\n\n    /// @notice Thrown when unlock is called, but the contract is already unlocked\n    error AlreadyUnlocked();\n\n    /// @notice Thrown when a function is called that requires the contract to be unlocked, but it is not\n    error ManagerLocked();\n\n    /// @notice Pools are limited to type(int16).max tickSpacing in #initialize, to prevent overflow\n    error TickSpacingTooLarge(int24 tickSpacing);\n\n    /// @notice Pools must have a positive non-zero tickSpacing passed to #initialize\n    error TickSpacingTooSmall(int24 tickSpacing);\n\n    /// @notice PoolKey must have currencies where address(currency0) < address(currency1)\n    error CurrenciesOutOfOrderOrEqual(address currency0, address currency1);\n\n    /// @notice Thrown when a call to updateDynamicLPFee is made by an address that is not the hook,\n    /// or on a pool that does not have a dynamic swap fee.\n    error UnauthorizedDynamicLPFeeUpdate();\n\n    /// @notice Thrown when trying to swap amount of 0\n    error SwapAmountCannotBeZero();\n\n    ///@notice Thrown when native currency is passed to a non native settlement\n    error NonzeroNativeValue();\n\n    /// @notice Thrown when `clear` is called with an amount that is not exactly equal to the open currency delta.\n    error MustClearExactPositiveDelta();\n\n    /// @notice Emitted when a new pool is initialized\n    /// @param id The abi encoded hash of the pool key struct for the new pool\n    /// @param currency0 The first currency of the pool by address sort order\n    /// @param currency1 The second currency of the pool by address sort order\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\n    /// @param hooks The hooks contract address for the pool, or address(0) if none\n    /// @param sqrtPriceX96 The price of the pool on initialization\n    /// @param tick The initial tick of the pool corresponding to the initialized price\n    event Initialize(\n        PoolId indexed id,\n        Currency indexed currency0,\n        Currency indexed currency1,\n        uint24 fee,\n        int24 tickSpacing,\n        IHooks hooks,\n        uint160 sqrtPriceX96,\n        int24 tick\n    );\n\n    /// @notice Emitted when a liquidity position is modified\n    /// @param id The abi encoded hash of the pool key struct for the pool that was modified\n    /// @param sender The address that modified the pool\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param liquidityDelta The amount of liquidity that was added or removed\n    /// @param salt The extra data to make positions unique\n    event ModifyLiquidity(\n        PoolId indexed id, address indexed sender, int24 tickLower, int24 tickUpper, int256 liquidityDelta, bytes32 salt\n    );\n\n    /// @notice Emitted for swaps between currency0 and currency1\n    /// @param id The abi encoded hash of the pool key struct for the pool that was modified\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param amount0 The delta of the currency0 balance of the pool\n    /// @param amount1 The delta of the currency1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of the price of the pool after the swap\n    /// @param fee The swap fee in hundredths of a bip\n    event Swap(\n        PoolId indexed id,\n        address indexed sender,\n        int128 amount0,\n        int128 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick,\n        uint24 fee\n    );\n\n    /// @notice Emitted for donations\n    /// @param id The abi encoded hash of the pool key struct for the pool that was donated to\n    /// @param sender The address that initiated the donate call\n    /// @param amount0 The amount donated in currency0\n    /// @param amount1 The amount donated in currency1\n    event Donate(PoolId indexed id, address indexed sender, uint256 amount0, uint256 amount1);\n\n    /// @notice All interactions on the contract that account deltas require unlocking. A caller that calls `unlock` must implement\n    /// `IUnlockCallback(msg.sender).unlockCallback(data)`, where they interact with the remaining functions on this contract.\n    /// @dev The only functions callable without an unlocking are `initialize` and `updateDynamicLPFee`\n    /// @param data Any data to pass to the callback, via `IUnlockCallback(msg.sender).unlockCallback(data)`\n    /// @return The data returned by the call to `IUnlockCallback(msg.sender).unlockCallback(data)`\n    function unlock(bytes calldata data) external returns (bytes memory);\n\n    /// @notice Initialize the state for a given pool ID\n    /// @dev A swap fee totaling MAX_SWAP_FEE (100%) makes exact output swaps impossible since the input is entirely consumed by the fee\n    /// @param key The pool key for the pool to initialize\n    /// @param sqrtPriceX96 The initial square root price\n    /// @return tick The initial tick of the pool\n    function initialize(PoolKey memory key, uint160 sqrtPriceX96) external returns (int24 tick);\n\n    struct ModifyLiquidityParams {\n        // the lower and upper tick of the position\n        int24 tickLower;\n        int24 tickUpper;\n        // how to modify the liquidity\n        int256 liquidityDelta;\n        // a value to set if you want unique liquidity positions at the same range\n        bytes32 salt;\n    }\n\n    /// @notice Modify the liquidity for the given pool\n    /// @dev Poke by calling with a zero liquidityDelta\n    /// @param key The pool to modify liquidity in\n    /// @param params The parameters for modifying the liquidity\n    /// @param hookData The data to pass through to the add/removeLiquidity hooks\n    /// @return callerDelta The balance delta of the caller of modifyLiquidity. This is the total of both principal, fee deltas, and hook deltas if applicable\n    /// @return feesAccrued The balance delta of the fees generated in the liquidity range. Returned for informational purposes\n    function modifyLiquidity(PoolKey memory key, ModifyLiquidityParams memory params, bytes calldata hookData)\n        external\n        returns (BalanceDelta callerDelta, BalanceDelta feesAccrued);\n\n    struct SwapParams {\n        /// Whether to swap token0 for token1 or vice versa\n        bool zeroForOne;\n        /// The desired input amount if negative (exactIn), or the desired output amount if positive (exactOut)\n        int256 amountSpecified;\n        /// The sqrt price at which, if reached, the swap will stop executing\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swap against the given pool\n    /// @param key The pool to swap in\n    /// @param params The parameters for swapping\n    /// @param hookData The data to pass through to the swap hooks\n    /// @return swapDelta The balance delta of the address swapping\n    /// @dev Swapping on low liquidity pools may cause unexpected swap amounts when liquidity available is less than amountSpecified.\n    /// Additionally note that if interacting with hooks that have the BEFORE_SWAP_RETURNS_DELTA_FLAG or AFTER_SWAP_RETURNS_DELTA_FLAG\n    /// the hook may alter the swap input/output. Integrators should perform checks on the returned swapDelta.\n    function swap(PoolKey memory key, SwapParams memory params, bytes calldata hookData)\n        external\n        returns (BalanceDelta swapDelta);\n\n    /// @notice Donate the given currency amounts to the in-range liquidity providers of a pool\n    /// @dev Calls to donate can be frontrun adding just-in-time liquidity, with the aim of receiving a portion donated funds.\n    /// Donors should keep this in mind when designing donation mechanisms.\n    /// @dev This function donates to in-range LPs at slot0.tick. In certain edge-cases of the swap algorithm, the `sqrtPrice` of\n    /// a pool can be at the lower boundary of tick `n`, but the `slot0.tick` of the pool is already `n - 1`. In this case a call to\n    /// `donate` would donate to tick `n - 1` (slot0.tick) not tick `n` (getTickAtSqrtPrice(slot0.sqrtPriceX96)).\n    /// Read the comments in `Pool.swap()` for more information about this.\n    /// @param key The key of the pool to donate to\n    /// @param amount0 The amount of currency0 to donate\n    /// @param amount1 The amount of currency1 to donate\n    /// @param hookData The data to pass through to the donate hooks\n    /// @return BalanceDelta The delta of the caller after the donate\n    function donate(PoolKey memory key, uint256 amount0, uint256 amount1, bytes calldata hookData)\n        external\n        returns (BalanceDelta);\n\n    /// @notice Writes the current ERC20 balance of the specified currency to transient storage\n    /// This is used to checkpoint balances for the manager and derive deltas for the caller.\n    /// @dev This MUST be called before any ERC20 tokens are sent into the contract, but can be skipped\n    /// for native tokens because the amount to settle is determined by the sent value.\n    /// However, if an ERC20 token has been synced and not settled, and the caller instead wants to settle\n    /// native funds, this function can be called with the native currency to then be able to settle the native currency\n    function sync(Currency currency) external;\n\n    /// @notice Called by the user to net out some value owed to the user\n    /// @dev Will revert if the requested amount is not available, consider using `mint` instead\n    /// @dev Can also be used as a mechanism for free flash loans\n    /// @param currency The currency to withdraw from the pool manager\n    /// @param to The address to withdraw to\n    /// @param amount The amount of currency to withdraw\n    function take(Currency currency, address to, uint256 amount) external;\n\n    /// @notice Called by the user to pay what is owed\n    /// @return paid The amount of currency settled\n    function settle() external payable returns (uint256 paid);\n\n    /// @notice Called by the user to pay on behalf of another address\n    /// @param recipient The address to credit for the payment\n    /// @return paid The amount of currency settled\n    function settleFor(address recipient) external payable returns (uint256 paid);\n\n    /// @notice WARNING - Any currency that is cleared, will be non-retrievable, and locked in the contract permanently.\n    /// A call to clear will zero out a positive balance WITHOUT a corresponding transfer.\n    /// @dev This could be used to clear a balance that is considered dust.\n    /// Additionally, the amount must be the exact positive balance. This is to enforce that the caller is aware of the amount being cleared.\n    function clear(Currency currency, uint256 amount) external;\n\n    /// @notice Called by the user to move value into ERC6909 balance\n    /// @param to The address to mint the tokens to\n    /// @param id The currency address to mint to ERC6909s, as a uint256\n    /// @param amount The amount of currency to mint\n    /// @dev The id is converted to a uint160 to correspond to a currency address\n    /// If the upper 12 bytes are not 0, they will be 0-ed out\n    function mint(address to, uint256 id, uint256 amount) external;\n\n    /// @notice Called by the user to move value from ERC6909 balance\n    /// @param from The address to burn the tokens from\n    /// @param id The currency address to burn from ERC6909s, as a uint256\n    /// @param amount The amount of currency to burn\n    /// @dev The id is converted to a uint160 to correspond to a currency address\n    /// If the upper 12 bytes are not 0, they will be 0-ed out\n    function burn(address from, uint256 id, uint256 amount) external;\n\n    /// @notice Updates the pools lp fees for the a pool that has enabled dynamic lp fees.\n    /// @dev A swap fee totaling MAX_SWAP_FEE (100%) makes exact output swaps impossible since the input is entirely consumed by the fee\n    /// @param key The key of the pool to update dynamic LP fees for\n    /// @param newDynamicLPFee The new dynamic pool LP fee\n    function updateDynamicLPFee(PoolKey memory key, uint24 newDynamicLPFee) external;\n}\n"},"src/modules/UniConsumer.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IPoolManager} from \"../interfaces/IUniV4.sol\";\nimport {Hooks, IHooks} from \"v4-core/src/libraries/Hooks.sol\";\nimport {Currency} from \"v4-core/src/types/Currency.sol\";\nimport {LPFeeLibrary} from \"v4-core/src/libraries/LPFeeLibrary.sol\";\n\nuint24 constant ANGSTROM_INIT_HOOK_FEE = LPFeeLibrary.DYNAMIC_FEE_FLAG;\n\n/// @author philogy <https://github.com/philogy>\nabstract contract UniConsumer {\n    using Hooks for IHooks;\n\n    error NotUniswap();\n\n    IPoolManager internal immutable UNI_V4;\n\n    uint24 internal constant INIT_HOOK_FEE = ANGSTROM_INIT_HOOK_FEE;\n\n    error InvalidHookPermissions();\n\n    constructor(IPoolManager uniV4) {\n        UNI_V4 = uniV4;\n    }\n\n    function _onlyUniV4() internal view {\n        if (msg.sender != address(UNI_V4)) revert NotUniswap();\n    }\n\n    function _checkAngstromHookFlags() internal view {\n        if (!hasAngstromHookFlags(address(this))) {\n            revert InvalidHookPermissions();\n        }\n    }\n\n    function _c(address addr) internal pure returns (Currency) {\n        return Currency.wrap(addr);\n    }\n\n    function _addr(Currency c) internal pure returns (address) {\n        return Currency.unwrap(c);\n    }\n}\n\nusing Hooks for IHooks;\n\nfunction hasAngstromHookFlags(address addr) pure returns (bool) {\n    IHooks hook = IHooks(addr);\n\n    // Need at least 1 of the flags to control initialization.\n    if (!hook.hasPermission(Hooks.BEFORE_INITIALIZE_FLAG | Hooks.AFTER_INITIALIZE_FLAG)) {\n        return false;\n    }\n\n    // Ensure that we exactly only enable before add & remove, no after hooks.\n    if (!hook.hasPermission(Hooks.BEFORE_ADD_LIQUIDITY_FLAG)) return false;\n    if (hook.hasPermission(Hooks.AFTER_ADD_LIQUIDITY_FLAG)) return false;\n    if (!hook.hasPermission(Hooks.BEFORE_REMOVE_LIQUIDITY_FLAG)) return false;\n    if (hook.hasPermission(Hooks.AFTER_REMOVE_LIQUIDITY_FLAG)) return false;\n\n    // Ensure that we have some hook preventing 3rd party swapping.\n    if (!hook.hasPermission(Hooks.BEFORE_SWAP_FLAG)) return false;\n    if (\n        !(\n            hook.hasPermission(Hooks.AFTER_SWAP_FLAG)\n                && hook.hasPermission(Hooks.AFTER_SWAP_RETURNS_DELTA_FLAG)\n        )\n    ) return false;\n\n    return hook.isValidHookAddress(ANGSTROM_INIT_HOOK_FEE);\n}\n"},"src/modules/PermitSubmitterHook.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {\n    IAngstromComposable, EXPECTED_HOOK_RETURN_MAGIC\n} from \"../interfaces/IAngstromComposable.sol\";\nimport {IERC2612} from \"../interfaces/IERC2612.sol\";\nimport {IDaiPermit} from \"../interfaces/IDaiPermit.sol\";\nimport {CalldataReader, CalldataReaderLib} from \"../types/CalldataReader.sol\";\n\n/// @author philogy <https://github.com/philogy>\nabstract contract PermitSubmitterHook is IAngstromComposable {\n    uint256 internal constant ERC2612_INFINITE = 0x00;\n    uint256 internal constant ERC2612_SPECIFIC = 0x01;\n    uint256 internal constant DAI_INFINITE = 0x02;\n\n    error InvalidPermitType(uint8);\n\n    function compose(address from, bytes calldata payload) external override returns (uint32) {\n        CalldataReader reader = CalldataReaderLib.from(payload);\n        uint8 permitType;\n        (reader, permitType) = reader.readU8();\n\n        if (permitType == ERC2612_INFINITE) {\n            address token;\n            (reader, token) = reader.readAddr();\n            uint40 deadline;\n            (reader, deadline) = reader.readU40();\n            uint8 v;\n            (reader, v) = reader.readU8();\n            uint256 r;\n            (reader, r) = reader.readU256();\n            uint256 s;\n            (reader, s) = reader.readU256();\n            IERC2612(token).permit(\n                from, msg.sender, type(uint256).max, deadline, v, bytes32(r), bytes32(s)\n            );\n        } else if (permitType == ERC2612_SPECIFIC) {\n            address token;\n            (reader, token) = reader.readAddr();\n            uint128 value;\n            (reader, value) = reader.readU128();\n            uint40 deadline;\n            (reader, deadline) = reader.readU40();\n            uint8 v;\n            (reader, v) = reader.readU8();\n            uint256 r;\n            (reader, r) = reader.readU256();\n            uint256 s;\n            (reader, s) = reader.readU256();\n            IERC2612(token).permit(from, msg.sender, value, deadline, v, bytes32(r), bytes32(s));\n        } else if (permitType == DAI_INFINITE) {\n            address token;\n            (reader, token) = reader.readAddr();\n            uint32 nonce;\n            (reader, nonce) = reader.readU32();\n            uint40 deadline;\n            (reader, deadline) = reader.readU40();\n            uint8 v;\n            (reader, v) = reader.readU8();\n            uint256 r;\n            (reader, r) = reader.readU256();\n            uint256 s;\n            (reader, s) = reader.readU256();\n            IDaiPermit(token).permit(\n                from, msg.sender, nonce, deadline, true, v, bytes32(r), bytes32(s)\n            );\n        } else {\n            revert InvalidPermitType(permitType);\n        }\n\n        reader.requireAtEndOf(payload);\n\n        return EXPECTED_HOOK_RETURN_MAGIC;\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/interfaces/callback/IUnlockCallback.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Interface for the callback executed when an address unlocks the pool manager\ninterface IUnlockCallback {\n    /// @notice Called by the pool manager on `msg.sender` when the manager is unlocked\n    /// @param data The data that was passed to the call to unlock\n    /// @return Any data that you want to be returned from the unlock call\n    function unlockCallback(bytes calldata data) external returns (bytes memory);\n}\n"},"src/types/CalldataReader.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/// @dev Represents a raw calldata offset.\ntype CalldataReader is uint256;\n\nusing CalldataReaderLib for CalldataReader global;\nusing {neq as !=, eq as ==, gt as >, lt as <, ge as >=, le as <=} for CalldataReader global;\n\nfunction neq(CalldataReader a, CalldataReader b) pure returns (bool) {\n    return CalldataReader.unwrap(a) != CalldataReader.unwrap(b);\n}\n\nfunction eq(CalldataReader a, CalldataReader b) pure returns (bool) {\n    return CalldataReader.unwrap(a) == CalldataReader.unwrap(b);\n}\n\nfunction gt(CalldataReader a, CalldataReader b) pure returns (bool) {\n    return CalldataReader.unwrap(a) > CalldataReader.unwrap(b);\n}\n\nfunction lt(CalldataReader a, CalldataReader b) pure returns (bool) {\n    return CalldataReader.unwrap(a) < CalldataReader.unwrap(b);\n}\n\nfunction ge(CalldataReader a, CalldataReader b) pure returns (bool) {\n    return CalldataReader.unwrap(a) >= CalldataReader.unwrap(b);\n}\n\nfunction le(CalldataReader a, CalldataReader b) pure returns (bool) {\n    return CalldataReader.unwrap(a) <= CalldataReader.unwrap(b);\n}\n\n/// @author philogy <https://github.com/philogy>\nlibrary CalldataReaderLib {\n    error ReaderNotAtEnd();\n\n    function from(bytes calldata data) internal pure returns (CalldataReader reader) {\n        assembly (\"memory-safe\") {\n            reader := data.offset\n        }\n    }\n\n    function requireAtEndOf(CalldataReader self, bytes calldata data) internal pure {\n        assembly (\"memory-safe\") {\n            let end := add(data.offset, data.length)\n            if iszero(eq(self, end)) {\n                mstore(0x00, 0x01842f8c /* ReaderNotAtEnd() */ )\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    function requireAtEndOf(CalldataReader self, CalldataReader end) internal pure {\n        if (self != end) revert ReaderNotAtEnd();\n    }\n\n    function offset(CalldataReader self) internal pure returns (uint256) {\n        return CalldataReader.unwrap(self);\n    }\n\n    function readBool(CalldataReader self) internal pure returns (CalldataReader, bool value) {\n        assembly (\"memory-safe\") {\n            value := gt(byte(0, calldataload(self)), 0)\n            self := add(self, 1)\n        }\n        return (self, value);\n    }\n\n    function readU8(CalldataReader self) internal pure returns (CalldataReader, uint8 value) {\n        assembly (\"memory-safe\") {\n            value := byte(0, calldataload(self))\n            self := add(self, 1)\n        }\n        return (self, value);\n    }\n\n    function readU16(CalldataReader self) internal pure returns (CalldataReader, uint16 value) {\n        assembly (\"memory-safe\") {\n            value := shr(240, calldataload(self))\n            self := add(self, 2)\n        }\n        return (self, value);\n    }\n\n    function readU32(CalldataReader self) internal pure returns (CalldataReader, uint32 value) {\n        assembly (\"memory-safe\") {\n            value := shr(224, calldataload(self))\n            self := add(self, 4)\n        }\n        return (self, value);\n    }\n\n    function readI24(CalldataReader self) internal pure returns (CalldataReader, int24 value) {\n        assembly (\"memory-safe\") {\n            value := sar(232, calldataload(self))\n            self := add(self, 3)\n        }\n        return (self, value);\n    }\n\n    function readU40(CalldataReader self) internal pure returns (CalldataReader, uint40 value) {\n        assembly (\"memory-safe\") {\n            value := shr(216, calldataload(self))\n            self := add(self, 5)\n        }\n        return (self, value);\n    }\n\n    function readU64(CalldataReader self) internal pure returns (CalldataReader, uint64 value) {\n        assembly (\"memory-safe\") {\n            value := shr(192, calldataload(self))\n            self := add(self, 8)\n        }\n        return (self, value);\n    }\n\n    function readU128(CalldataReader self) internal pure returns (CalldataReader, uint128 value) {\n        assembly (\"memory-safe\") {\n            value := shr(128, calldataload(self))\n            self := add(self, 16)\n        }\n        return (self, value);\n    }\n\n    function readAddr(CalldataReader self) internal pure returns (CalldataReader, address addr) {\n        assembly (\"memory-safe\") {\n            addr := shr(96, calldataload(self))\n            self := add(self, 20)\n        }\n        return (self, addr);\n    }\n\n    function readU160(CalldataReader self) internal pure returns (CalldataReader, uint160 value) {\n        assembly (\"memory-safe\") {\n            value := shr(96, calldataload(self))\n            self := add(self, 20)\n        }\n        return (self, value);\n    }\n\n    function readU256(CalldataReader self) internal pure returns (CalldataReader, uint256 value) {\n        assembly (\"memory-safe\") {\n            value := calldataload(self)\n            self := add(self, 32)\n        }\n        return (self, value);\n    }\n\n    function readU24End(CalldataReader self)\n        internal\n        pure\n        returns (CalldataReader, CalldataReader end)\n    {\n        assembly (\"memory-safe\") {\n            let len := shr(232, calldataload(self))\n            self := add(self, 3)\n            end := add(self, len)\n        }\n        return (self, end);\n    }\n\n    function readBytes(CalldataReader self)\n        internal\n        pure\n        returns (CalldataReader, bytes calldata slice)\n    {\n        assembly (\"memory-safe\") {\n            slice.length := shr(232, calldataload(self))\n            self := add(self, 3)\n            slice.offset := self\n            self := add(self, slice.length)\n        }\n        return (self, slice);\n    }\n}\n"},"src/types/Asset.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {CalldataReader} from \"./CalldataReader.sol\";\n\nuint256 constant FEE_SUMMARY_ENTRY_SIZE = 36;\n\ntype Asset is uint256;\n\ntype AssetArray is uint256;\n\nusing AssetLib for Asset global;\nusing AssetLib for AssetArray global;\n\n/// @author philogy <https://github.com/philogy>\nlibrary AssetLib {\n    error AssetsOutOfOrderOrNotUnique();\n    error AssetAccessOutOfBounds(uint256 index, uint256 length);\n\n    /// @dev Size of a single encoded asset (b20:addr ++ b16:save ++ b16:borrow ++ b16:settle)\n    uint256 internal constant ASSET_CD_BYTES = 68;\n\n    uint256 internal constant ADDR_OFFSET = 0;\n    uint256 internal constant SAVE_OFFSET = 20;\n    uint256 internal constant TAKE_OFFSET = 36;\n    uint256 internal constant SETTLE_OFFSET = 52;\n\n    uint256 internal constant LENGTH_MASK = 0xffffffff;\n    uint256 internal constant CALLDATA_PTR_OFFSET = 32;\n\n    function readFromAndValidate(CalldataReader reader)\n        internal\n        pure\n        returns (CalldataReader, AssetArray assets)\n    {\n        CalldataReader end;\n        (reader, end) = reader.readU24End();\n\n        uint256 length = (end.offset() - reader.offset()) / ASSET_CD_BYTES;\n\n        assets = AssetArray.wrap((reader.offset() << CALLDATA_PTR_OFFSET) | length);\n\n        address lastAddr = address(0);\n        for (uint256 i = 0; i < length; i++) {\n            address newAddr = assets.getUnchecked(i).addr();\n            if (newAddr <= lastAddr) revert AssetsOutOfOrderOrNotUnique();\n            lastAddr = newAddr;\n        }\n\n        return (end, assets);\n    }\n\n    function len(AssetArray assets) internal pure returns (uint256) {\n        return AssetArray.unwrap(assets) & LENGTH_MASK;\n    }\n\n    function get(AssetArray self, uint256 index) internal pure returns (Asset asset) {\n        if (self.len() <= index) revert AssetAccessOutOfBounds(index, self.len());\n        return self.getUnchecked(index);\n    }\n\n    function getUnchecked(AssetArray self, uint256 index) internal pure returns (Asset asset) {\n        unchecked {\n            uint256 raw_calldataOffset = AssetArray.unwrap(self) >> CALLDATA_PTR_OFFSET;\n            return Asset.wrap(raw_calldataOffset + index * ASSET_CD_BYTES);\n        }\n    }\n\n    function raw_copyFeeEntryToMemory(Asset self, uint256 raw_memOffset) internal pure {\n        assembly (\"memory-safe\") {\n            calldatacopy(raw_memOffset, add(self, ADDR_OFFSET), FEE_SUMMARY_ENTRY_SIZE)\n        }\n    }\n\n    function addr(Asset self) internal pure returns (address value) {\n        assembly (\"memory-safe\") {\n            value := shr(96, calldataload(add(self, ADDR_OFFSET)))\n        }\n    }\n\n    function take(Asset self) internal pure returns (uint128 amount) {\n        assembly (\"memory-safe\") {\n            amount := shr(128, calldataload(add(self, TAKE_OFFSET)))\n        }\n    }\n\n    function save(Asset self) internal pure returns (uint128 amount) {\n        assembly (\"memory-safe\") {\n            amount := shr(128, calldataload(add(self, SAVE_OFFSET)))\n        }\n    }\n\n    function settle(Asset self) internal pure returns (uint128 amount) {\n        assembly (\"memory-safe\") {\n            amount := shr(128, calldataload(add(self, SETTLE_OFFSET)))\n        }\n    }\n}\n"},"src/types/Pair.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {CalldataReader} from \"./CalldataReader.sol\";\nimport {AssetArray} from \"./Asset.sol\";\nimport {RayMathLib} from \"../libraries/RayMathLib.sol\";\nimport {PoolConfigStore, StoreKey} from \"../libraries/PoolConfigStore.sol\";\nimport {ONE_E6} from \"./ConfigEntry.sol\";\nimport {StoreKey, HASH_TO_STORE_KEY_SHIFT} from \"../types/StoreKey.sol\";\n\ntype Pair is uint256;\n\ntype PairArray is uint256;\n\nusing PairLib for Pair global;\nusing PairLib for PairArray global;\n\n/// @author philogy <https://github.com/philogy>\n/// @dev Keeps track of pairs used in a given transaction, ensuring they've been initialized and are\n/// unique.\nlibrary PairLib {\n    using RayMathLib for uint256;\n\n    error OutOfOrderOrDuplicatePairs();\n    error PairAccessOutOfBounds(uint256 index, uint256 length);\n\n    uint256 internal constant PAIR_ARRAY_MEM_OFFSET_OFFSET = 32;\n    uint256 internal constant PAIR_ARRAY_LENGTH_MASK = 0xffffffff;\n\n    /// @dev 6 words for: asset0, asset1, priceAB, priceBA, tickSpacing, fee\n    uint256 internal constant PAIR_MEM_BYTES = 0xc0;\n\n    uint256 internal constant PAIR_ASSET0_OFFSET = 0x00;\n    uint256 internal constant PAIR_ASSET1_OFFSET = 0x20;\n    uint256 internal constant PAIR_TICK_SPACING_OFFSET = 0x40;\n    uint256 internal constant PAIR_FEE_OFFSET = 0x60;\n    uint256 internal constant PAIR_PRICE_0_OVER_1_OFFSET = 0x80;\n    uint256 internal constant PAIR_PRICE_1_OVER_0_OFFSET = 0xa0;\n\n    uint256 internal constant INDEX_A_OFFSET = 16;\n    uint256 internal constant INDEX_B_MASK = 0xffff;\n\n    uint256 internal constant PAIR_CD_BYTES = 38;\n\n    function readFromAndValidate(CalldataReader reader, AssetArray assets, PoolConfigStore store)\n        internal\n        view\n        returns (CalldataReader, PairArray pairs)\n    {\n        uint256 raw_memoryOffset;\n        uint256 raw_memoryEnd;\n\n        CalldataReader end;\n        {\n            (reader, end) = reader.readU24End();\n            uint256 length = (end.offset() - reader.offset()) / PAIR_CD_BYTES;\n\n            assembly (\"memory-safe\") {\n                // WARN: Memory is allocated, but **not cleaned**.\n                raw_memoryOffset := mload(0x40)\n                raw_memoryEnd := add(raw_memoryOffset, mul(PAIR_MEM_BYTES, length))\n                mstore(0x40, raw_memoryEnd)\n                // No need to mask length because we know it's less than 4 bytes (u24.max / PAIR_BYTES < u32.max)\n                pairs := or(shl(PAIR_ARRAY_MEM_OFFSET_OFFSET, raw_memoryOffset), length)\n            }\n        }\n\n        uint32 lastIndices;\n        for (; raw_memoryOffset < raw_memoryEnd;) {\n            // Load, decode and validate assets of pair.\n            {\n                uint32 indices;\n                (reader, indices) = reader.readU32();\n                address asset0 = assets.get(indices >> INDEX_A_OFFSET).addr();\n                address asset1 = assets.get(indices & INDEX_B_MASK).addr();\n                // We ensure pair uniqueness by ensuring that the list is sorted and that every pair\n                // is unique by ensuring there's only one valid ordering of asset 0 & 1.\n                if (indices <= lastIndices || asset0 >= asset1) revert OutOfOrderOrDuplicatePairs();\n                lastIndices = indices;\n\n                assembly (\"memory-safe\") {\n                    mstore(add(raw_memoryOffset, PAIR_ASSET0_OFFSET), asset0)\n                    mstore(add(raw_memoryOffset, PAIR_ASSET1_OFFSET), asset1)\n                }\n            }\n\n            // Load and store pool config.\n            {\n                StoreKey key;\n                assembly (\"memory-safe\") {\n                    key :=\n                        shl(\n                            HASH_TO_STORE_KEY_SHIFT,\n                            keccak256(add(raw_memoryOffset, PAIR_ASSET0_OFFSET), 0x40)\n                        )\n                }\n\n                uint16 storeIndex;\n                (reader, storeIndex) = reader.readU16();\n                (int24 tickSpacing, uint24 feeInE6) = store.get(key, storeIndex);\n\n                assembly (\"memory-safe\") {\n                    mstore(add(raw_memoryOffset, PAIR_TICK_SPACING_OFFSET), tickSpacing)\n                    mstore(add(raw_memoryOffset, PAIR_FEE_OFFSET), feeInE6)\n                }\n            }\n\n            // Load main AB price, compute inverse, store both.\n            {\n                uint256 price1Over0;\n                (reader, price1Over0) = reader.readU256();\n                uint256 price0Over1 = price1Over0.invRayUnchecked();\n                assembly (\"memory-safe\") {\n                    mstore(add(raw_memoryOffset, PAIR_PRICE_0_OVER_1_OFFSET), price0Over1)\n                    mstore(add(raw_memoryOffset, PAIR_PRICE_1_OVER_0_OFFSET), price1Over0)\n                }\n            }\n\n            unchecked {\n                raw_memoryOffset += PAIR_MEM_BYTES;\n            }\n        }\n\n        return (end, pairs);\n    }\n\n    function len(PairArray self) internal pure returns (uint256 length) {\n        return PairArray.unwrap(self) & PAIR_ARRAY_LENGTH_MASK;\n    }\n\n    function get(PairArray self, uint256 index) internal pure returns (Pair pair) {\n        if (self.len() <= index) revert PairAccessOutOfBounds(index, self.len());\n        uint256 raw_memoryOffset = PairArray.unwrap(self) >> PAIR_ARRAY_MEM_OFFSET_OFFSET;\n        unchecked {\n            return Pair.wrap(raw_memoryOffset + index * PAIR_MEM_BYTES);\n        }\n    }\n\n    function getPoolInfo(Pair self)\n        internal\n        pure\n        returns (address asset0, address asset1, int24 tickSpacing)\n    {\n        assembly (\"memory-safe\") {\n            asset0 := mload(add(self, PAIR_ASSET0_OFFSET))\n            asset1 := mload(add(self, PAIR_ASSET1_OFFSET))\n            tickSpacing := mload(add(self, PAIR_TICK_SPACING_OFFSET))\n        }\n    }\n\n    function getAssets(Pair self, bool zeroToOne)\n        internal\n        pure\n        returns (address assetIn, address assetOut)\n    {\n        assembly (\"memory-safe\") {\n            let offsetIfZeroToOne := shl(5, zeroToOne)\n            assetIn := mload(add(self, xor(offsetIfZeroToOne, 0x20)))\n            assetOut := mload(add(self, offsetIfZeroToOne))\n        }\n    }\n\n    function getSwapInfo(Pair self, bool zeroToOne)\n        internal\n        pure\n        returns (address assetIn, address assetOut, uint256 priceOutVsIn)\n    {\n        uint256 oneMinusFee;\n        assembly (\"memory-safe\") {\n            let offsetIfZeroToOne := shl(5, zeroToOne)\n            assetIn := mload(add(self, xor(offsetIfZeroToOne, 0x20)))\n            assetOut := mload(add(self, offsetIfZeroToOne))\n            priceOutVsIn := mload(add(self, add(PAIR_PRICE_0_OVER_1_OFFSET, offsetIfZeroToOne)))\n            oneMinusFee := sub(ONE_E6, mload(add(self, PAIR_FEE_OFFSET)))\n        }\n        priceOutVsIn = priceOutVsIn * oneMinusFee / ONE_E6;\n    }\n}\n"},"src/types/TypedDataHasher.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/// @dev Abstraction for memory pointer to 66 bytes of memory used for ERC712 typed data hashing.\ntype TypedDataHasher is uint256;\n\nusing TypedDataHasherLib for TypedDataHasher global;\n\n/// @author philogy <https://github.com/philogy>\n/// @dev Custom bytes allocation used to compute the EIP712 message digest from a struct hash and\n/// domain hash.\nlibrary TypedDataHasherLib {\n    function init(bytes32 separator) internal pure returns (TypedDataHasher hasher) {\n        assembly (\"memory-safe\") {\n            // Allocate 66 (0x42) bytes of memory (last 32 can be left uncleared because we\n            // always overwrite it in `hashTypedData`).\n            hasher := mload(0x40)\n            mstore(0x40, add(hasher, 0x42))\n            // Pre-store ERC712 header bytes and domain separator in memory.\n            mstore(hasher, hex\"1901\")\n            mstore(add(hasher, 2), separator)\n        }\n    }\n\n    function hashTypedData(TypedDataHasher hasher, bytes32 structHash)\n        internal\n        pure\n        returns (bytes32 digest)\n    {\n        assembly (\"memory-safe\") {\n            mstore(add(hasher, 0x22), structHash)\n            digest := keccak256(hasher, 0x42)\n        }\n    }\n}\n"},"src/types/HookBuffer.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.13;\n\nimport {EXPECTED_HOOK_RETURN_MAGIC} from \"../interfaces/IAngstromComposable.sol\";\nimport {CalldataReader} from \"./CalldataReader.sol\";\n\n/// @dev 0 or packed (u64 memory pointer ++ u160 hook address ++ u32 calldata length)\ntype HookBuffer is uint256;\n\nusing HookBufferLib for HookBuffer global;\n\n/// @author philogy <https://github.com/philogy>\n/// @dev Custom bytes allocation that stores a partially encoded hook call such that hashing of\n/// hook data for validation & actual hook triggering can be done in different parts of the order\n/// processing lifecycle.\nlibrary HookBufferLib {\n    error InvalidHookReturn();\n\n    /// @dev Hash of empty sequence of bytes `keccak256(\"\")`\n    /// @custom:test test/types/OrderIterator.t.sol:test_emptyBytesHash\n    uint256 internal constant EMPTY_BYTES_HASH =\n        0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n    uint256 internal constant HOOK_ADDR_OFFSET = 32;\n    uint256 internal constant HOOK_MEM_PTR_OFFSET = 192;\n    uint256 internal constant HOOK_LENGTH_MASK = 0xffffffff;\n\n    /// @dev Left-shifted hook selector (`compose(address, bytes)`).\n    uint256 internal constant HOOK_SELECTOR_LEFT_ALIGNED =\n        0x7407905c00000000000000000000000000000000000000000000000000000000;\n\n    function readFrom(CalldataReader reader, bool noHookToRead)\n        internal\n        pure\n        returns (CalldataReader, HookBuffer hook, bytes32 hash)\n    {\n        assembly (\"memory-safe\") {\n            hash := EMPTY_BYTES_HASH\n            if iszero(noHookToRead) {\n                // Load length of address + payload from reader.\n                let hookDataLength := shr(232, calldataload(reader))\n                reader := add(reader, 3)\n\n                // Allocate memory for hook call.\n                let memPtr := mload(0x40)\n                let contentOffset := add(memPtr, sub(0x64, 20))\n                mstore(0x40, add(contentOffset, hookDataLength))\n\n                // Copy hook data into memory and hash.\n                calldatacopy(contentOffset, reader, hookDataLength)\n                hash := keccak256(contentOffset, hookDataLength)\n                reader := add(reader, hookDataLength)\n\n                // Load hook address from memory ensuring upper bytes are cleared.\n                // If `hookDataLength` < 20 dirty lower bytes will become part of the hook address.\n                // This could lead to an unexpected hook address being called on behalf of the\n                // signer, however this can only occur if: 1. Said signer signs a malformed order\n                // struct (hook data length < 20) and 2. The submitting node decides to maliciously\n                // include the order despite it violating the encoding specification.\n                let hookAddr := shr(96, mload(add(memPtr, add(0x44, 12))))\n\n                // Setup memory for full call.\n                mstore(memPtr, HOOK_SELECTOR_LEFT_ALIGNED) // 0x00:0x04 selector\n                mstore(add(memPtr, 0x24), 0x40) // 0x24:0x44 calldata offset\n                // Can underflow, which would result in an insanely high length being written to memory.\n                let payloadLength := sub(hookDataLength, 20)\n                mstore(add(memPtr, 0x44), payloadLength) // 0x44:0x64 payload length\n\n                // Build packed hook pointer.\n                // `payloadLength` bounded to [-20; 2^24-21], + 0x64 => [+80, 2^24+79] (cannot\n                // overflow because its allotted 32 bits in the packed hook pointer).\n                hook :=\n                    or(\n                        shl(HOOK_MEM_PTR_OFFSET, memPtr),\n                        or(shl(HOOK_ADDR_OFFSET, hookAddr), add(payloadLength, 0x64))\n                    )\n            }\n        }\n\n        return (reader, hook, hash);\n    }\n\n    function tryTrigger(HookBuffer self, address from) internal {\n        assembly (\"memory-safe\") {\n            if self {\n                // Unpack hook.\n                let calldataLength := and(self, HOOK_LENGTH_MASK)\n                let memPtr := shr(HOOK_MEM_PTR_OFFSET, self)\n                // Encode `from`.\n                mstore(add(memPtr, 0x04), from)\n                // Call hook. The upper bytes of `hookAddr` will be dirty from the memory pointer\n                // but the EVM discards upper bytes for calls. https://ethereum.github.io/execution-specs/src/ethereum/cancun/vm/instructions/system.py.html#ethereum.cancun.vm.instructions.system.call:0\n                let hookAddr := shr(HOOK_ADDR_OFFSET, self)\n                // In the case where `hookDataLength` < 20 the calldata will not represent a valid\n                // ABI encoded call because the calldata length (0x44:0x64) will be truncated.\n                let success := call(gas(), hookAddr, 0, memPtr, calldataLength, 0x00, 0x20)\n\n                // Check that the call was successful, sufficient data was returned and the expected\n                // return magic was returned.\n                if iszero(\n                    and(\n                        success,\n                        and(gt(returndatasize(), 31), eq(mload(0x00), EXPECTED_HOOK_RETURN_MAGIC))\n                    )\n                ) {\n                    mstore(0x00, 0xf959fdae /* InvalidHookReturn() */ )\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n}\n"},"src/libraries/SignatureLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {CalldataReader} from \"../types/CalldataReader.sol\";\nimport {SignatureCheckerLib} from \"solady/src/utils/SignatureCheckerLib.sol\";\n\n/// @author philogy <https://github.com/philogy>\nlibrary SignatureLib {\n    error InvalidSignature();\n\n    uint256 internal constant ECRECOVER_ADDR = 1;\n\n    function readAndCheckEcdsa(CalldataReader reader, bytes32 hash)\n        internal\n        view\n        returns (CalldataReader, address from)\n    {\n        assembly (\"memory-safe\") {\n            let free := mload(0x40)\n            mstore(free, hash)\n            // Ensure next word is clear\n            mstore(add(free, 0x20), 0)\n            // Read signature.\n            calldatacopy(add(free, 0x3f), reader, 65)\n            reader := add(reader, 65)\n            // Call ec-Recover pre-compile (addr: 0x01).\n            // Credit to Vectorized's ECDSA in Solady: https://github.com/Vectorized/solady/blob/a95f6714868cfe5d590145f936d0661bddff40d2/src/utils/ECDSA.sol#L108-L123\n            from := mload(staticcall(gas(), ECRECOVER_ADDR, free, 0x80, 0x01, 0x20))\n            if iszero(returndatasize()) {\n                mstore(0x00, 0x8baa579f /* InvalidSignature() */ )\n                revert(0x1c, 0x04)\n            }\n        }\n\n        return (reader, from);\n    }\n\n    function readAndCheckERC1271(CalldataReader reader, bytes32 hash)\n        internal\n        view\n        returns (CalldataReader, address from)\n    {\n        (reader, from) = reader.readAddr();\n        bytes calldata signature;\n        (reader, signature) = reader.readBytes();\n        if (!SignatureCheckerLib.isValidERC1271SignatureNowCalldata(from, hash, signature)) {\n            revert InvalidSignature();\n        }\n        return (reader, from);\n    }\n}\n"},"src/types/Price.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {RayMathLib} from \"../libraries/RayMathLib.sol\";\n\ntype PriceAB is uint256;\n\ntype AmountA is uint256;\n\ntype AmountB is uint256;\n\nusing PriceLib for PriceAB global;\nusing PriceLib for AmountA global;\nusing {addA as +, subA as -, gtA as >, ltA as <} for AmountA global;\nusing PriceLib for AmountB global;\nusing {addB as +, subB as -, gtB as >, ltB as <} for AmountB global;\n\nfunction addA(AmountA x, AmountA y) pure returns (AmountA) {\n    return AmountA.wrap(x.into() + y.into());\n}\n\nfunction subA(AmountA x, AmountA y) pure returns (AmountA) {\n    return AmountA.wrap(x.into() - y.into());\n}\n\nfunction gtA(AmountA x, AmountA y) pure returns (bool) {\n    return x.into() > y.into();\n}\n\nfunction ltA(AmountA x, AmountA y) pure returns (bool) {\n    return x.into() < y.into();\n}\n\nfunction addB(AmountB x, AmountB y) pure returns (AmountB) {\n    return AmountB.wrap(x.into() + y.into());\n}\n\nfunction subB(AmountB x, AmountB y) pure returns (AmountB) {\n    return AmountB.wrap(x.into() - y.into());\n}\n\nfunction gtB(AmountB x, AmountB y) pure returns (bool) {\n    return x.into() > y.into();\n}\n\nfunction ltB(AmountB x, AmountB y) pure returns (bool) {\n    return x.into() < y.into();\n}\n\n/// @author philogy <https://github.com/philogy>\nlibrary PriceLib {\n    using RayMathLib for *;\n\n    uint256 internal constant ONE_E6 = 1e6;\n\n    function into(PriceAB price) internal pure returns (uint256) {\n        return PriceAB.unwrap(price);\n    }\n\n    function into(AmountA amount) internal pure returns (uint256) {\n        return AmountA.unwrap(amount);\n    }\n\n    function into(AmountB amount) internal pure returns (uint256) {\n        return AmountB.unwrap(amount);\n    }\n\n    /// @dev Convert an amount in `A` to `B` based on `priceAB`, rounding the result *down*.\n    function convertDown(PriceAB priceAB, AmountA amountA) internal pure returns (AmountB) {\n        return AmountB.wrap(amountA.into().divRayDown(priceAB.into()));\n    }\n\n    /// @dev Convert an amount in `A` to `B` based on `priceAB`, rounding the result *up*.\n    function convertUp(PriceAB priceAB, AmountA amountA) internal pure returns (AmountB) {\n        return AmountB.wrap(amountA.into().divRayUp(priceAB.into()));\n    }\n\n    /// @dev Convert an amount in `B` to `A` based on `priceAB`, rounding the result *down*.\n    function convertDown(PriceAB priceAB, AmountB amountB) internal pure returns (AmountA) {\n        return AmountA.wrap(amountB.into().mulRayDown(priceAB.into()));\n    }\n\n    /// @dev Convert an amount in `B` to `A` based on `priceAB`, rounding the result *up*.\n    function convertUp(PriceAB priceAB, AmountB amountB) internal pure returns (AmountA) {\n        return AmountA.wrap(amountB.into().mulRayUp(priceAB.into()));\n    }\n\n    /// @dev Scale `price` by `(1 - feeE6)` such that `feeE6/1e6` A is received for every B.\n    function reduceByFeeE6(PriceAB price, uint256 feeE6) internal pure returns (PriceAB) {\n        uint256 oneMinusFee;\n        unchecked {\n            oneMinusFee = ONE_E6 - feeE6;\n        }\n        return PriceAB.wrap(PriceAB.unwrap(price) * oneMinusFee / ONE_E6);\n    }\n}\n"},"src/types/ToBOrderBuffer.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nstruct ToBOrderBuffer {\n    bytes32 typeHash;\n    uint256 quantityIn;\n    uint256 quantityOut;\n    uint256 maxGasAsset0;\n    bool useInternal;\n    address assetIn;\n    address assetOut;\n    address recipient;\n    uint64 validForBlock;\n}\n\nusing ToBOrderBufferLib for ToBOrderBuffer global;\n\n/// @author philogy <https://github.com/philogy>\nlibrary ToBOrderBufferLib {\n    uint256 internal constant BUFFER_BYTES = 288;\n\n    /// forgefmt: disable-next-item\n    bytes32 internal constant TOP_OF_BLOCK_ORDER_TYPEHASH = keccak256(\n        \"TopOfBlockOrder(\"\n           \"uint128 quantity_in,\"\n           \"uint128 quantity_out,\"\n           \"uint128 max_gas_asset0,\"\n           \"bool use_internal,\"\n           \"address asset_in,\"\n           \"address asset_out,\"\n           \"address recipient,\"\n           \"uint64 valid_for_block\"\n        \")\"\n    );\n\n    function init(ToBOrderBuffer memory self) internal view {\n        self.typeHash = TOP_OF_BLOCK_ORDER_TYPEHASH;\n        self.validForBlock = uint64(block.number);\n    }\n\n    function hash(ToBOrderBuffer memory self) internal pure returns (bytes32 orderHash) {\n        assembly (\"memory-safe\") {\n            orderHash := keccak256(self, BUFFER_BYTES)\n        }\n    }\n}\n"},"src/types/ToBOrderVariantMap.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\ntype ToBOrderVariantMap is uint8;\n\nusing ToBOrderVariantMapLib for ToBOrderVariantMap global;\n\n/// @author philogy <https://github.com/philogy>\nlibrary ToBOrderVariantMapLib {\n    uint256 internal constant USE_INTERNAL_BIT = 0x01;\n    uint256 internal constant ZERO_FOR_ONE_BIT = 0x02;\n    uint256 internal constant HAS_RECIPIENT_BIT = 0x04;\n    uint256 internal constant IS_ECDSA_BIT = 0x08;\n\n    function useInternal(ToBOrderVariantMap variant) internal pure returns (bool) {\n        return ToBOrderVariantMap.unwrap(variant) & USE_INTERNAL_BIT != 0;\n    }\n\n    function zeroForOne(ToBOrderVariantMap variant) internal pure returns (bool) {\n        return ToBOrderVariantMap.unwrap(variant) & ZERO_FOR_ONE_BIT != 0;\n    }\n\n    function recipientIsSome(ToBOrderVariantMap variant) internal pure returns (bool) {\n        return ToBOrderVariantMap.unwrap(variant) & HAS_RECIPIENT_BIT != 0;\n    }\n\n    function isEcdsa(ToBOrderVariantMap variant) internal pure returns (bool) {\n        return ToBOrderVariantMap.unwrap(variant) & IS_ECDSA_BIT != 0;\n    }\n}\n"},"src/types/UserOrderBuffer.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {CalldataReader} from \"./CalldataReader.sol\";\nimport {UserOrderVariantMap} from \"./UserOrderVariantMap.sol\";\nimport {PriceAB as PriceOutVsIn, AmountA as AmountOut, AmountB as AmountIn} from \"./Price.sol\";\n\nstruct UserOrderBuffer {\n    bytes32 typeHash;\n    uint32 refId;\n    uint256 exactIn_or_minQuantityIn;\n    uint256 quantity_or_maxQuantityIn;\n    uint256 maxExtraFeeAsset0;\n    uint256 minPrice;\n    bool useInternal;\n    address assetIn;\n    address assetOut;\n    address recipient;\n    bytes32 hookDataHash;\n    uint64 nonce_or_validForBlock;\n    uint40 deadline_or_empty;\n}\n\nusing UserOrderBufferLib for UserOrderBuffer global;\n\n/// @author philogy <https://github.com/philogy>\nlibrary UserOrderBufferLib {\n    error FillingTooLittle();\n    error FillingTooMuch();\n    error GasAboveMax();\n\n    uint256 internal constant STANDING_ORDER_BYTES = 416;\n    uint256 internal constant FLASH_ORDER_BYTES = 384;\n\n    uint256 internal constant VARIANT_MAP_BYTES = 1;\n    /// @dev Destination offset for direct calldatacopy of 4-byte ref ID (therefore not word aligned).\n    uint256 internal constant REF_ID_MEM_OFFSET = 0x20;\n    uint256 internal constant REF_ID_BYTES = 4;\n    uint256 internal constant NONCE_MEM_OFFSET = 0x160;\n    uint256 internal constant NONCE_BYTES = 8;\n    uint256 internal constant DEADLINE_MEM_OFFSET = 0x180;\n    uint256 internal constant DEADLINE_BYTES = 5;\n\n    /// forgefmt: disable-next-item\n    bytes32 internal constant PARTIAL_STANDING_ORDER_TYPEHASH =\n        keccak256(\n            \"PartialStandingOrder(\"\n            \"uint32 ref_id,\"\n            \"uint128 min_amount_in,\"\n            \"uint128 max_amount_in,\"\n            \"uint128 max_extra_fee_asset0,\"\n            \"uint256 min_price,\"\n            \"bool use_internal,\"\n            \"address asset_in,\"\n            \"address asset_out,\"\n            \"address recipient,\"\n            \"bytes hook_data,\"\n            \"uint64 nonce,\"\n            \"uint40 deadline\"\n            \")\"\n        );\n\n    /// forgefmt: disable-next-item\n    bytes32 internal constant EXACT_STANDING_ORDER_TYPEHASH =\n        keccak256(\n            \"ExactStandingOrder(\"\n            \"uint32 ref_id,\"\n            \"bool exact_in,\"\n            \"uint128 amount,\"\n            \"uint128 max_extra_fee_asset0,\"\n            \"uint256 min_price,\"\n            \"bool use_internal,\"\n            \"address asset_in,\"\n            \"address asset_out,\"\n            \"address recipient,\"\n            \"bytes hook_data,\"\n            \"uint64 nonce,\"\n            \"uint40 deadline\"\n            \")\"\n        );\n\n    /// forgefmt: disable-next-item\n    bytes32 internal constant PARTIAL_FLASH_ORDER_TYPEHASH =\n        keccak256(\n            \"PartialFlashOrder(\"\n            \"uint32 ref_id,\"\n            \"uint128 min_amount_in,\"\n            \"uint128 max_amount_in,\"\n            \"uint128 max_extra_fee_asset0,\"\n            \"uint256 min_price,\"\n            \"bool use_internal,\"\n            \"address asset_in,\"\n            \"address asset_out,\"\n            \"address recipient,\"\n            \"bytes hook_data,\"\n            \"uint64 valid_for_block\"\n            \")\"\n        );\n\n    /// forgefmt: disable-next-item\n    bytes32 internal constant EXACT_FLASH_ORDER_TYPEHASH =\n        keccak256(\n            \"ExactFlashOrder(\"\n            \"uint32 ref_id,\"\n            \"bool exact_in,\"\n            \"uint128 amount,\"\n            \"uint128 max_extra_fee_asset0,\"\n            \"uint256 min_price,\"\n            \"bool use_internal,\"\n            \"address asset_in,\"\n            \"address asset_out,\"\n            \"address recipient,\"\n            \"bytes hook_data,\"\n            \"uint64 valid_for_block\"\n            \")\"\n        );\n\n    function init(UserOrderBuffer memory self, CalldataReader reader)\n        internal\n        pure\n        returns (CalldataReader, UserOrderVariantMap variantMap)\n    {\n        assembly (\"memory-safe\") {\n            variantMap := byte(0, calldataload(reader))\n            reader := add(reader, VARIANT_MAP_BYTES)\n            // Copy `refId` from calldata directly to memory.\n            calldatacopy(\n                add(self, add(REF_ID_MEM_OFFSET, sub(0x20, REF_ID_BYTES))), reader, REF_ID_BYTES\n            )\n            // Advance reader.\n            reader := add(reader, REF_ID_BYTES)\n        }\n        // forgefmt: disable-next-item\n        if (variantMap.quantitiesPartial()) {\n            self.typeHash = variantMap.isStanding()\n                ? PARTIAL_STANDING_ORDER_TYPEHASH\n                : PARTIAL_FLASH_ORDER_TYPEHASH;\n        } else {\n            self.typeHash = variantMap.isStanding()\n                ? EXACT_STANDING_ORDER_TYPEHASH\n                : EXACT_FLASH_ORDER_TYPEHASH;\n        }\n\n        self.useInternal = variantMap.useInternal();\n\n        return (reader, variantMap);\n    }\n\n    function structHash(UserOrderBuffer memory self, UserOrderVariantMap variant)\n        internal\n        pure\n        returns (bytes32 hashed)\n    {\n        uint256 structLength = variant.isStanding() ? STANDING_ORDER_BYTES : FLASH_ORDER_BYTES;\n        assembly (\"memory-safe\") {\n            hashed := keccak256(self, structLength)\n        }\n    }\n\n    function loadAndComputeQuantity(\n        UserOrderBuffer memory self,\n        CalldataReader reader,\n        UserOrderVariantMap variant,\n        PriceOutVsIn price\n    ) internal pure returns (CalldataReader, AmountIn quantityIn, AmountOut quantityOut) {\n        uint256 quantity;\n        if (variant.quantitiesPartial()) {\n            uint256 minQuantityIn;\n            uint256 maxQuantityIn;\n            (reader, minQuantityIn) = reader.readU128();\n            (reader, maxQuantityIn) = reader.readU128();\n            (reader, quantity) = reader.readU128();\n            self.exactIn_or_minQuantityIn = minQuantityIn;\n            self.quantity_or_maxQuantityIn = maxQuantityIn;\n\n            if (quantity < minQuantityIn) revert FillingTooLittle();\n            if (quantity > maxQuantityIn) revert FillingTooMuch();\n        } else {\n            (reader, quantity) = reader.readU128();\n            self.exactIn_or_minQuantityIn = variant.exactIn() ? 1 : 0;\n            self.quantity_or_maxQuantityIn = quantity;\n        }\n\n        uint128 extraFeeAsset0;\n        {\n            uint128 maxExtraFeeAsset0;\n            (reader, maxExtraFeeAsset0) = reader.readU128();\n            (reader, extraFeeAsset0) = reader.readU128();\n            if (extraFeeAsset0 > maxExtraFeeAsset0) revert GasAboveMax();\n            self.maxExtraFeeAsset0 = maxExtraFeeAsset0;\n        }\n\n        if (variant.zeroForOne()) {\n            AmountIn fee = AmountIn.wrap(extraFeeAsset0);\n\n            if (variant.specifyingInput()) {\n                quantityIn = AmountIn.wrap(quantity);\n                quantityOut = price.convertDown(quantityIn - fee);\n            } else {\n                quantityOut = AmountOut.wrap(quantity);\n                quantityIn = price.convertUp(quantityOut) + fee;\n            }\n        } else {\n            AmountOut fee = AmountOut.wrap(extraFeeAsset0);\n            if (variant.specifyingInput()) {\n                quantityIn = AmountIn.wrap(quantity);\n                quantityOut = price.convertDown(quantityIn) - fee;\n            } else {\n                quantityOut = AmountOut.wrap(quantity);\n                quantityIn = price.convertUp(quantityOut + fee);\n            }\n        }\n\n        return (reader, quantityIn, quantityOut);\n    }\n\n    function readOrderValidation(\n        UserOrderBuffer memory self,\n        CalldataReader reader,\n        UserOrderVariantMap variant\n    ) internal view returns (CalldataReader) {\n        if (variant.isStanding()) {\n            // Copy slices directly from calldata into memory.\n            assembly (\"memory-safe\") {\n                calldatacopy(\n                    add(self, add(NONCE_MEM_OFFSET, sub(0x20, NONCE_BYTES))), reader, NONCE_BYTES\n                )\n                reader := add(reader, NONCE_BYTES)\n                calldatacopy(\n                    add(self, add(DEADLINE_MEM_OFFSET, sub(0x20, DEADLINE_BYTES))),\n                    reader,\n                    DEADLINE_BYTES\n                )\n                reader := add(reader, DEADLINE_BYTES)\n            }\n        } else {\n            // Nothing loaded from calldata, reader stays unmodified.\n            self.nonce_or_validForBlock = uint64(block.number);\n        }\n        return reader;\n    }\n}\n"},"src/types/UserOrderVariantMap.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\ntype UserOrderVariantMap is uint8;\n\nusing UserOrderVariantMapLib for UserOrderVariantMap global;\n\n/// @author philogy <https://github.com/philogy>\nlibrary UserOrderVariantMapLib {\n    uint256 internal constant USE_INTERNAL_BIT = 0x01;\n    uint256 internal constant HAS_RECIPIENT_BIT = 0x02;\n    uint256 internal constant HAS_HOOK_BIT = 0x04;\n    uint256 internal constant ZERO_FOR_ONE_BIT = 0x08;\n    uint256 internal constant IS_STANDING_BIT = 0x10;\n    uint256 internal constant QTY_PARTIAL_BIT = 0x20;\n    uint256 internal constant IS_EXACT_IN_BIT = 0x40;\n    uint256 internal constant IS_ECDSA_BIT = 0x80;\n\n    uint256 internal constant SPECIFYING_IN_MASK = QTY_PARTIAL_BIT | IS_EXACT_IN_BIT;\n\n    function useInternal(UserOrderVariantMap variant) internal pure returns (bool) {\n        return UserOrderVariantMap.unwrap(variant) & USE_INTERNAL_BIT != 0;\n    }\n\n    function recipientIsSome(UserOrderVariantMap variant) internal pure returns (bool) {\n        return UserOrderVariantMap.unwrap(variant) & HAS_RECIPIENT_BIT != 0;\n    }\n\n    function noHook(UserOrderVariantMap variant) internal pure returns (bool) {\n        return UserOrderVariantMap.unwrap(variant) & HAS_HOOK_BIT == 0;\n    }\n\n    function zeroForOne(UserOrderVariantMap variant) internal pure returns (bool) {\n        return UserOrderVariantMap.unwrap(variant) & ZERO_FOR_ONE_BIT != 0;\n    }\n\n    function specifyingInput(UserOrderVariantMap variant) internal pure returns (bool) {\n        return UserOrderVariantMap.unwrap(variant) & SPECIFYING_IN_MASK != 0;\n    }\n\n    function isStanding(UserOrderVariantMap variant) internal pure returns (bool) {\n        return UserOrderVariantMap.unwrap(variant) & IS_STANDING_BIT != 0;\n    }\n\n    function quantitiesPartial(UserOrderVariantMap variant) internal pure returns (bool) {\n        return UserOrderVariantMap.unwrap(variant) & QTY_PARTIAL_BIT != 0;\n    }\n\n    function exactIn(UserOrderVariantMap variant) internal pure returns (bool) {\n        return UserOrderVariantMap.unwrap(variant) & IS_EXACT_IN_BIT != 0;\n    }\n\n    function isEcdsa(UserOrderVariantMap variant) internal pure returns (bool) {\n        return UserOrderVariantMap.unwrap(variant) & IS_ECDSA_BIT != 0;\n    }\n}\n"},"src/interfaces/IAngstromAuth.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {StoreKey} from \"../types/StoreKey.sol\";\nimport {PoolConfigStore} from \"../libraries/PoolConfigStore.sol\";\n\nstruct ConfigEntryUpdate {\n    uint256 index;\n    StoreKey key;\n    uint24 bundleFee;\n    uint24 unlockedFee;\n    uint24 protocolUnlockedFee;\n}\n\ninterface IAngstromAuth {\n    function setController(address newController) external;\n\n    function collect_unlock_swap_fees(address to, bytes calldata packed_assets) external;\n\n    function configurePool(\n        address assetA,\n        address assetB,\n        uint16 tickSpacing,\n        uint24 bundleFee,\n        uint24 unlockedFee,\n        uint24 protocolUnlockedFee\n    ) external;\n\n    function removePool(StoreKey key, PoolConfigStore expectedStore, uint256 storeIndex) external;\n\n    function batchUpdatePools(PoolConfigStore expected_store, ConfigEntryUpdate[] calldata updates)\n        external;\n\n    function pullFee(address asset, uint256 amount) external;\n\n    function toggleNodes(address[] calldata nodes) external;\n\n    function extsload(uint256 slot) external view returns (uint256);\n}\n"},"src/libraries/PoolConfigStore.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {\n    ConfigEntry,\n    ConfigEntryLib,\n    ENTRY_SIZE,\n    KEY_MASK,\n    TICK_SPACING_OFFSET,\n    TICK_SPACING_MASK,\n    FEE_OFFSET,\n    FEE_MASK\n} from \"../types/ConfigEntry.sol\";\nimport {StoreKey} from \"../types/StoreKey.sol\";\nimport {ConfigBuffer} from \"../types/ConfigBuffer.sol\";\n\ntype PoolConfigStore is address;\n\nuint256 constant MEMORY_OFFSET_OFFSET = 192;\nuint256 constant STORE_ADDR_OFFSET = 32;\nuint256 constant SIZE_OFFSET = 0;\nuint256 constant SIZE_MASK = 0xffffffff;\nuint256 constant STORE_HEADER_SIZE = 1;\n\nusing PoolConfigStoreLib for PoolConfigStore global;\n\nusing {PoolConfigStore_neq as !=} for PoolConfigStore global;\n\nfunction PoolConfigStore_neq(PoolConfigStore a, PoolConfigStore b) pure returns (bool neq) {\n    return PoolConfigStore.unwrap(a) != PoolConfigStore.unwrap(b);\n}\n\n/// @author philogy <https://github.com/philogy>\n/// @dev Handles deploying and querying of \"pool config store contracts\", SSTORE2 contracts that\n/// store the list of configured pools in their bytecode for the sake of saving gas (cold contract\n/// code read costs `2600 + 3 * n` vs. `2100 * ceil(n / 32)` for storage, where `n` is the number of\n/// bytes to be read). Since the pool config is read with every bundle and we expect to very quickly\n/// have more than 1 pair leveraging the \"more expensive writes for cheaper reads\" trade-off is worth it.\nlibrary PoolConfigStoreLib {\n    PoolConfigStore internal constant NULL_CONFIG_CACHE = PoolConfigStore.wrap(address(0));\n\n    error NoEntry();\n\n    error FailedToDeployNewStore();\n\n    /*\n     * @dev Generated from ./StoreDeployer.huff using https://github.com/Philogy/py-huff (commit: 44bbb4b)\n     *  PC   OP BYTES   INSTRUCTION   STACK (Top -> Down)          COMMENT\n     * ----------------------------------------------------------------------------------------------\n     * Constructor Code\n     *   0   600b       PUSH1 11      [11]                         Push constructor size\n     *   2   38         CODESIZE      [codesize, 11]               Sum of all bytes including runtime\n     *   3   03         SUB           [run_size]                   Subtracting to compute the runtime size\n     *   4   80         DUP1          [run_size, run_size]         Duplicate for later\n     *   5   600b       PUSH1 11      [11, run_size, run_size]     Push constructor size again\n     *   7   5f         PUSH0         [0, 11, run_size, run_size]\n     *   8   39         CODECOPY      [run_size]                   Copy the runtime code into memory\n     *                                                             (`memory[0:0+run_size] = code[11:11+run_size]`)\n     *   9   5f         PUSH0         [0, run_size]\n     *  10   f3         RETURN        []                           Return runtime from memory as final code\n     *                                                             (`runtime = memory[0:runsize]`)\n     * Runtime Code\n     *   0   00         STOP          []                           Stop execution. Ensure that even if\n     *                                                             called the store contract cannot do\n     *                                                             anything like SELFDESTRUCTing itself.\n     **/\n    uint256 internal constant STORE_DEPLOYER = 0x600b380380600b5f395ff300;\n    uint256 internal constant STORE_DEPLOYER_BYTES = 12;\n\n    /// @dev Copy to the entries from the store to a new buffer. Does\n    function read_to_buffer(PoolConfigStore self) internal view returns (ConfigBuffer memory) {\n        return self.read_to_buffer(0);\n    }\n\n    function read_to_buffer(PoolConfigStore self, uint256 extra_capacity)\n        internal\n        view\n        returns (ConfigBuffer memory buffer)\n    {\n        uint256 entry_count = self.totalEntries();\n        uint256 capacity = entry_count + extra_capacity;\n\n        buffer.reset_and_alloc_capacity(capacity);\n\n        // Copy store contents into buffer.\n        ConfigEntry[] memory entries = buffer.entries;\n        assembly (\"memory-safe\") {\n            // Copy all the entries from store into the buffer.\n            let bytes_to_copy := mul(entry_count, ENTRY_SIZE)\n            extcodecopy(self, add(entries, 0x20), STORE_HEADER_SIZE, bytes_to_copy)\n        }\n\n        // Safety: We allocated at least `entry_count` capacity and have copied exactly\n        // `entry_count` valid entries from the store into the buffer.\n        buffer.unsafe_resize(entry_count);\n    }\n\n    function store_from_buffer(ConfigBuffer memory buffer)\n        internal\n        returns (PoolConfigStore new_store)\n    {\n        ConfigEntry[] memory entries = buffer.entries;\n        uint256 entry_count = entries.length;\n\n        assembly (\"memory-safe\") {\n            // Temporarily overwrite `entries.length` with deployer bytecode.\n            mstore(entries, STORE_DEPLOYER)\n            // Create store contract.\n            new_store :=\n                create(\n                    0,\n                    add(entries, sub(0x20, STORE_DEPLOYER_BYTES)),\n                    add(STORE_DEPLOYER_BYTES, mul(entry_count, ENTRY_SIZE))\n                )\n            // Reset length to previous value.\n            mstore(entries, entry_count)\n        }\n\n        /// Verify that the deployment was successful.\n        if (PoolConfigStore.unwrap(new_store) == address(0)) {\n            revert FailedToDeployNewStore();\n        }\n    }\n\n    function totalEntries(PoolConfigStore self) internal view returns (uint256) {\n        return PoolConfigStore.unwrap(self).code.length / ENTRY_SIZE;\n    }\n\n    function getWithDefaultEmpty(PoolConfigStore self, StoreKey key, uint256 index)\n        internal\n        view\n        returns (ConfigEntry entry)\n    {\n        assembly (\"memory-safe\") {\n            // Copy from store into scratch space.\n            extcodecopy(self, 0x00, add(STORE_HEADER_SIZE, mul(ENTRY_SIZE, index)), ENTRY_SIZE)\n            // Zero out entry if keys do not match.\n            entry := mload(0x00)\n            entry := mul(entry, eq(key, and(entry, KEY_MASK)))\n        }\n    }\n\n    function get(PoolConfigStore self, StoreKey key, uint256 index)\n        internal\n        view\n        returns (int24 tickSpacing, uint24 bundleFee)\n    {\n        ConfigEntry entry = self.getWithDefaultEmpty(key, index);\n        if (entry.isEmpty()) revert NoEntry();\n        tickSpacing = int24(uint24(entry.tickSpacing()));\n        bundleFee = entry.bundleFee();\n    }\n\n    function into(PoolConfigStore self) internal pure returns (address) {\n        return PoolConfigStore.unwrap(self);\n    }\n}\n"},"src/types/StoreKey.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/// @dev Left shift in bits to convert the full hash `keccak256(abi.encode(asset0, asset1))` to a store key.\nuint256 constant HASH_TO_STORE_KEY_SHIFT = 40;\n\ntype StoreKey is bytes27;\n\nusing StoreKeyLib for StoreKey global;\nusing {StoreKey_eq as ==, StoreKey_neq as !=} for StoreKey global;\n\nfunction StoreKey_eq(StoreKey a, StoreKey b) pure returns (bool) {\n    return StoreKey.unwrap(a) == StoreKey.unwrap(b);\n}\n\nfunction StoreKey_neq(StoreKey a, StoreKey b) pure returns (bool) {\n    return StoreKey.unwrap(a) != StoreKey.unwrap(b);\n}\n\n/// @author philogy <https://github.com/philogy>\nlibrary StoreKeyLib {\n    /// @dev Computes the `StoreKey` from the inputs. WARN: Does not check that the assets are\n    /// sorted and in unique order.\n    function keyFromAssetsUnchecked(address asset0, address asset1)\n        internal\n        pure\n        returns (StoreKey key)\n    {\n        assembly (\"memory-safe\") {\n            mstore(0x00, asset0)\n            mstore(0x20, asset1)\n            key := shl(HASH_TO_STORE_KEY_SHIFT, keccak256(0x00, 0x40))\n        }\n    }\n}\n"},"src/types/ConfigEntry.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {StoreKey} from \"./StoreKey.sol\";\nimport {TickMath} from \"v4-core/src/libraries/TickMath.sol\";\n\n/// @dev Packed `storeKey:u216 ++ tickSpacing:u16 ++ feeInE6:u24`\ntype ConfigEntry is uint256;\n\nuint256 constant ENTRY_SIZE = 32;\nuint256 constant KEY_MASK = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffff0000000000;\nuint256 constant TICK_SPACING_MASK = 0xffff;\nuint256 constant TICK_SPACING_OFFSET = 24;\nuint256 constant FEE_MASK = 0xffffff;\nuint256 constant FEE_OFFSET = 0;\n\n/// @dev Max bundle fee.\nuint24 constant MAX_FEE = 0.2e6;\n/// @dev 100% fee in `bundleFee` units (pips).\nuint24 constant ONE_E6 = 1.0e6;\n\nusing ConfigEntryLib for ConfigEntry global;\n\n/// @author philogy <https://github.com/philogy>\nlibrary ConfigEntryLib {\n    error InvalidTickSpacing();\n    error FeeAboveMax();\n\n    function isEmpty(ConfigEntry self) internal pure returns (bool) {\n        return ConfigEntry.unwrap(self) == 0;\n    }\n\n    function init(StoreKey skey, uint16 spacing, uint24 fee) internal pure returns (ConfigEntry) {\n        _checkTickSpacing(spacing);\n        _checkBundleFee(fee);\n        // forgefmt: disable-next-item\n        return ConfigEntry.wrap(uint256(bytes32(StoreKey.unwrap(skey))))\n            .setTickSpacing(spacing)\n            .setBundleFee(fee);\n    }\n\n    function key(ConfigEntry self) internal pure returns (StoreKey) {\n        return StoreKey.wrap(bytes27(bytes32(ConfigEntry.unwrap(self))));\n    }\n\n    uint256 internal constant MIN_TICK_SPACING = uint24(TickMath.MIN_TICK_SPACING);\n    uint256 internal constant MAX_TICK_SPACING = uint24(TickMath.MAX_TICK_SPACING);\n\n    function setTickSpacing(ConfigEntry self, uint16 spacing)\n        internal\n        pure\n        returns (ConfigEntry updated)\n    {\n        _checkTickSpacing(spacing);\n        uint256 backing = ConfigEntry.unwrap(self);\n        uint256 xoredSpacing = spacing ^ uint24(self.tickSpacing());\n        updated = ConfigEntry.wrap(backing ^ (xoredSpacing << TICK_SPACING_OFFSET));\n        return updated;\n    }\n\n    function tickSpacing(ConfigEntry self) internal pure returns (uint16 spacing) {\n        assembly (\"memory-safe\") {\n            spacing := and(TICK_SPACING_MASK, shr(TICK_SPACING_OFFSET, self))\n        }\n    }\n\n    function setBundleFee(ConfigEntry self, uint24 fee)\n        internal\n        pure\n        returns (ConfigEntry updated)\n    {\n        _checkBundleFee(fee);\n        uint256 backing = ConfigEntry.unwrap(self);\n        uint256 xoredFee = fee ^ self.bundleFee();\n        updated = ConfigEntry.wrap(backing ^ (xoredFee << FEE_OFFSET));\n        return updated;\n    }\n\n    function bundleFee(ConfigEntry self) internal pure returns (uint24 fee) {\n        assembly (\"memory-safe\") {\n            fee := and(FEE_MASK, shr(FEE_OFFSET, self))\n        }\n    }\n\n    function _checkTickSpacing(uint16 spacing) internal pure {\n        if (spacing < MIN_TICK_SPACING || spacing > MAX_TICK_SPACING) {\n            revert InvalidTickSpacing();\n        }\n    }\n\n    function _checkBundleFee(uint24 fee) internal pure {\n        if (fee > MAX_FEE) revert FeeAboveMax();\n    }\n}\n"},"src/types/ConfigBuffer.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {ConfigEntry, ENTRY_SIZE} from \"./ConfigEntry.sol\";\nimport {StoreKey} from \"./StoreKey.sol\";\n\nstruct ConfigBuffer {\n    ConfigEntry[] entries;\n    uint256 capacity;\n}\n\nusing ConfigBufferLib for ConfigBuffer global;\n\n/// @author philogy <https://github.com/philogy>\nlibrary ConfigBufferLib {\n    error InsufficientCapacity();\n    error EntryKeyMismatch();\n\n    function get(ConfigBuffer memory self, StoreKey key, uint256 index)\n        internal\n        pure\n        returns (ConfigEntry entry)\n    {\n        entry = self.entries[index];\n        if (entry.key() != key) revert EntryKeyMismatch();\n        return entry;\n    }\n\n    /// @dev Allocate memory for `capacity` entries and resets le\n    function reset_and_alloc_capacity(ConfigBuffer memory self, uint256 capacity) internal pure {\n        self.capacity = capacity;\n        assembly (\"memory-safe\") {\n            // Alloc entry space.\n            let entries := mload(0x40)\n            mstore(0x40, add(entries, add(mul(capacity, ENTRY_SIZE), 0x20)))\n            // Set  default length to 0.\n            mstore(entries, 0)\n            // Set ptr `self.entries`.\n            mstore(self, entries)\n        }\n    }\n\n    function remove_entry(ConfigBuffer memory self, StoreKey key, uint256 index) internal pure {\n        if (self.entries[index].key() != key) revert EntryKeyMismatch();\n\n        uint256 newLength = self.entries.length - 1;\n        if (index < newLength) {\n            self.entries[index] = self.entries[newLength];\n        }\n        // Set new length to `length - 1`.\n        unsafe_resize(self, newLength);\n    }\n\n    /// @dev Add a new entry to the store. WARNING: Responsibility of caller to ensure that `entry`\n    /// does *not* contain a duplicate key otherwise key uniqueness invariant will be broken.\n    function unsafe_add(ConfigBuffer memory self, ConfigEntry entry) internal pure {\n        uint256 prev_length = self.entries.length;\n        if (prev_length == self.capacity) revert InsufficientCapacity();\n\n        unsafe_resize(self, prev_length + 1);\n        self.entries[prev_length] = entry;\n    }\n\n    /// @dev Sets the length of the buffer to an arbitrary length `new_length`. WARNING:\n    /// Responsibility of the caller to ensure that the length is either being *decreased* from a\n    /// valid length or increased at most to the capacity and only to contain valid entries.\n    function unsafe_resize(ConfigBuffer memory self, uint256 new_length) internal pure {\n        ConfigEntry[] memory entries = self.entries;\n        assembly (\"memory-safe\") {\n            mstore(entries, new_length)\n        }\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/interfaces/IHooks.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {PoolKey} from \"../types/PoolKey.sol\";\nimport {BalanceDelta} from \"../types/BalanceDelta.sol\";\nimport {IPoolManager} from \"./IPoolManager.sol\";\nimport {BeforeSwapDelta} from \"../types/BeforeSwapDelta.sol\";\n\n/// @notice V4 decides whether to invoke specific hooks by inspecting the least significant bits\n/// of the address that the hooks contract is deployed to.\n/// For example, a hooks contract deployed to address: 0x0000000000000000000000000000000000002400\n/// has the lowest bits '10 0100 0000 0000' which would cause the 'before initialize' and 'after add liquidity' hooks to be used.\n/// See the Hooks library for the full spec.\n/// @dev Should only be callable by the v4 PoolManager.\ninterface IHooks {\n    /// @notice The hook called before the state of a pool is initialized\n    /// @param sender The initial msg.sender for the initialize call\n    /// @param key The key for the pool being initialized\n    /// @param sqrtPriceX96 The sqrt(price) of the pool as a Q64.96\n    /// @return bytes4 The function selector for the hook\n    function beforeInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96) external returns (bytes4);\n\n    /// @notice The hook called after the state of a pool is initialized\n    /// @param sender The initial msg.sender for the initialize call\n    /// @param key The key for the pool being initialized\n    /// @param sqrtPriceX96 The sqrt(price) of the pool as a Q64.96\n    /// @param tick The current tick after the state of a pool is initialized\n    /// @return bytes4 The function selector for the hook\n    function afterInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96, int24 tick)\n        external\n        returns (bytes4);\n\n    /// @notice The hook called before liquidity is added\n    /// @param sender The initial msg.sender for the add liquidity call\n    /// @param key The key for the pool\n    /// @param params The parameters for adding liquidity\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidity provider to be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function beforeAddLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called after liquidity is added\n    /// @param sender The initial msg.sender for the add liquidity call\n    /// @param key The key for the pool\n    /// @param params The parameters for adding liquidity\n    /// @param delta The caller's balance delta after adding liquidity; the sum of principal delta, fees accrued, and hook delta\n    /// @param feesAccrued The fees accrued since the last time fees were collected from this position\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidity provider to be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    /// @return BalanceDelta The hook's delta in token0 and token1. Positive: the hook is owed/took currency, negative: the hook owes/sent currency\n    function afterAddLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        BalanceDelta delta,\n        BalanceDelta feesAccrued,\n        bytes calldata hookData\n    ) external returns (bytes4, BalanceDelta);\n\n    /// @notice The hook called before liquidity is removed\n    /// @param sender The initial msg.sender for the remove liquidity call\n    /// @param key The key for the pool\n    /// @param params The parameters for removing liquidity\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidity provider to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function beforeRemoveLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called after liquidity is removed\n    /// @param sender The initial msg.sender for the remove liquidity call\n    /// @param key The key for the pool\n    /// @param params The parameters for removing liquidity\n    /// @param delta The caller's balance delta after removing liquidity; the sum of principal delta, fees accrued, and hook delta\n    /// @param feesAccrued The fees accrued since the last time fees were collected from this position\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidity provider to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    /// @return BalanceDelta The hook's delta in token0 and token1. Positive: the hook is owed/took currency, negative: the hook owes/sent currency\n    function afterRemoveLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        BalanceDelta delta,\n        BalanceDelta feesAccrued,\n        bytes calldata hookData\n    ) external returns (bytes4, BalanceDelta);\n\n    /// @notice The hook called before a swap\n    /// @param sender The initial msg.sender for the swap call\n    /// @param key The key for the pool\n    /// @param params The parameters for the swap\n    /// @param hookData Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    /// @return BeforeSwapDelta The hook's delta in specified and unspecified currencies. Positive: the hook is owed/took currency, negative: the hook owes/sent currency\n    /// @return uint24 Optionally override the lp fee, only used if three conditions are met: 1. the Pool has a dynamic fee, 2. the value's 2nd highest bit is set (23rd bit, 0x400000), and 3. the value is less than or equal to the maximum fee (1 million)\n    function beforeSwap(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        bytes calldata hookData\n    ) external returns (bytes4, BeforeSwapDelta, uint24);\n\n    /// @notice The hook called after a swap\n    /// @param sender The initial msg.sender for the swap call\n    /// @param key The key for the pool\n    /// @param params The parameters for the swap\n    /// @param delta The amount owed to the caller (positive) or owed to the pool (negative)\n    /// @param hookData Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    /// @return int128 The hook's delta in unspecified currency. Positive: the hook is owed/took currency, negative: the hook owes/sent currency\n    function afterSwap(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        BalanceDelta delta,\n        bytes calldata hookData\n    ) external returns (bytes4, int128);\n\n    /// @notice The hook called before donate\n    /// @param sender The initial msg.sender for the donate call\n    /// @param key The key for the pool\n    /// @param amount0 The amount of token0 being donated\n    /// @param amount1 The amount of token1 being donated\n    /// @param hookData Arbitrary data handed into the PoolManager by the donor to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function beforeDonate(\n        address sender,\n        PoolKey calldata key,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called after donate\n    /// @param sender The initial msg.sender for the donate call\n    /// @param key The key for the pool\n    /// @param amount0 The amount of token0 being donated\n    /// @param amount1 The amount of token1 being donated\n    /// @param hookData Arbitrary data handed into the PoolManager by the donor to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function afterDonate(\n        address sender,\n        PoolKey calldata key,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata hookData\n    ) external returns (bytes4);\n}\n"},"lib/v4-periphery/lib/v4-core/src/types/PoolKey.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Currency} from \"./Currency.sol\";\nimport {IHooks} from \"../interfaces/IHooks.sol\";\nimport {PoolIdLibrary} from \"./PoolId.sol\";\n\nusing PoolIdLibrary for PoolKey global;\n\n/// @notice Returns the key for identifying a pool\nstruct PoolKey {\n    /// @notice The lower currency of the pool, sorted numerically\n    Currency currency0;\n    /// @notice The higher currency of the pool, sorted numerically\n    Currency currency1;\n    /// @notice The pool LP fee, capped at 1_000_000. If the highest bit is 1, the pool has a dynamic fee and must be exactly equal to 0x800000\n    uint24 fee;\n    /// @notice Ticks that involve positions must be a multiple of tick spacing\n    int24 tickSpacing;\n    /// @notice The hooks of the pool\n    IHooks hooks;\n}\n"},"lib/solady/src/utils/SafeCastLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Safe integer casting library that reverts on overflow.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeCastLib.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\n/// @dev Optimized for runtime gas for very high number of optimizer runs (i.e. >= 1000000).\nlibrary SafeCastLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Unable to cast to the target type due to overflow.\n    error Overflow();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*          UNSIGNED INTEGER SAFE CASTING OPERATIONS          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Casts `x` to a uint8. Reverts on overflow.\n    function toUint8(uint256 x) internal pure returns (uint8) {\n        if (x >= 1 << 8) _revertOverflow();\n        return uint8(x);\n    }\n\n    /// @dev Casts `x` to a uint16. Reverts on overflow.\n    function toUint16(uint256 x) internal pure returns (uint16) {\n        if (x >= 1 << 16) _revertOverflow();\n        return uint16(x);\n    }\n\n    /// @dev Casts `x` to a uint24. Reverts on overflow.\n    function toUint24(uint256 x) internal pure returns (uint24) {\n        if (x >= 1 << 24) _revertOverflow();\n        return uint24(x);\n    }\n\n    /// @dev Casts `x` to a uint32. Reverts on overflow.\n    function toUint32(uint256 x) internal pure returns (uint32) {\n        if (x >= 1 << 32) _revertOverflow();\n        return uint32(x);\n    }\n\n    /// @dev Casts `x` to a uint40. Reverts on overflow.\n    function toUint40(uint256 x) internal pure returns (uint40) {\n        if (x >= 1 << 40) _revertOverflow();\n        return uint40(x);\n    }\n\n    /// @dev Casts `x` to a uint48. Reverts on overflow.\n    function toUint48(uint256 x) internal pure returns (uint48) {\n        if (x >= 1 << 48) _revertOverflow();\n        return uint48(x);\n    }\n\n    /// @dev Casts `x` to a uint56. Reverts on overflow.\n    function toUint56(uint256 x) internal pure returns (uint56) {\n        if (x >= 1 << 56) _revertOverflow();\n        return uint56(x);\n    }\n\n    /// @dev Casts `x` to a uint64. Reverts on overflow.\n    function toUint64(uint256 x) internal pure returns (uint64) {\n        if (x >= 1 << 64) _revertOverflow();\n        return uint64(x);\n    }\n\n    /// @dev Casts `x` to a uint72. Reverts on overflow.\n    function toUint72(uint256 x) internal pure returns (uint72) {\n        if (x >= 1 << 72) _revertOverflow();\n        return uint72(x);\n    }\n\n    /// @dev Casts `x` to a uint80. Reverts on overflow.\n    function toUint80(uint256 x) internal pure returns (uint80) {\n        if (x >= 1 << 80) _revertOverflow();\n        return uint80(x);\n    }\n\n    /// @dev Casts `x` to a uint88. Reverts on overflow.\n    function toUint88(uint256 x) internal pure returns (uint88) {\n        if (x >= 1 << 88) _revertOverflow();\n        return uint88(x);\n    }\n\n    /// @dev Casts `x` to a uint96. Reverts on overflow.\n    function toUint96(uint256 x) internal pure returns (uint96) {\n        if (x >= 1 << 96) _revertOverflow();\n        return uint96(x);\n    }\n\n    /// @dev Casts `x` to a uint104. Reverts on overflow.\n    function toUint104(uint256 x) internal pure returns (uint104) {\n        if (x >= 1 << 104) _revertOverflow();\n        return uint104(x);\n    }\n\n    /// @dev Casts `x` to a uint112. Reverts on overflow.\n    function toUint112(uint256 x) internal pure returns (uint112) {\n        if (x >= 1 << 112) _revertOverflow();\n        return uint112(x);\n    }\n\n    /// @dev Casts `x` to a uint120. Reverts on overflow.\n    function toUint120(uint256 x) internal pure returns (uint120) {\n        if (x >= 1 << 120) _revertOverflow();\n        return uint120(x);\n    }\n\n    /// @dev Casts `x` to a uint128. Reverts on overflow.\n    function toUint128(uint256 x) internal pure returns (uint128) {\n        if (x >= 1 << 128) _revertOverflow();\n        return uint128(x);\n    }\n\n    /// @dev Casts `x` to a uint136. Reverts on overflow.\n    function toUint136(uint256 x) internal pure returns (uint136) {\n        if (x >= 1 << 136) _revertOverflow();\n        return uint136(x);\n    }\n\n    /// @dev Casts `x` to a uint144. Reverts on overflow.\n    function toUint144(uint256 x) internal pure returns (uint144) {\n        if (x >= 1 << 144) _revertOverflow();\n        return uint144(x);\n    }\n\n    /// @dev Casts `x` to a uint152. Reverts on overflow.\n    function toUint152(uint256 x) internal pure returns (uint152) {\n        if (x >= 1 << 152) _revertOverflow();\n        return uint152(x);\n    }\n\n    /// @dev Casts `x` to a uint160. Reverts on overflow.\n    function toUint160(uint256 x) internal pure returns (uint160) {\n        if (x >= 1 << 160) _revertOverflow();\n        return uint160(x);\n    }\n\n    /// @dev Casts `x` to a uint168. Reverts on overflow.\n    function toUint168(uint256 x) internal pure returns (uint168) {\n        if (x >= 1 << 168) _revertOverflow();\n        return uint168(x);\n    }\n\n    /// @dev Casts `x` to a uint176. Reverts on overflow.\n    function toUint176(uint256 x) internal pure returns (uint176) {\n        if (x >= 1 << 176) _revertOverflow();\n        return uint176(x);\n    }\n\n    /// @dev Casts `x` to a uint184. Reverts on overflow.\n    function toUint184(uint256 x) internal pure returns (uint184) {\n        if (x >= 1 << 184) _revertOverflow();\n        return uint184(x);\n    }\n\n    /// @dev Casts `x` to a uint192. Reverts on overflow.\n    function toUint192(uint256 x) internal pure returns (uint192) {\n        if (x >= 1 << 192) _revertOverflow();\n        return uint192(x);\n    }\n\n    /// @dev Casts `x` to a uint200. Reverts on overflow.\n    function toUint200(uint256 x) internal pure returns (uint200) {\n        if (x >= 1 << 200) _revertOverflow();\n        return uint200(x);\n    }\n\n    /// @dev Casts `x` to a uint208. Reverts on overflow.\n    function toUint208(uint256 x) internal pure returns (uint208) {\n        if (x >= 1 << 208) _revertOverflow();\n        return uint208(x);\n    }\n\n    /// @dev Casts `x` to a uint216. Reverts on overflow.\n    function toUint216(uint256 x) internal pure returns (uint216) {\n        if (x >= 1 << 216) _revertOverflow();\n        return uint216(x);\n    }\n\n    /// @dev Casts `x` to a uint224. Reverts on overflow.\n    function toUint224(uint256 x) internal pure returns (uint224) {\n        if (x >= 1 << 224) _revertOverflow();\n        return uint224(x);\n    }\n\n    /// @dev Casts `x` to a uint232. Reverts on overflow.\n    function toUint232(uint256 x) internal pure returns (uint232) {\n        if (x >= 1 << 232) _revertOverflow();\n        return uint232(x);\n    }\n\n    /// @dev Casts `x` to a uint240. Reverts on overflow.\n    function toUint240(uint256 x) internal pure returns (uint240) {\n        if (x >= 1 << 240) _revertOverflow();\n        return uint240(x);\n    }\n\n    /// @dev Casts `x` to a uint248. Reverts on overflow.\n    function toUint248(uint256 x) internal pure returns (uint248) {\n        if (x >= 1 << 248) _revertOverflow();\n        return uint248(x);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*           SIGNED INTEGER SAFE CASTING OPERATIONS           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Casts `x` to a int8. Reverts on overflow.\n    function toInt8(int256 x) internal pure returns (int8) {\n        unchecked {\n            if (((1 << 7) + uint256(x)) >> 8 == uint256(0)) return int8(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int16. Reverts on overflow.\n    function toInt16(int256 x) internal pure returns (int16) {\n        unchecked {\n            if (((1 << 15) + uint256(x)) >> 16 == uint256(0)) return int16(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int24. Reverts on overflow.\n    function toInt24(int256 x) internal pure returns (int24) {\n        unchecked {\n            if (((1 << 23) + uint256(x)) >> 24 == uint256(0)) return int24(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int32. Reverts on overflow.\n    function toInt32(int256 x) internal pure returns (int32) {\n        unchecked {\n            if (((1 << 31) + uint256(x)) >> 32 == uint256(0)) return int32(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int40. Reverts on overflow.\n    function toInt40(int256 x) internal pure returns (int40) {\n        unchecked {\n            if (((1 << 39) + uint256(x)) >> 40 == uint256(0)) return int40(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int48. Reverts on overflow.\n    function toInt48(int256 x) internal pure returns (int48) {\n        unchecked {\n            if (((1 << 47) + uint256(x)) >> 48 == uint256(0)) return int48(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int56. Reverts on overflow.\n    function toInt56(int256 x) internal pure returns (int56) {\n        unchecked {\n            if (((1 << 55) + uint256(x)) >> 56 == uint256(0)) return int56(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int64. Reverts on overflow.\n    function toInt64(int256 x) internal pure returns (int64) {\n        unchecked {\n            if (((1 << 63) + uint256(x)) >> 64 == uint256(0)) return int64(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int72. Reverts on overflow.\n    function toInt72(int256 x) internal pure returns (int72) {\n        unchecked {\n            if (((1 << 71) + uint256(x)) >> 72 == uint256(0)) return int72(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int80. Reverts on overflow.\n    function toInt80(int256 x) internal pure returns (int80) {\n        unchecked {\n            if (((1 << 79) + uint256(x)) >> 80 == uint256(0)) return int80(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int88. Reverts on overflow.\n    function toInt88(int256 x) internal pure returns (int88) {\n        unchecked {\n            if (((1 << 87) + uint256(x)) >> 88 == uint256(0)) return int88(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int96. Reverts on overflow.\n    function toInt96(int256 x) internal pure returns (int96) {\n        unchecked {\n            if (((1 << 95) + uint256(x)) >> 96 == uint256(0)) return int96(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int104. Reverts on overflow.\n    function toInt104(int256 x) internal pure returns (int104) {\n        unchecked {\n            if (((1 << 103) + uint256(x)) >> 104 == uint256(0)) return int104(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int112. Reverts on overflow.\n    function toInt112(int256 x) internal pure returns (int112) {\n        unchecked {\n            if (((1 << 111) + uint256(x)) >> 112 == uint256(0)) return int112(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int120. Reverts on overflow.\n    function toInt120(int256 x) internal pure returns (int120) {\n        unchecked {\n            if (((1 << 119) + uint256(x)) >> 120 == uint256(0)) return int120(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int128. Reverts on overflow.\n    function toInt128(int256 x) internal pure returns (int128) {\n        unchecked {\n            if (((1 << 127) + uint256(x)) >> 128 == uint256(0)) return int128(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int136. Reverts on overflow.\n    function toInt136(int256 x) internal pure returns (int136) {\n        unchecked {\n            if (((1 << 135) + uint256(x)) >> 136 == uint256(0)) return int136(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int144. Reverts on overflow.\n    function toInt144(int256 x) internal pure returns (int144) {\n        unchecked {\n            if (((1 << 143) + uint256(x)) >> 144 == uint256(0)) return int144(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int152. Reverts on overflow.\n    function toInt152(int256 x) internal pure returns (int152) {\n        unchecked {\n            if (((1 << 151) + uint256(x)) >> 152 == uint256(0)) return int152(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int160. Reverts on overflow.\n    function toInt160(int256 x) internal pure returns (int160) {\n        unchecked {\n            if (((1 << 159) + uint256(x)) >> 160 == uint256(0)) return int160(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int168. Reverts on overflow.\n    function toInt168(int256 x) internal pure returns (int168) {\n        unchecked {\n            if (((1 << 167) + uint256(x)) >> 168 == uint256(0)) return int168(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int176. Reverts on overflow.\n    function toInt176(int256 x) internal pure returns (int176) {\n        unchecked {\n            if (((1 << 175) + uint256(x)) >> 176 == uint256(0)) return int176(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int184. Reverts on overflow.\n    function toInt184(int256 x) internal pure returns (int184) {\n        unchecked {\n            if (((1 << 183) + uint256(x)) >> 184 == uint256(0)) return int184(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int192. Reverts on overflow.\n    function toInt192(int256 x) internal pure returns (int192) {\n        unchecked {\n            if (((1 << 191) + uint256(x)) >> 192 == uint256(0)) return int192(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int200. Reverts on overflow.\n    function toInt200(int256 x) internal pure returns (int200) {\n        unchecked {\n            if (((1 << 199) + uint256(x)) >> 200 == uint256(0)) return int200(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int208. Reverts on overflow.\n    function toInt208(int256 x) internal pure returns (int208) {\n        unchecked {\n            if (((1 << 207) + uint256(x)) >> 208 == uint256(0)) return int208(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int216. Reverts on overflow.\n    function toInt216(int256 x) internal pure returns (int216) {\n        unchecked {\n            if (((1 << 215) + uint256(x)) >> 216 == uint256(0)) return int216(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int224. Reverts on overflow.\n    function toInt224(int256 x) internal pure returns (int224) {\n        unchecked {\n            if (((1 << 223) + uint256(x)) >> 224 == uint256(0)) return int224(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int232. Reverts on overflow.\n    function toInt232(int256 x) internal pure returns (int232) {\n        unchecked {\n            if (((1 << 231) + uint256(x)) >> 232 == uint256(0)) return int232(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int240. Reverts on overflow.\n    function toInt240(int256 x) internal pure returns (int240) {\n        unchecked {\n            if (((1 << 239) + uint256(x)) >> 240 == uint256(0)) return int240(x);\n            _revertOverflow();\n        }\n    }\n\n    /// @dev Casts `x` to a int248. Reverts on overflow.\n    function toInt248(int256 x) internal pure returns (int248) {\n        unchecked {\n            if (((1 << 247) + uint256(x)) >> 248 == uint256(0)) return int248(x);\n            _revertOverflow();\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*               OTHER SAFE CASTING OPERATIONS                */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Casts `x` to a int8. Reverts on overflow.\n    function toInt8(uint256 x) internal pure returns (int8) {\n        if (x >= 1 << 7) _revertOverflow();\n        return int8(int256(x));\n    }\n\n    /// @dev Casts `x` to a int16. Reverts on overflow.\n    function toInt16(uint256 x) internal pure returns (int16) {\n        if (x >= 1 << 15) _revertOverflow();\n        return int16(int256(x));\n    }\n\n    /// @dev Casts `x` to a int24. Reverts on overflow.\n    function toInt24(uint256 x) internal pure returns (int24) {\n        if (x >= 1 << 23) _revertOverflow();\n        return int24(int256(x));\n    }\n\n    /// @dev Casts `x` to a int32. Reverts on overflow.\n    function toInt32(uint256 x) internal pure returns (int32) {\n        if (x >= 1 << 31) _revertOverflow();\n        return int32(int256(x));\n    }\n\n    /// @dev Casts `x` to a int40. Reverts on overflow.\n    function toInt40(uint256 x) internal pure returns (int40) {\n        if (x >= 1 << 39) _revertOverflow();\n        return int40(int256(x));\n    }\n\n    /// @dev Casts `x` to a int48. Reverts on overflow.\n    function toInt48(uint256 x) internal pure returns (int48) {\n        if (x >= 1 << 47) _revertOverflow();\n        return int48(int256(x));\n    }\n\n    /// @dev Casts `x` to a int56. Reverts on overflow.\n    function toInt56(uint256 x) internal pure returns (int56) {\n        if (x >= 1 << 55) _revertOverflow();\n        return int56(int256(x));\n    }\n\n    /// @dev Casts `x` to a int64. Reverts on overflow.\n    function toInt64(uint256 x) internal pure returns (int64) {\n        if (x >= 1 << 63) _revertOverflow();\n        return int64(int256(x));\n    }\n\n    /// @dev Casts `x` to a int72. Reverts on overflow.\n    function toInt72(uint256 x) internal pure returns (int72) {\n        if (x >= 1 << 71) _revertOverflow();\n        return int72(int256(x));\n    }\n\n    /// @dev Casts `x` to a int80. Reverts on overflow.\n    function toInt80(uint256 x) internal pure returns (int80) {\n        if (x >= 1 << 79) _revertOverflow();\n        return int80(int256(x));\n    }\n\n    /// @dev Casts `x` to a int88. Reverts on overflow.\n    function toInt88(uint256 x) internal pure returns (int88) {\n        if (x >= 1 << 87) _revertOverflow();\n        return int88(int256(x));\n    }\n\n    /// @dev Casts `x` to a int96. Reverts on overflow.\n    function toInt96(uint256 x) internal pure returns (int96) {\n        if (x >= 1 << 95) _revertOverflow();\n        return int96(int256(x));\n    }\n\n    /// @dev Casts `x` to a int104. Reverts on overflow.\n    function toInt104(uint256 x) internal pure returns (int104) {\n        if (x >= 1 << 103) _revertOverflow();\n        return int104(int256(x));\n    }\n\n    /// @dev Casts `x` to a int112. Reverts on overflow.\n    function toInt112(uint256 x) internal pure returns (int112) {\n        if (x >= 1 << 111) _revertOverflow();\n        return int112(int256(x));\n    }\n\n    /// @dev Casts `x` to a int120. Reverts on overflow.\n    function toInt120(uint256 x) internal pure returns (int120) {\n        if (x >= 1 << 119) _revertOverflow();\n        return int120(int256(x));\n    }\n\n    /// @dev Casts `x` to a int128. Reverts on overflow.\n    function toInt128(uint256 x) internal pure returns (int128) {\n        if (x >= 1 << 127) _revertOverflow();\n        return int128(int256(x));\n    }\n\n    /// @dev Casts `x` to a int136. Reverts on overflow.\n    function toInt136(uint256 x) internal pure returns (int136) {\n        if (x >= 1 << 135) _revertOverflow();\n        return int136(int256(x));\n    }\n\n    /// @dev Casts `x` to a int144. Reverts on overflow.\n    function toInt144(uint256 x) internal pure returns (int144) {\n        if (x >= 1 << 143) _revertOverflow();\n        return int144(int256(x));\n    }\n\n    /// @dev Casts `x` to a int152. Reverts on overflow.\n    function toInt152(uint256 x) internal pure returns (int152) {\n        if (x >= 1 << 151) _revertOverflow();\n        return int152(int256(x));\n    }\n\n    /// @dev Casts `x` to a int160. Reverts on overflow.\n    function toInt160(uint256 x) internal pure returns (int160) {\n        if (x >= 1 << 159) _revertOverflow();\n        return int160(int256(x));\n    }\n\n    /// @dev Casts `x` to a int168. Reverts on overflow.\n    function toInt168(uint256 x) internal pure returns (int168) {\n        if (x >= 1 << 167) _revertOverflow();\n        return int168(int256(x));\n    }\n\n    /// @dev Casts `x` to a int176. Reverts on overflow.\n    function toInt176(uint256 x) internal pure returns (int176) {\n        if (x >= 1 << 175) _revertOverflow();\n        return int176(int256(x));\n    }\n\n    /// @dev Casts `x` to a int184. Reverts on overflow.\n    function toInt184(uint256 x) internal pure returns (int184) {\n        if (x >= 1 << 183) _revertOverflow();\n        return int184(int256(x));\n    }\n\n    /// @dev Casts `x` to a int192. Reverts on overflow.\n    function toInt192(uint256 x) internal pure returns (int192) {\n        if (x >= 1 << 191) _revertOverflow();\n        return int192(int256(x));\n    }\n\n    /// @dev Casts `x` to a int200. Reverts on overflow.\n    function toInt200(uint256 x) internal pure returns (int200) {\n        if (x >= 1 << 199) _revertOverflow();\n        return int200(int256(x));\n    }\n\n    /// @dev Casts `x` to a int208. Reverts on overflow.\n    function toInt208(uint256 x) internal pure returns (int208) {\n        if (x >= 1 << 207) _revertOverflow();\n        return int208(int256(x));\n    }\n\n    /// @dev Casts `x` to a int216. Reverts on overflow.\n    function toInt216(uint256 x) internal pure returns (int216) {\n        if (x >= 1 << 215) _revertOverflow();\n        return int216(int256(x));\n    }\n\n    /// @dev Casts `x` to a int224. Reverts on overflow.\n    function toInt224(uint256 x) internal pure returns (int224) {\n        if (x >= 1 << 223) _revertOverflow();\n        return int224(int256(x));\n    }\n\n    /// @dev Casts `x` to a int232. Reverts on overflow.\n    function toInt232(uint256 x) internal pure returns (int232) {\n        if (x >= 1 << 231) _revertOverflow();\n        return int232(int256(x));\n    }\n\n    /// @dev Casts `x` to a int240. Reverts on overflow.\n    function toInt240(uint256 x) internal pure returns (int240) {\n        if (x >= 1 << 239) _revertOverflow();\n        return int240(int256(x));\n    }\n\n    /// @dev Casts `x` to a int248. Reverts on overflow.\n    function toInt248(uint256 x) internal pure returns (int248) {\n        if (x >= 1 << 247) _revertOverflow();\n        return int248(int256(x));\n    }\n\n    /// @dev Casts `x` to a int256. Reverts on overflow.\n    function toInt256(uint256 x) internal pure returns (int256) {\n        if (int256(x) >= 0) return int256(x);\n        _revertOverflow();\n    }\n\n    /// @dev Casts `x` to a uint256. Reverts on overflow.\n    function toUint256(int256 x) internal pure returns (uint256) {\n        if (x >= 0) return uint256(x);\n        _revertOverflow();\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function _revertOverflow() private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Store the function selector of `Overflow()`.\n            mstore(0x00, 0x35278d12)\n            // Revert with (offset, size).\n            revert(0x1c, 0x04)\n        }\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/libraries/LPFeeLibrary.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {CustomRevert} from \"./CustomRevert.sol\";\n\n/// @notice Library of helper functions for a pools LP fee\nlibrary LPFeeLibrary {\n    using LPFeeLibrary for uint24;\n    using CustomRevert for bytes4;\n\n    /// @notice Thrown when the static or dynamic fee on a pool exceeds 100%.\n    error LPFeeTooLarge(uint24 fee);\n\n    /// @notice An lp fee of exactly 0b1000000... signals a dynamic fee pool. This isn't a valid static fee as it is > MAX_LP_FEE\n    uint24 public constant DYNAMIC_FEE_FLAG = 0x800000;\n\n    /// @notice the second bit of the fee returned by beforeSwap is used to signal if the stored LP fee should be overridden in this swap\n    // only dynamic-fee pools can return a fee via the beforeSwap hook\n    uint24 public constant OVERRIDE_FEE_FLAG = 0x400000;\n\n    /// @notice mask to remove the override fee flag from a fee returned by the beforeSwaphook\n    uint24 public constant REMOVE_OVERRIDE_MASK = 0xBFFFFF;\n\n    /// @notice the lp fee is represented in hundredths of a bip, so the max is 100%\n    uint24 public constant MAX_LP_FEE = 1000000;\n\n    /// @notice returns true if a pool's LP fee signals that the pool has a dynamic fee\n    /// @param self The fee to check\n    /// @return bool True of the fee is dynamic\n    function isDynamicFee(uint24 self) internal pure returns (bool) {\n        return self == DYNAMIC_FEE_FLAG;\n    }\n\n    /// @notice returns true if an LP fee is valid, aka not above the maximum permitted fee\n    /// @param self The fee to check\n    /// @return bool True of the fee is valid\n    function isValid(uint24 self) internal pure returns (bool) {\n        return self <= MAX_LP_FEE;\n    }\n\n    /// @notice validates whether an LP fee is larger than the maximum, and reverts if invalid\n    /// @param self The fee to validate\n    function validate(uint24 self) internal pure {\n        if (!self.isValid()) LPFeeTooLarge.selector.revertWith(self);\n    }\n\n    /// @notice gets and validates the initial LP fee for a pool. Dynamic fee pools have an initial fee of 0.\n    /// @dev if a dynamic fee pool wants a non-0 initial fee, it should call `updateDynamicLPFee` in the afterInitialize hook\n    /// @param self The fee to get the initial LP from\n    /// @return initialFee 0 if the fee is dynamic, otherwise the fee (if valid)\n    function getInitialLPFee(uint24 self) internal pure returns (uint24) {\n        // the initial fee for a dynamic fee pool is 0\n        if (self.isDynamicFee()) return 0;\n        self.validate();\n        return self;\n    }\n\n    /// @notice returns true if the fee has the override flag set (2nd highest bit of the uint24)\n    /// @param self The fee to check\n    /// @return bool True of the fee has the override flag set\n    function isOverride(uint24 self) internal pure returns (bool) {\n        return self & OVERRIDE_FEE_FLAG != 0;\n    }\n\n    /// @notice returns a fee with the override flag removed\n    /// @param self The fee to remove the override flag from\n    /// @return fee The fee without the override flag set\n    function removeOverrideFlag(uint24 self) internal pure returns (uint24) {\n        return self & REMOVE_OVERRIDE_MASK;\n    }\n\n    /// @notice Removes the override flag and validates the fee (reverts if the fee is too large)\n    /// @param self The fee to remove the override flag from, and then validate\n    /// @return fee The fee without the override flag set (if valid)\n    function removeOverrideFlagAndValidate(uint24 self) internal pure returns (uint24 fee) {\n        fee = self.removeOverrideFlag();\n        fee.validate();\n    }\n}\n"},"lib/solady/src/utils/SafeTransferLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Permit2 operations from (https://github.com/Uniswap/permit2/blob/main/src/libraries/Permit2Lib.sol)\n///\n/// @dev Note:\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\nlibrary SafeTransferLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ETH transfer has failed.\n    error ETHTransferFailed();\n\n    /// @dev The ERC20 `transferFrom` has failed.\n    error TransferFromFailed();\n\n    /// @dev The ERC20 `transfer` has failed.\n    error TransferFailed();\n\n    /// @dev The ERC20 `approve` has failed.\n    error ApproveFailed();\n\n    /// @dev The ERC20 `totalSupply` query has failed.\n    error TotalSupplyQueryFailed();\n\n    /// @dev The Permit2 operation has failed.\n    error Permit2Failed();\n\n    /// @dev The Permit2 amount must be less than `2**160 - 1`.\n    error Permit2AmountOverflow();\n\n    /// @dev The Permit2 approve operation has failed.\n    error Permit2ApproveFailed();\n\n    /// @dev The Permit2 lockdown operation has failed.\n    error Permit2LockdownFailed();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\n\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\n    /// storage reads and writes, but low enough to prevent griefing.\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\n\n    /// @dev The unique EIP-712 domain domain separator for the DAI token contract.\n    bytes32 internal constant DAI_DOMAIN_SEPARATOR = 0xdbb8cf42e1ecb028be3f3dbc922e1d878b963f411dc388ced501601c60f7c6f7;\n\n    /// @dev The address for the WETH9 contract on Ethereum mainnet.\n    address internal constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /// @dev The canonical Permit2 address.\n    /// [Github](https://github.com/Uniswap/permit2)\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\n    address internal constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       ETH OPERATIONS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\n    //\n    // The regular variants:\n    // - Forwards all remaining gas to the target.\n    // - Reverts if the target reverts.\n    // - Reverts if the current contract has insufficient balance.\n    //\n    // The force variants:\n    // - Forwards with an optional gas stipend\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\n    // - If the target reverts, or if the gas stipend is exhausted,\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\n    // - Reverts if the current contract has insufficient balance.\n    //\n    // The try variants:\n    // - Forwards with a mandatory gas stipend.\n    // - Instead of reverting, returns whether the transfer succeeded.\n\n    /// @dev Sends `amount` (in wei) ETH to `to`.\n    function safeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Sends all the ETH in the current contract to `to`.\n    function safeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer all the ETH and check if it succeeded or not.\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\n    function forceSafeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\n    function forceSafeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // forgefmt: disable-next-item\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal returns (bool success) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\n        }\n    }\n\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\n    function trySafeTransferAllETH(address to, uint256 gasStipend) internal returns (bool success) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      ERC20 OPERATIONS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for\n    /// the current contract to manage.\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            let success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    ///\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\n    function trySafeTransferFrom(address token, address from, address to, uint256 amount)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                success := lt(or(iszero(extcodesize(token)), returndatasize()), success)\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have their entire balance approved for the current contract to manage.\n    function safeTransferAllFrom(address token, address from, address to) internal returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransfer(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\n            mstore(0x20, address()) // Store the address of the current contract.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x14, to) // Store the `to` argument.\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// Reverts upon failure.\n    function safeApprove(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\n    /// Reverts upon failure.\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            // Perform the approval, retrying upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x34, 0) // Store 0 for the `amount`.\n                    mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n                    pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\n                    mstore(0x34, amount) // Store back the original `amount`.\n                    // Retry the approval, reverting upon failure.\n                    success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                    if iszero(and(eq(mload(0x00), 1), success)) {\n                        // Check the `extcodesize` again just in case the token selfdestructs lol.\n                        if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                            mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                            revert(0x1c, 0x04)\n                        }\n                    }\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\n    /// Returns zero if the `token` does not exist.\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, account) // Store the `account` argument.\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            amount :=\n                mul( // The arguments of `mul` are evaluated from right to left.\n                    mload(0x20),\n                    and( // The arguments of `and` are evaluated from right to left.\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\n                    )\n                )\n        }\n    }\n\n    /// @dev Returns the total supply of the `token`.\n    /// Reverts if the token does not exist or does not implement `totalSupply()`.\n    function totalSupply(address token) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x18160ddd) // `totalSupply()`.\n            if iszero(and(gt(returndatasize(), 0x1f), staticcall(gas(), token, 0x1c, 0x04, 0x00, 0x20))) {\n                mstore(0x00, 0x54cd9435) // `TotalSupplyQueryFailed()`.\n                revert(0x1c, 0x04)\n            }\n            result := mload(0x00)\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// If the initial attempt fails, try to use Permit2 to transfer the token.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\n    function safeTransferFrom2(address token, address from, address to, uint256 amount) internal {\n        if (!trySafeTransferFrom(token, from, to, amount)) {\n            permit2TransferFrom(token, from, to, amount);\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to` via Permit2.\n    /// Reverts upon failure.\n    function permit2TransferFrom(address token, address from, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 0x74), shr(96, shl(96, token)))\n            mstore(add(m, 0x54), amount)\n            mstore(add(m, 0x34), to)\n            mstore(add(m, 0x20), shl(96, from))\n            // `transferFrom(address,address,uint160,address)`.\n            mstore(m, 0x36c78516000000000000000000000000)\n            let p := PERMIT2\n            let exists := eq(chainid(), 1)\n            if iszero(exists) { exists := iszero(iszero(extcodesize(p))) }\n            if iszero(\n                and(\n                    call(gas(), p, 0, add(m, 0x10), 0x84, codesize(), 0x00),\n                    lt(iszero(extcodesize(token)), exists) // Token has code and Permit2 exists.\n                )\n            ) {\n                mstore(0x00, 0x7939f4248757f0fd) // `TransferFromFailed()` or `Permit2AmountOverflow()`.\n                revert(add(0x18, shl(2, iszero(iszero(shr(160, amount))))), 0x04)\n            }\n        }\n    }\n\n    /// @dev Permit a user to spend a given amount of\n    /// another user's tokens via native EIP-2612 permit if possible, falling\n    /// back to Permit2 if native permit fails or is not implemented on the token.\n    function permit2(\n        address token,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        bool success;\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} shl(96, xor(token, WETH9)) {} {\n                mstore(0x00, 0x3644e515) // `DOMAIN_SEPARATOR()`.\n                if iszero(\n                    and( // The arguments of `and` are evaluated from right to left.\n                        lt(iszero(mload(0x00)), eq(returndatasize(), 0x20)), // Returns 1 non-zero word.\n                        // Gas stipend to limit gas burn for tokens that don't refund gas when\n                        // an non-existing function is called. 5K should be enough for a SLOAD.\n                        staticcall(5000, token, 0x1c, 0x04, 0x00, 0x20)\n                    )\n                ) { break }\n                // After here, we can be sure that token is a contract.\n                let m := mload(0x40)\n                mstore(add(m, 0x34), spender)\n                mstore(add(m, 0x20), shl(96, owner))\n                mstore(add(m, 0x74), deadline)\n                if eq(mload(0x00), DAI_DOMAIN_SEPARATOR) {\n                    mstore(0x14, owner)\n                    mstore(0x00, 0x7ecebe00000000000000000000000000) // `nonces(address)`.\n                    mstore(add(m, 0x94), lt(iszero(amount), staticcall(gas(), token, 0x10, 0x24, add(m, 0x54), 0x20)))\n                    mstore(m, 0x8fcbaf0c000000000000000000000000) // `IDAIPermit.permit`.\n                    // `nonces` is already at `add(m, 0x54)`.\n                    // `amount != 0` is already stored at `add(m, 0x94)`.\n                    mstore(add(m, 0xb4), and(0xff, v))\n                    mstore(add(m, 0xd4), r)\n                    mstore(add(m, 0xf4), s)\n                    success := call(gas(), token, 0, add(m, 0x10), 0x104, codesize(), 0x00)\n                    break\n                }\n                mstore(m, 0xd505accf000000000000000000000000) // `IERC20Permit.permit`.\n                mstore(add(m, 0x54), amount)\n                mstore(add(m, 0x94), and(0xff, v))\n                mstore(add(m, 0xb4), r)\n                mstore(add(m, 0xd4), s)\n                success := call(gas(), token, 0, add(m, 0x10), 0xe4, codesize(), 0x00)\n                break\n            }\n        }\n        if (!success) simplePermit2(token, owner, spender, amount, deadline, v, r, s);\n    }\n\n    /// @dev Simple permit on the Permit2 contract.\n    function simplePermit2(\n        address token,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, 0x927da105) // `allowance(address,address,address)`.\n            {\n                let addressMask := shr(96, not(0))\n                mstore(add(m, 0x20), and(addressMask, owner))\n                mstore(add(m, 0x40), and(addressMask, token))\n                mstore(add(m, 0x60), and(addressMask, spender))\n                mstore(add(m, 0xc0), and(addressMask, spender))\n            }\n            let p := mul(PERMIT2, iszero(shr(160, amount)))\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x5f), // Returns 3 words: `amount`, `expiration`, `nonce`.\n                    staticcall(gas(), p, add(m, 0x1c), 0x64, add(m, 0x60), 0x60)\n                )\n            ) {\n                mstore(0x00, 0x6b836e6b8757f0fd) // `Permit2Failed()` or `Permit2AmountOverflow()`.\n                revert(add(0x18, shl(2, iszero(p))), 0x04)\n            }\n            mstore(m, 0x2b67b570) // `Permit2.permit` (PermitSingle variant).\n            // `owner` is already `add(m, 0x20)`.\n            // `token` is already at `add(m, 0x40)`.\n            mstore(add(m, 0x60), amount)\n            mstore(add(m, 0x80), 0xffffffffffff) // `expiration = type(uint48).max`.\n            // `nonce` is already at `add(m, 0xa0)`.\n            // `spender` is already at `add(m, 0xc0)`.\n            mstore(add(m, 0xe0), deadline)\n            mstore(add(m, 0x100), 0x100) // `signature` offset.\n            mstore(add(m, 0x120), 0x41) // `signature` length.\n            mstore(add(m, 0x140), r)\n            mstore(add(m, 0x160), s)\n            mstore(add(m, 0x180), shl(248, v))\n            if iszero( // Revert if token does not have code, or if the call fails.\n            mul(extcodesize(token), call(gas(), p, 0, add(m, 0x1c), 0x184, codesize(), 0x00))) {\n                mstore(0x00, 0x6b836e6b) // `Permit2Failed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Approves `spender` to spend `amount` of `token` for `address(this)`.\n    function permit2Approve(address token, address spender, uint160 amount, uint48 expiration) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let addressMask := shr(96, not(0))\n            let m := mload(0x40)\n            mstore(m, 0x87517c45) // `approve(address,address,uint160,uint48)`.\n            mstore(add(m, 0x20), and(addressMask, token))\n            mstore(add(m, 0x40), and(addressMask, spender))\n            mstore(add(m, 0x60), and(addressMask, amount))\n            mstore(add(m, 0x80), and(0xffffffffffff, expiration))\n            if iszero(call(gas(), PERMIT2, 0, add(m, 0x1c), 0xa0, codesize(), 0x00)) {\n                mstore(0x00, 0x324f14ae) // `Permit2ApproveFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Revokes an approval for `token` and `spender` for `address(this)`.\n    function permit2Lockdown(address token, address spender) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, 0xcc53287f) // `Permit2.lockdown`.\n            mstore(add(m, 0x20), 0x20) // Offset of the `approvals`.\n            mstore(add(m, 0x40), 1) // `approvals.length`.\n            mstore(add(m, 0x60), shr(96, shl(96, token)))\n            mstore(add(m, 0x80), shr(96, shl(96, spender)))\n            if iszero(call(gas(), PERMIT2, 0, add(m, 0x1c), 0xa0, codesize(), 0x00)) {\n                mstore(0x00, 0x96b3de23) // `Permit2LockdownFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n}\n"},"lib/solady/src/utils/SignatureCheckerLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Signature verification helper that supports both ECDSA signatures from EOAs\n/// and ERC1271 signatures from smart contract wallets like Argent and Gnosis safe.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SignatureCheckerLib.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/SignatureChecker.sol)\n///\n/// @dev Note:\n/// - The signature checking functions use the ecrecover precompile (0x1).\n/// - The `bytes memory signature` variants use the identity precompile (0x4)\n///   to copy memory internally.\n/// - Unlike ECDSA signatures, contract signatures are revocable.\n/// - As of Solady version 0.0.134, all `bytes signature` variants accept both\n///   regular 65-byte `(r, s, v)` and EIP-2098 `(r, vs)` short form signatures.\n///   See: https://eips.ethereum.org/EIPS/eip-2098\n///   This is for calldata efficiency on smart accounts prevalent on L2s.\n///\n/// WARNING! Do NOT use signatures as unique identifiers:\n/// - Use a nonce in the digest to prevent replay attacks on the same contract.\n/// - Use EIP-712 for the digest to prevent replay attacks across different chains and contracts.\n///   EIP-712 also enables readable signing of typed data for better user safety.\n/// This implementation does NOT check if a signature is non-malleable.\nlibrary SignatureCheckerLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*               SIGNATURE CHECKING OPERATIONS                */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns whether `signature` is valid for `signer` and `hash`.\n    /// If `signer.code.length == 0`, then validate with `ecrecover`, else\n    /// it will validate with ERC1271 on `signer`.\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        if (signer == address(0)) return isValid;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            for {} 1 {} {\n                if iszero(extcodesize(signer)) {\n                    switch mload(signature)\n                    case 64 {\n                        let vs := mload(add(signature, 0x40))\n                        mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                        mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                    }\n                    case 65 {\n                        mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n                        mstore(0x60, mload(add(signature, 0x40))) // `s`.\n                    }\n                    default { break }\n                    mstore(0x00, hash)\n                    mstore(0x40, mload(add(signature, 0x20))) // `r`.\n                    let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                    isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))\n                    mstore(0x60, 0) // Restore the zero slot.\n                    mstore(0x40, m) // Restore the free memory pointer.\n                    break\n                }\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                // Copy the `signature` over.\n                let n := add(0x20, mload(signature))\n                let copied := staticcall(gas(), 4, signature, n, add(m, 0x44), n)\n                isValid := staticcall(gas(), signer, m, add(returndatasize(), 0x44), d, 0x20)\n                isValid := and(eq(mload(d), f), and(isValid, copied))\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether `signature` is valid for `signer` and `hash`.\n    /// If `signer.code.length == 0`, then validate with `ecrecover`, else\n    /// it will validate with ERC1271 on `signer`.\n    function isValidSignatureNowCalldata(address signer, bytes32 hash, bytes calldata signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        if (signer == address(0)) return isValid;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            for {} 1 {} {\n                if iszero(extcodesize(signer)) {\n                    switch signature.length\n                    case 64 {\n                        let vs := calldataload(add(signature.offset, 0x20))\n                        mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                        mstore(0x40, calldataload(signature.offset)) // `r`.\n                        mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                    }\n                    case 65 {\n                        mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\n                        calldatacopy(0x40, signature.offset, 0x40) // `r`, `s`.\n                    }\n                    default { break }\n                    mstore(0x00, hash)\n                    let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                    isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))\n                    mstore(0x60, 0) // Restore the zero slot.\n                    mstore(0x40, m) // Restore the free memory pointer.\n                    break\n                }\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                mstore(add(m, 0x44), signature.length)\n                // Copy the `signature` over.\n                calldatacopy(add(m, 0x64), signature.offset, signature.length)\n                isValid := staticcall(gas(), signer, m, add(signature.length, 0x64), d, 0x20)\n                isValid := and(eq(mload(d), f), isValid)\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether the signature (`r`, `vs`) is valid for `signer` and `hash`.\n    /// If `signer.code.length == 0`, then validate with `ecrecover`, else\n    /// it will validate with ERC1271 on `signer`.\n    function isValidSignatureNow(address signer, bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        view\n        returns (bool isValid)\n    {\n        if (signer == address(0)) return isValid;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            for {} 1 {} {\n                if iszero(extcodesize(signer)) {\n                    mstore(0x00, hash)\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x40, r) // `r`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                    let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                    isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))\n                    mstore(0x60, 0) // Restore the zero slot.\n                    mstore(0x40, m) // Restore the free memory pointer.\n                    break\n                }\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                mstore(add(m, 0x44), 65) // Length of the signature.\n                mstore(add(m, 0x64), r) // `r`.\n                mstore(add(m, 0x84), shr(1, shl(1, vs))) // `s`.\n                mstore8(add(m, 0xa4), add(shr(255, vs), 27)) // `v`.\n                isValid := staticcall(gas(), signer, m, 0xa5, d, 0x20)\n                isValid := and(eq(mload(d), f), isValid)\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether the signature (`v`, `r`, `s`) is valid for `signer` and `hash`.\n    /// If `signer.code.length == 0`, then validate with `ecrecover`, else\n    /// it will validate with ERC1271 on `signer`.\n    function isValidSignatureNow(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (bool isValid)\n    {\n        if (signer == address(0)) return isValid;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            for {} 1 {} {\n                if iszero(extcodesize(signer)) {\n                    mstore(0x00, hash)\n                    mstore(0x20, and(v, 0xff)) // `v`.\n                    mstore(0x40, r) // `r`.\n                    mstore(0x60, s) // `s`.\n                    let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                    isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))\n                    mstore(0x60, 0) // Restore the zero slot.\n                    mstore(0x40, m) // Restore the free memory pointer.\n                    break\n                }\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                mstore(add(m, 0x44), 65) // Length of the signature.\n                mstore(add(m, 0x64), r) // `r`.\n                mstore(add(m, 0x84), s) // `s`.\n                mstore8(add(m, 0xa4), v) // `v`.\n                isValid := staticcall(gas(), signer, m, 0xa5, d, 0x20)\n                isValid := and(eq(mload(d), f), isValid)\n                break\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     ERC1271 OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Note: These ERC1271 operations do NOT have an ECDSA fallback.\n\n    /// @dev Returns whether `signature` is valid for `hash` for an ERC1271 `signer` contract.\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes memory signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            // Copy the `signature` over.\n            let n := add(0x20, mload(signature))\n            let copied := staticcall(gas(), 4, signature, n, add(m, 0x44), n)\n            isValid := staticcall(gas(), signer, m, add(returndatasize(), 0x44), d, 0x20)\n            isValid := and(eq(mload(d), f), and(isValid, copied))\n        }\n    }\n\n    /// @dev Returns whether `signature` is valid for `hash` for an ERC1271 `signer` contract.\n    function isValidERC1271SignatureNowCalldata(address signer, bytes32 hash, bytes calldata signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            mstore(add(m, 0x44), signature.length)\n            // Copy the `signature` over.\n            calldatacopy(add(m, 0x64), signature.offset, signature.length)\n            isValid := staticcall(gas(), signer, m, add(signature.length, 0x64), d, 0x20)\n            isValid := and(eq(mload(d), f), isValid)\n        }\n    }\n\n    /// @dev Returns whether the signature (`r`, `vs`) is valid for `hash`\n    /// for an ERC1271 `signer` contract.\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            mstore(add(m, 0x44), 65) // Length of the signature.\n            mstore(add(m, 0x64), r) // `r`.\n            mstore(add(m, 0x84), shr(1, shl(1, vs))) // `s`.\n            mstore8(add(m, 0xa4), add(shr(255, vs), 27)) // `v`.\n            isValid := staticcall(gas(), signer, m, 0xa5, d, 0x20)\n            isValid := and(eq(mload(d), f), isValid)\n        }\n    }\n\n    /// @dev Returns whether the signature (`v`, `r`, `s`) is valid for `hash`\n    /// for an ERC1271 `signer` contract.\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            mstore(add(m, 0x44), 65) // Length of the signature.\n            mstore(add(m, 0x64), r) // `r`.\n            mstore(add(m, 0x84), s) // `s`.\n            mstore8(add(m, 0xa4), v) // `v`.\n            isValid := staticcall(gas(), signer, m, 0xa5, d, 0x20)\n            isValid := and(eq(mload(d), f), isValid)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     ERC6492 OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Note: These ERC6492 operations now include an ECDSA fallback at the very end.\n    // The calldata variants are excluded for brevity.\n\n    /// @dev Returns whether `signature` is valid for `hash`.\n    /// If the signature is postfixed with the ERC6492 magic number, it will attempt to\n    /// deploy / prepare the `signer` smart account before doing a regular ERC1271 check.\n    /// Note: This function is NOT reentrancy safe.\n    /// The verifier must be deployed.\n    /// Otherwise, the function will return false if `signer` is not yet deployed / prepared.\n    /// See: https://gist.github.com/Vectorized/011d6becff6e0a73e42fe100f8d7ef04\n    /// With a dedicated verifier, this function is safe to use in contracts\n    /// that have been granted special permissions.\n    function isValidERC6492SignatureNowAllowSideEffects(address signer, bytes32 hash, bytes memory signature)\n        internal\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function callIsValidSignature(signer_, hash_, signature_) -> _isValid {\n                let m_ := mload(0x40)\n                let f_ := shl(224, 0x1626ba7e)\n                mstore(m_, f_) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m_, 0x04), hash_)\n                let d_ := add(m_, 0x24)\n                mstore(d_, 0x40) // The offset of the `signature` in the calldata.\n                let n_ := add(0x20, mload(signature_))\n                let copied_ := staticcall(gas(), 4, signature_, n_, add(m_, 0x44), n_)\n                _isValid := staticcall(gas(), signer_, m_, add(returndatasize(), 0x44), d_, 0x20)\n                _isValid := and(eq(mload(d_), f_), and(_isValid, copied_))\n            }\n            let noCode := iszero(extcodesize(signer))\n            let n := mload(signature)\n            for {} 1 {} {\n                if iszero(eq(mload(add(signature, n)), mul(0x6492, div(not(isValid), 0xffff)))) {\n                    if iszero(noCode) { isValid := callIsValidSignature(signer, hash, signature) }\n                    break\n                }\n                if iszero(noCode) {\n                    let o := add(signature, 0x20) // Signature bytes.\n                    isValid := callIsValidSignature(signer, hash, add(o, mload(add(o, 0x40))))\n                    if isValid { break }\n                }\n                let m := mload(0x40)\n                mstore(m, signer)\n                mstore(add(m, 0x20), hash)\n                pop(\n                    call(\n                        gas(), // Remaining gas.\n                        0x0000bc370E4DC924F427d84e2f4B9Ec81626ba7E, // Non-reverting verifier.\n                        0, // Send zero ETH.\n                        m, // Start of memory.\n                        add(returndatasize(), 0x40), // Length of calldata in memory.\n                        staticcall(gas(), 4, add(signature, 0x20), n, add(m, 0x40), n), // 1.\n                        0x00 // Length of returndata to write.\n                    )\n                )\n                isValid := returndatasize()\n                break\n            }\n            // Do `ecrecover` fallback if `noCode && !isValid`.\n            for {} gt(noCode, isValid) {} {\n                switch n\n                case 64 {\n                    let vs := mload(add(signature, 0x40))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                }\n                case 65 {\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\n                }\n                default { break }\n                let m := mload(0x40)\n                mstore(0x00, hash)\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\n                let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether `signature` is valid for `hash`.\n    /// If the signature is postfixed with the ERC6492 magic number, it will attempt\n    /// to use a reverting verifier to deploy / prepare the `signer` smart account\n    /// and do a `isValidSignature` check via the reverting verifier.\n    /// Note: This function is reentrancy safe.\n    /// The reverting verifier must be deployed.\n    /// Otherwise, the function will return false if `signer` is not yet deployed / prepared.\n    /// See: https://gist.github.com/Vectorized/846a474c855eee9e441506676800a9ad\n    function isValidERC6492SignatureNow(address signer, bytes32 hash, bytes memory signature)\n        internal\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function callIsValidSignature(signer_, hash_, signature_) -> _isValid {\n                let m_ := mload(0x40)\n                let f_ := shl(224, 0x1626ba7e)\n                mstore(m_, f_) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m_, 0x04), hash_)\n                let d_ := add(m_, 0x24)\n                mstore(d_, 0x40) // The offset of the `signature` in the calldata.\n                let n_ := add(0x20, mload(signature_))\n                let copied_ := staticcall(gas(), 4, signature_, n_, add(m_, 0x44), n_)\n                _isValid := staticcall(gas(), signer_, m_, add(returndatasize(), 0x44), d_, 0x20)\n                _isValid := and(eq(mload(d_), f_), and(_isValid, copied_))\n            }\n            let noCode := iszero(extcodesize(signer))\n            let n := mload(signature)\n            for {} 1 {} {\n                if iszero(eq(mload(add(signature, n)), mul(0x6492, div(not(isValid), 0xffff)))) {\n                    if iszero(noCode) { isValid := callIsValidSignature(signer, hash, signature) }\n                    break\n                }\n                if iszero(noCode) {\n                    let o := add(signature, 0x20) // Signature bytes.\n                    isValid := callIsValidSignature(signer, hash, add(o, mload(add(o, 0x40))))\n                    if isValid { break }\n                }\n                let m := mload(0x40)\n                mstore(m, signer)\n                mstore(add(m, 0x20), hash)\n                let willBeZeroIfRevertingVerifierExists :=\n                    call(\n                        gas(), // Remaining gas.\n                        0x00007bd799e4A591FeA53f8A8a3E9f931626Ba7e, // Reverting verifier.\n                        0, // Send zero ETH.\n                        m, // Start of memory.\n                        add(returndatasize(), 0x40), // Length of calldata in memory.\n                        staticcall(gas(), 4, add(signature, 0x20), n, add(m, 0x40), n), // 1.\n                        0x00 // Length of returndata to write.\n                    )\n                isValid := gt(returndatasize(), willBeZeroIfRevertingVerifierExists)\n                break\n            }\n            // Do `ecrecover` fallback if `noCode && !isValid`.\n            for {} gt(noCode, isValid) {} {\n                switch n\n                case 64 {\n                    let vs := mload(add(signature, 0x40))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                }\n                case 65 {\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\n                }\n                default { break }\n                let m := mload(0x40)\n                mstore(0x00, hash)\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\n                let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n                break\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     HASHING OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns an Ethereum Signed Message, created from a `hash`.\n    /// This produces a hash corresponding to the one signed with the\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\n    /// JSON-RPC method as part of EIP-191.\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, hash) // Store into scratch space for keccak256.\n            mstore(0x00, \"\\x00\\x00\\x00\\x00\\x19Ethereum Signed Message:\\n32\") // 28 bytes.\n            result := keccak256(0x04, 0x3c) // `32 * 2 - (32 - 28) = 60 = 0x3c`.\n        }\n    }\n\n    /// @dev Returns an Ethereum Signed Message, created from `s`.\n    /// This produces a hash corresponding to the one signed with the\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\n    /// JSON-RPC method as part of EIP-191.\n    /// Note: Supports lengths of `s` up to 999999 bytes.\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let sLength := mload(s)\n            let o := 0x20\n            mstore(o, \"\\x19Ethereum Signed Message:\\n\") // 26 bytes, zero-right-padded.\n            mstore(0x00, 0x00)\n            // Convert the `s.length` to ASCII decimal representation: `base10(s.length)`.\n            for { let temp := sLength } 1 {} {\n                o := sub(o, 1)\n                mstore8(o, add(48, mod(temp, 10)))\n                temp := div(temp, 10)\n                if iszero(temp) { break }\n            }\n            let n := sub(0x3a, o) // Header length: `26 + 32 - o`.\n            // Throw an out-of-offset error (consumes all gas) if the header exceeds 32 bytes.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0x20))\n            mstore(s, or(mload(0x00), mload(n))) // Temporarily store the header.\n            result := keccak256(add(s, sub(0x20, n)), add(n, sLength))\n            mstore(s, sLength) // Restore the length.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   EMPTY CALLDATA HELPERS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns an empty calldata bytes.\n    function emptySignature() internal pure returns (bytes calldata signature) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            signature.length := 0\n        }\n    }\n}\n"},"src/modules/UnlockSwapFeeCollector.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IPoolManager} from \"../interfaces/IUniV4.sol\";\nimport {IUnlockCallback} from \"v4-core/src/interfaces/callback/IUnlockCallback.sol\";\nimport {Currency} from \"v4-core/src/types/Currency.sol\";\n\n/// @author philogy <https://github.com/philogy>\ncontract UnlockSwapFeeCollector is IUnlockCallback {\n    error NotUniswap();\n    error NotOwner();\n\n    address internal immutable _owner;\n    IPoolManager internal immutable UNI_V4;\n\n    constructor(IPoolManager uniV4) {\n        _owner = msg.sender;\n        UNI_V4 = uniV4;\n    }\n\n    function withdraw_to(address to, bytes calldata packed_assets) external {\n        if (msg.sender != _owner) revert NotOwner();\n        UNI_V4.unlock(bytes.concat(bytes20(to), packed_assets));\n    }\n\n    function unlockCallback(bytes calldata data) external override returns (bytes memory) {\n        if (msg.sender != address(UNI_V4)) revert NotUniswap();\n\n        address to = address(bytes20(data[:20]));\n        data = data[20:];\n        uint256 iters = data.length / 20;\n\n        for (uint256 i = 0; i < iters; i++) {\n            address asset;\n            assembly {\n                asset := shr(96, calldataload(add(data.offset, mul(i, 20))))\n            }\n            uint256 bal = UNI_V4.balanceOf(address(this), uint160(asset));\n            UNI_V4.burn(address(this), uint160(asset), bal);\n            UNI_V4.take(Currency.wrap(asset), to, bal);\n        }\n\n        return \"\";\n    }\n}\n"},"lib/forge-std/src/interfaces/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\n/// @dev Interface of the ERC20 standard as defined in the EIP.\n/// @dev This includes the optional name, symbol, and decimals metadata.\ninterface IERC20 {\n    /// @dev Emitted when `value` tokens are moved from one account (`from`) to another (`to`).\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @dev Emitted when the allowance of a `spender` for an `owner` is set, where `value`\n    /// is the new allowance.\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice Returns the amount of tokens in existence.\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Returns the amount of tokens owned by `account`.\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Moves `amount` tokens from the caller's account to `to`.\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the remaining number of tokens that `spender` is allowed\n    /// to spend on behalf of `owner`\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Sets `amount` as the allowance of `spender` over the caller's tokens.\n    /// @dev Be aware of front-running risks: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Moves `amount` tokens from `from` to `to` using the allowance mechanism.\n    /// `amount` is then deducted from the caller's allowance.\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the name of the token.\n    function name() external view returns (string memory);\n\n    /// @notice Returns the symbol of the token.\n    function symbol() external view returns (string memory);\n\n    /// @notice Returns the decimals places of the token.\n    function decimals() external view returns (uint8);\n}\n"},"src/types/DeltaTracker.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {MixedSignLib} from \"../libraries/MixedSignLib.sol\";\nimport {tint256} from \"transient-goodies/TransientPrimitives.sol\";\n\nstruct DeltaTracker {\n    mapping(address asset => tint256 netBalances) deltas;\n}\n\nusing DeltaTrackerLib for DeltaTracker global;\n\n/// @author philogy <https://github.com/philogy>\n/// @dev Tracks intermediate value changes in the contract that need to be resolved. A _negative_\n/// delta means the contract is temporarily insolvent, a _positive_ delta means that contract has\n/// funds to use for payouts of different kinds.\nlibrary DeltaTrackerLib {\n    function add(DeltaTracker storage self, address asset, uint256 amount) internal {\n        tint256 storage delta = self.deltas[asset];\n        delta.set(MixedSignLib.add(delta.get(), amount));\n    }\n\n    function sub(DeltaTracker storage self, address asset, uint256 amount)\n        internal\n        returns (int256 newDelta)\n    {\n        tint256 storage delta = self.deltas[asset];\n        delta.set(newDelta = MixedSignLib.sub(delta.get(), amount));\n    }\n}\n"},"src/modules/GrowthOutsideUpdater.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.24;\n\n// import {console} from \"forge-std/console.sol\";\nimport {PoolId} from \"v4-core/src/types/PoolId.sol\";\nimport {PoolRewards, REWARD_GROWTH_SIZE} from \"../types/PoolRewards.sol\";\nimport {CalldataReader} from \"../types/CalldataReader.sol\";\nimport {IPoolManager, IUniV4} from \"../interfaces/IUniV4.sol\";\nimport {UniConsumer} from \"./UniConsumer.sol\";\n\nimport {TickLib} from \"../libraries/TickLib.sol\";\nimport {MixedSignLib} from \"../libraries/MixedSignLib.sol\";\nimport {X128MathLib} from \"../libraries/X128MathLib.sol\";\n\n/// @author philogy <https://github.com/philogy>\n/// @dev Core logic responsible for updating reward accumulators to distribute rewards.\nabstract contract GrowthOutsideUpdater is UniConsumer {\n    using IUniV4 for IPoolManager;\n    using TickLib for uint256;\n\n    error WrongEndLiquidity(uint128 endLiquidity, uint128 actualCurrentLiquidity);\n    error JustInTimeLiquidityChange();\n\n    // Stack too deep shenanigan.\n    struct RewardParams {\n        PoolId id;\n        int24 tickSpacing;\n        int24 currentTick;\n        uint256 rewardChecksum;\n    }\n\n    function _decodeAndReward(\n        bool currentOnly,\n        CalldataReader reader,\n        PoolRewards storage poolRewards_,\n        PoolId id,\n        int24 tickSpacing,\n        int24 currentTick\n    ) internal returns (CalldataReader, uint256) {\n        if (currentOnly) {\n            uint128 amount;\n            (reader, amount) = reader.readU128();\n            uint128 expectedLiquidity;\n            (reader, expectedLiquidity) = reader.readU128();\n            // we sometimes have to do empty updates for swap encoding\n            // purposes\n            if (amount == 0 || expectedLiquidity == 0) {\n                return (reader, amount);\n            }\n\n            uint128 pooLiquidity = UNI_V4.getPoolLiquidity(id);\n            if (expectedLiquidity != pooLiquidity) {\n                // console.log(\"expectedLiquidity != pooLiquidity\");\n                revert JustInTimeLiquidityChange();\n            }\n            unchecked {\n                poolRewards_.globalGrowth += X128MathLib.flatDivX128(amount, pooLiquidity);\n            }\n\n            return (reader, amount);\n        }\n\n        uint256 cumulativeGrowth;\n        uint128 endLiquidity;\n\n        int24 startTick;\n        (reader, startTick) = reader.readI24();\n        uint128 liquidity;\n        // start liq\n        (reader, liquidity) = reader.readU128();\n        (CalldataReader newReader, CalldataReader amountsEnd) = reader.readU24End();\n\n        // Stack too deep shenanigan.\n        PoolRewards storage poolRewards = poolRewards_;\n\n        uint256 total;\n        RewardParams memory pool = RewardParams(id, tickSpacing, currentTick, 0);\n        (newReader, total, cumulativeGrowth, endLiquidity) = startTick <= pool.currentTick\n            ? _rewardBelow(poolRewards.rewardGrowthOutside, startTick, newReader, liquidity, pool)\n            : _rewardAbove(poolRewards.rewardGrowthOutside, startTick, newReader, liquidity, pool);\n\n        uint128 donateToCurrent;\n        (newReader, donateToCurrent) = newReader.readU128();\n        unchecked {\n            cumulativeGrowth += X128MathLib.flatDivX128(donateToCurrent, endLiquidity);\n        }\n        total += donateToCurrent;\n\n        newReader.requireAtEndOf(amountsEnd);\n\n        uint128 currentLiquidity = UNI_V4.getPoolLiquidity(pool.id);\n        if (endLiquidity != currentLiquidity) {\n            revert WrongEndLiquidity(endLiquidity, currentLiquidity);\n        }\n\n        {\n            uint160 expectedRewardChecksum;\n            (newReader, expectedRewardChecksum) = newReader.readU160();\n            if (expectedRewardChecksum != pool.rewardChecksum >> 96) {\n                // console.log(\"expectedRewardChecksum != pool.rewardChecksum >> 96\");\n                revert JustInTimeLiquidityChange();\n            }\n        }\n\n        unchecked {\n            poolRewards.globalGrowth += cumulativeGrowth;\n        }\n\n        return (newReader, total);\n    }\n\n    function _rewardBelow(\n        uint256[REWARD_GROWTH_SIZE] storage rewardGrowthOutside,\n        int24 rewardTick,\n        CalldataReader reader,\n        uint128 liquidity,\n        RewardParams memory pool\n    ) internal returns (CalldataReader, uint256, uint256, uint128) {\n        bool initialized = true;\n        uint256 total = 0;\n        uint256 cumulativeGrowth = 0;\n        uint256 rewardChecksum = 0;\n\n        do {\n            if (initialized) {\n                uint128 amount;\n                (reader, amount) = reader.readU128();\n\n                total += amount;\n                unchecked {\n                    cumulativeGrowth += X128MathLib.flatDivX128(amount, liquidity);\n                    rewardGrowthOutside[uint24(rewardTick)] += cumulativeGrowth;\n                }\n\n                (, int128 netLiquidity) = UNI_V4.getTickLiquidity(pool.id, rewardTick);\n                liquidity = MixedSignLib.add(liquidity, netLiquidity);\n\n                // console.log(\"below\", uint256(int256(rewardTick)), uint256(liquidity));\n                assembly (\"memory-safe\") {\n                    mstore(0x13, rewardTick)\n                    mstore(0x10, liquidity)\n                    mstore(0x00, rewardChecksum)\n                    rewardChecksum := keccak256(0x00, 0x33)\n                }\n            }\n            (initialized, rewardTick) = UNI_V4.getNextTickGt(pool.id, rewardTick, pool.tickSpacing);\n        } while (rewardTick <= pool.currentTick);\n\n        pool.rewardChecksum = rewardChecksum;\n\n        return (reader, total, cumulativeGrowth, liquidity);\n    }\n\n    function _rewardAbove(\n        uint256[REWARD_GROWTH_SIZE] storage rewardGrowthOutside,\n        int24 rewardTick,\n        CalldataReader reader,\n        uint128 liquidity,\n        RewardParams memory pool\n    ) internal returns (CalldataReader, uint256, uint256, uint128) {\n        bool initialized = true;\n        uint256 total = 0;\n        uint256 cumulativeGrowth = 0;\n        uint256 rewardChecksum = 0;\n\n        do {\n            if (initialized) {\n                uint128 amount;\n                (reader, amount) = reader.readU128();\n\n                total += amount;\n                unchecked {\n                    cumulativeGrowth += X128MathLib.flatDivX128(amount, liquidity);\n                    rewardGrowthOutside[uint24(rewardTick)] += cumulativeGrowth;\n                }\n\n                (, int128 netLiquidity) = UNI_V4.getTickLiquidity(pool.id, rewardTick);\n                liquidity = MixedSignLib.sub(liquidity, netLiquidity);\n\n                // console.log(\"above\", uint256(int256(rewardTick)), uint256(liquidity));\n                assembly (\"memory-safe\") {\n                    mstore(0x13, rewardTick)\n                    mstore(0x10, liquidity)\n                    mstore(0x00, rewardChecksum)\n                    rewardChecksum := keccak256(0x00, 0x33)\n                }\n            }\n            (initialized, rewardTick) = UNI_V4.getNextTickLt(pool.id, rewardTick, pool.tickSpacing);\n        } while (rewardTick > pool.currentTick);\n\n        pool.rewardChecksum = rewardChecksum;\n\n        return (reader, total, cumulativeGrowth, liquidity);\n    }\n}\n"},"src/interfaces/IHooks.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// Modified from v4-core's IHooks interface.\n\nimport {PoolKey} from \"v4-core/src/types/PoolKey.sol\";\nimport {BalanceDelta} from \"v4-core/src/types/BalanceDelta.sol\";\nimport {IPoolManager} from \"v4-core/src/interfaces/IPoolManager.sol\";\nimport {BeforeSwapDelta} from \"v4-core/src/types/BeforeSwapDelta.sol\";\n\n// Same ABI as `PoolKey` just no custom types to make it easier to handle.\nstruct SimplePoolKey {\n    address asset0;\n    address asset1;\n    uint24 fee;\n    int24 tickSpacing;\n    address hooks;\n}\n\ninterface IBeforeInitializeHook {\n    /// @notice The hook called before the state of a pool is initialized\n    /// @param sender The initial msg.sender for the initialize call\n    /// @param key The key for the pool being initialized\n    /// @param sqrtPriceX96 The sqrt(price) of the pool as a Q64.96\n    /// @return bytes4 The function selector for the hook\n    function beforeInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96)\n        external\n        returns (bytes4);\n}\n\ninterface IAfterInitializeHook {\n    /// @notice The hook called after the state of a pool is initialized\n    /// @param sender The initial msg.sender for the initialize call\n    /// @param key The key for the pool being initialized\n    /// @param sqrtPriceX96 The sqrt(price) of the pool as a Q64.96\n    /// @param tick The current tick after the state of a pool is initialized\n    /// @return bytes4 The function selector for the hook\n    function afterInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96, int24 tick)\n        external\n        returns (bytes4);\n}\n\ninterface IBeforeAddLiquidityHook {\n    /// @notice The hook called before liquidity is added\n    /// @param sender The initial msg.sender for the add liquidity call\n    /// @param key The key for the pool\n    /// @param params The parameters for adding liquidity\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidity provider to be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function beforeAddLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        bytes calldata hookData\n    ) external returns (bytes4);\n}\n\ninterface IAfterAddLiquidityHook {\n    /// @notice The hook called after liquidity is added\n    /// @param sender The initial msg.sender for the add liquidity call\n    /// @param key The key for the pool\n    /// @param params The parameters for adding liquidity\n    /// @param delta The caller's balance delta after adding liquidity\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidity provider to be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    /// @return BalanceDelta The hook's delta in token0 and token1. Positive: the hook is owed/took currency, negative: the hook owes/sent currency\n    function afterAddLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        BalanceDelta delta,\n        bytes calldata hookData\n    ) external returns (bytes4, BalanceDelta);\n}\n\ninterface IBeforeRemoveLiquidityHook {\n    /// @notice The hook called before liquidity is removed\n    /// @param sender The initial msg.sender for the remove liquidity call\n    /// @param key The key for the pool\n    /// @param params The parameters for removing liquidity\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidity provider to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function beforeRemoveLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        bytes calldata hookData\n    ) external returns (bytes4);\n}\n\ninterface IAfterRemoveLiquidityHook {\n    /// @notice The hook called after liquidity is removed\n    /// @param sender The initial msg.sender for the remove liquidity call\n    /// @param key The key for the pool\n    /// @param params The parameters for removing liquidity\n    /// @param delta The caller's balance delta after removing liquidity\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidity provider to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    /// @return BalanceDelta The hook's delta in token0 and token1. Positive: the hook is owed/took currency, negative: the hook owes/sent currency\n    function afterRemoveLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        BalanceDelta delta,\n        bytes calldata hookData\n    ) external returns (bytes4, BalanceDelta);\n}\n\ninterface IBeforeSwapHook {\n    /// @notice The hook called before a swap\n    /// @param sender The initial msg.sender for the swap call\n    /// @param key The key for the pool\n    /// @param params The parameters for the swap\n    /// @param hookData Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    /// @return BeforeSwapDelta The hook's delta in specified and unspecified currencies. Positive: the hook is owed/took currency, negative: the hook owes/sent currency\n    /// @return uint24 Optionally override the lp fee, only used if three conditions are met: 1. the Pool has a dynamic fee, 2. the value's 2nd highest bit is set (23rd bit, 0x400000), and 3. the value is less than or equal to the maximum fee (1 million)\n    function beforeSwap(\n        address sender,\n        SimplePoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        bytes calldata hookData\n    ) external returns (bytes4, BeforeSwapDelta, uint24);\n}\n\ninterface IAfterSwapHook {\n    /// @notice The hook called after a swap\n    /// @param sender The initial msg.sender for the swap call\n    /// @param key The key for the pool\n    /// @param params The parameters for the swap\n    /// @param delta The amount owed to the caller (positive) or owed to the pool (negative)\n    /// @param hookData Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    /// @return int128 The hook's delta in unspecified currency. Positive: the hook is owed/took currency, negative: the hook owes/sent currency\n    function afterSwap(\n        address sender,\n        SimplePoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        BalanceDelta delta,\n        bytes calldata hookData\n    ) external returns (bytes4, int128);\n}\n\ninterface IBeforeDonateHook {\n    /// @notice The hook called before donate\n    /// @param sender The initial msg.sender for the donate call\n    /// @param key The key for the pool\n    /// @param amount0 The amount of token0 being donated\n    /// @param amount1 The amount of token1 being donated\n    /// @param hookData Arbitrary data handed into the PoolManager by the donor to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function beforeDonate(\n        address sender,\n        PoolKey calldata key,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata hookData\n    ) external returns (bytes4);\n}\n\ninterface IAfterDonateHook {\n    /// @notice The hook called after donate\n    /// @param sender The initial msg.sender for the donate call\n    /// @param key The key for the pool\n    /// @param amount0 The amount of token0 being donated\n    /// @param amount1 The amount of token1 being donated\n    /// @param hookData Arbitrary data handed into the PoolManager by the donor to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function afterDonate(\n        address sender,\n        PoolKey calldata key,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata hookData\n    ) external returns (bytes4);\n}\n"},"src/types/PoolRewards.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {IPoolManager} from \"v4-core/src/interfaces/IPoolManager.sol\";\nimport {PoolId} from \"v4-core/src/types/PoolId.sol\";\nimport {IUniV4} from \"../interfaces/IUniV4.sol\";\nimport {TickLib} from \"../libraries/TickLib.sol\";\n\n/// @dev Should accommodate all possible tick values.\nuint256 constant REWARD_GROWTH_SIZE = 16777216;\n\nstruct PoolRewards {\n    uint256[REWARD_GROWTH_SIZE] rewardGrowthOutside;\n    uint256 globalGrowth;\n}\n\nusing PoolRewardsLib for PoolRewards global;\n\n/// @author philogy <https://github.com/philogy>\n/// @dev Computes and maintains global LP rewards.\nlibrary PoolRewardsLib {\n    using IUniV4 for IPoolManager;\n    using TickLib for uint256;\n    using TickLib for int24;\n\n    function getGrowthInside(PoolRewards storage self, int24 current, int24 lower, int24 upper)\n        internal\n        view\n        returns (uint256 growthInside)\n    {\n        unchecked {\n            uint256 lowerGrowth = self.rewardGrowthOutside[uint24(lower)];\n            uint256 upperGrowth = self.rewardGrowthOutside[uint24(upper)];\n\n            if (current < lower) {\n                return lowerGrowth - upperGrowth;\n            }\n            if (upper <= current) {\n                return upperGrowth - lowerGrowth;\n            }\n            return self.globalGrowth - lowerGrowth - upperGrowth;\n        }\n    }\n\n    /// @dev Update growth values for a valid tick move from `prevTick` to `newTick`. Expects\n    /// `prevTick` and `newTick` to be valid Uniswap ticks (defined as tick ∈ [TickMath.MIN_TICK;\n    /// TickMath.MAX_TICK]).\n    function updateAfterTickMove(\n        PoolRewards storage self,\n        PoolId id,\n        IPoolManager uniV4,\n        int24 prevTick,\n        int24 newTick,\n        int24 tickSpacing\n    ) internal {\n        if (newTick > prevTick) {\n            // We assume the ticks are valid so no risk of underflow with these calls.\n            if (newTick.normalizeUnchecked(tickSpacing) > prevTick) {\n                _updateTickMoveUp(self, uniV4, id, prevTick, newTick, tickSpacing);\n            }\n        } else if (newTick < prevTick) {\n            // We assume the ticks are valid so no risk of underflow with these calls.\n            if (newTick < prevTick.normalizeUnchecked(tickSpacing)) {\n                _updateTickMoveDown(self, uniV4, id, prevTick, newTick, tickSpacing);\n            }\n        }\n    }\n\n    function _updateTickMoveUp(\n        PoolRewards storage self,\n        IPoolManager uniV4,\n        PoolId id,\n        int24 tick,\n        int24 newTick,\n        int24 tickSpacing\n    ) private {\n        while (true) {\n            bool initialized;\n            (initialized, tick) = uniV4.getNextTickGt(id, tick, tickSpacing);\n\n            if (newTick < tick) break;\n            if (initialized) {\n                unchecked {\n                    self.rewardGrowthOutside[uint24(tick)] =\n                        self.globalGrowth - self.rewardGrowthOutside[uint24(tick)];\n                }\n            }\n        }\n    }\n\n    function _updateTickMoveDown(\n        PoolRewards storage self,\n        IPoolManager uniV4,\n        PoolId id,\n        int24 tick,\n        int24 newTick,\n        int24 tickSpacing\n    ) private {\n        while (true) {\n            bool initialized;\n            (initialized, tick) = uniV4.getNextTickLe(id, tick, tickSpacing);\n\n            if (tick <= newTick) break;\n\n            if (initialized) {\n                unchecked {\n                    self.rewardGrowthOutside[uint24(tick)] =\n                        self.globalGrowth - self.rewardGrowthOutside[uint24(tick)];\n                }\n            }\n            tick--;\n        }\n    }\n}\n"},"src/types/Positions.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.13;\n\nimport {PoolId} from \"v4-core/src/types/PoolId.sol\";\n\nstruct Positions {\n    mapping(PoolId id => mapping(bytes32 uniPositionKey => Position)) positions;\n}\n\nstruct Position {\n    uint256 lastGrowthInside;\n}\n\nusing PositionsLib for Positions global;\n\n/// @author philogy <https://github.com/philogy>\nlibrary PositionsLib {\n    function get(\n        Positions storage self,\n        PoolId id,\n        address owner,\n        int24 lowerTick,\n        int24 upperTick,\n        bytes32 salt\n    ) internal view returns (Position storage position, bytes32 positionKey) {\n        assembly (\"memory-safe\") {\n            // Compute `positionKey` as `keccak256(abi.encodePacked(owner, lowerTick, upperTick, salt))`.\n            // Less efficient than alternative ordering *but* lets us reuse as Uniswap position key.\n            mstore(0x06, upperTick)\n            mstore(0x03, lowerTick)\n            mstore(0x00, owner)\n            // WARN: Free memory pointer temporarily invalid from here on.\n            mstore(0x26, salt)\n            positionKey := keccak256(12, add(add(3, 3), add(20, 32)))\n            // Upper bytes of free memory pointer cleared.\n            mstore(0x26, 0)\n        }\n        position = self.positions[id][positionKey];\n    }\n}\n"},"src/types/SwapCall.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IPoolManager} from \"v4-core/src/interfaces/IPoolManager.sol\";\nimport {PoolId} from \"v4-core/src/types/PoolId.sol\";\nimport {ANGSTROM_INIT_HOOK_FEE} from \"../modules/UniConsumer.sol\";\nimport {BalanceDelta, BalanceDeltaLibrary} from \"v4-core/src/types/BalanceDelta.sol\";\n\n// forgefmt: disable-next-item\nstruct SwapCall {\n    uint256 leftPaddedSelector;\n    /* 0x000 */ address asset0;\n    /* 0x020 */ address asset1;\n    /* 0x040 */ uint24 fee;\n    /* 0x060 */ int24 tickSpacing;\n    /* 0x080 */ address hook;\n    /* 0x0a0 */ bool zeroForOne;\n    /* 0x0c0 */ int256 amountSpecified;\n    /* 0x0e0 */ uint160 sqrtPriceLimitX96;\n    /* 0x100 */ uint256 hookDataRelativeOffset;\n    /* 0x120 */ uint256 hookDataLength;\n}\n\nusing SwapCallLib for SwapCall global;\n\n/// @author philogy <https://github.com/philogy>\n/// @dev Maintains a partially encoded swap call such that it doesn't have to be re-allocated and\n/// set for every swap.\nlibrary SwapCallLib {\n    error SwapFailed();\n\n    /// @dev Uniswap's `MIN_SQRT_RATIO + 1` to pass the limit check.\n    uint160 internal constant MIN_SQRT_RATIO = 4295128740;\n    /// @dev Uniswap's `MAX_SQRT_RATIO - 1` to pass the limit check.\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970341;\n\n    uint256 internal constant HOOK_DATA_CD_REL_OFFSET = 0x120;\n    uint256 internal constant CALL_PAYLOAD_START_OFFSET = 28;\n    uint256 internal constant CALL_PAYLOAD_CD_BYTES = 0x144;\n    uint256 internal constant POOL_KEY_OFFSET = 0x20;\n    uint256 internal constant POOL_KEY_SIZE = 0xa0;\n\n    function newSwapCall(address hook) internal pure returns (SwapCall memory swapCall) {\n        swapCall.leftPaddedSelector = uint256(uint32(IPoolManager.swap.selector));\n        swapCall.fee = ANGSTROM_INIT_HOOK_FEE;\n        swapCall.hook = hook;\n        swapCall.hookDataRelativeOffset = HOOK_DATA_CD_REL_OFFSET;\n    }\n\n    function setZeroForOne(SwapCall memory self, bool zeroForOne) internal pure {\n        self.zeroForOne = zeroForOne;\n        self.sqrtPriceLimitX96 = zeroForOne ? MIN_SQRT_RATIO : MAX_SQRT_RATIO;\n    }\n\n    function getId(SwapCall memory self) internal pure returns (PoolId id) {\n        assembly (\"memory-safe\") {\n            id := keccak256(add(self, POOL_KEY_OFFSET), POOL_KEY_SIZE)\n        }\n    }\n\n    function call(SwapCall memory self, IPoolManager uni) internal {\n        assembly (\"memory-safe\") {\n            let success :=\n                call(gas(), uni, 0, add(self, CALL_PAYLOAD_START_OFFSET), CALL_PAYLOAD_CD_BYTES, 0, 0)\n            if iszero(success) {\n                let free := mload(0x40)\n                returndatacopy(free, 0, returndatasize())\n                revert(free, returndatasize())\n            }\n        }\n    }\n}\n"},"src/types/PoolUpdateVariantMap.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\ntype PoolUpdateVariantMap is uint8;\n\nusing PoolUpdateVariantMapLib for PoolUpdateVariantMap global;\n\n/// @author philogy <https://github.com/philogy>\nlibrary PoolUpdateVariantMapLib {\n    uint256 internal constant ZERO_FOR_ONE_FLAG = 0x01;\n    uint256 internal constant CURRENT_ONLY_FLAG = 0x02;\n\n    function zeroForOne(PoolUpdateVariantMap self) internal pure returns (bool) {\n        return PoolUpdateVariantMap.unwrap(self) & ZERO_FOR_ONE_FLAG != 0;\n    }\n\n    function currentOnly(PoolUpdateVariantMap self) internal pure returns (bool) {\n        return PoolUpdateVariantMap.unwrap(self) & CURRENT_ONLY_FLAG != 0;\n    }\n}\n"},"lib/super-sol/src/libraries/SignedUnsignedLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @author philogy <https://github.com/philogy>\nlibrary SignedUnsignedLib {\n    error Overflow();\n    error Underflow();\n\n    function signed(uint256 x) internal pure returns (int256) {\n        if (x > uint256(type(int256).max)) revert Overflow();\n        return int256(x);\n    }\n\n    function neg(uint256 x) internal pure returns (int256) {\n        if (x > (1 << 255)) revert Overflow();\n        unchecked {\n            return int256(0 - x);\n        }\n    }\n\n    function unsigned(int256 x) internal pure returns (uint256) {\n        if (x < 0) revert Underflow();\n        return uint256(x);\n    }\n\n    function neg(int256 x) internal pure returns (uint256) {\n        if (x > 0) revert Underflow();\n        unchecked {\n            return uint256(-x);\n        }\n    }\n}\n"},"src/interfaces/IUniV4.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {IPoolManager} from \"v4-core/src/interfaces/IPoolManager.sol\";\nimport {Slot0} from \"v4-core/src/types/Slot0.sol\";\nimport {PoolId} from \"v4-core/src/types/PoolId.sol\";\nimport {TickLib} from \"../libraries/TickLib.sol\";\n\n/// @dev Library/Interface that wraps Uniswap V4's `extsload` to add view calls. NOTE: While\n/// technically a library, it behaves like an interface which is why it's here, under `/interfaces`.\nlibrary IUniV4 {\n    using IUniV4 for IPoolManager;\n    using TickLib for uint256;\n\n    error ExtsloadFailed();\n\n    /// @dev Selector of `IPoolManager.extsload`.\n    uint256 internal constant EXTSLOAD_SELECTOR = 0x1e2eaeaf;\n\n    uint256 private constant _OWNER_SLOT = 0;\n    uint256 private constant _PROTOCOL_FEES_SLOT = 1;\n    uint256 private constant _PROTOCOL_FEE_CONTROLLER_SLOT = 2;\n    uint256 private constant _IS_OPERATOR_SLOT = 3;\n    uint256 private constant _BALANCE_OF_SLOT = 4;\n    uint256 private constant _ALLOWANCE_SLOT = 5;\n    uint256 private constant _POOLS_SLOT = 6;\n\n    uint256 private constant _POOL_STATE_SLOT0_OFFSET = 0;\n    uint256 private constant _POOL_STATE_FEE0_OFFSET = 1;\n    uint256 private constant _POOL_STATE_FEE1_OFFSET = 2;\n    uint256 private constant _POOL_STATE_LIQUIDITY_OFFSET = 3;\n    uint256 private constant _POOL_STATE_TICKS_OFFSET = 4;\n    uint256 private constant _POOL_STATE_BITMAP_OFFSET = 5;\n    uint256 private constant _POOL_STATE_POSITIONS_OFFSET = 6;\n\n    uint256 private constant _POSITION_LIQUIDITY_OFFSET = 0;\n    uint256 private constant _POSITION_FEE_GROWTH_OUTSIDE0_OFFSET = 1;\n    uint256 private constant _POSITION_FEE_GROWTH_OUTSIDE1_OFFSET = 2;\n\n    function gudExtsload(IPoolManager self, uint256 slot)\n        internal\n        view\n        returns (uint256 rawValue)\n    {\n        assembly (\"memory-safe\") {\n            mstore(0x20, slot)\n            mstore(0x00, EXTSLOAD_SELECTOR)\n            if iszero(staticcall(gas(), self, 0x1c, 0x24, 0x00, 0x20)) {\n                mstore(0x00, 0x535cf94b /* ExtsloadFailed() */ )\n                revert(0x1c, 0x04)\n            }\n            rawValue := mload(0x00)\n        }\n    }\n\n    function computePoolStateSlot(IPoolManager, PoolId id) internal pure returns (uint256 slot) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, id)\n            mstore(0x20, _POOLS_SLOT)\n            slot := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev WARNING: use of this method with a dirty `int16` for `wordPos` may be vulnerable as the\n     * value is taken as is and used in assembly. If not sign extended will result in useless slots.\n     */\n    function computeBitmapWordSlot(IPoolManager, PoolId id, int16 wordPos)\n        internal\n        pure\n        returns (uint256 slot)\n    {\n        assembly (\"memory-safe\") {\n            // Pool state slot.\n            mstore(0x00, id)\n            mstore(0x20, _POOLS_SLOT)\n            slot := keccak256(0x00, 0x40)\n            // Compute relative map slot (Note: assumes `wordPos` is sanitized i.e. sign extended).\n            mstore(0x00, wordPos)\n            mstore(0x20, add(slot, _POOL_STATE_BITMAP_OFFSET))\n            slot := keccak256(0x00, 0x40)\n        }\n    }\n\n    function getSlot0(IPoolManager self, PoolId id) internal view returns (Slot0) {\n        uint256 slot = self.computePoolStateSlot(id);\n        return Slot0.wrap(bytes32(self.gudExtsload(slot)));\n    }\n\n    /**\n     * @dev WARNING: use of this method with a dirty `int16` for `wordPos` may be vulnerable as the\n     * value is taken as is and used in assembly. If not sign extended will result in useless slots.\n     */\n    function getPoolBitmapInfo(IPoolManager self, PoolId id, int16 wordPos)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 slot = self.computeBitmapWordSlot(id, wordPos);\n        return self.gudExtsload(slot);\n    }\n\n    /**\n     * @dev WARNING: Calling this method without first sanitizing `tick` (to ensure it's sign\n     * extended) is unsafe.\n     */\n    function getTickLiquidity(IPoolManager self, PoolId id, int24 tick)\n        internal\n        view\n        returns (uint128 liquidityGross, int128 liquidityNet)\n    {\n        assembly (\"memory-safe\") {\n            // Pool state slot derivation.\n            mstore(0x20, _POOLS_SLOT)\n            mstore(0x00, id)\n            // Compute relative map slot (WARNING: assumes `tick` is sanitized i.e. sign extended).\n            mstore(0x20, add(keccak256(0x00, 0x40), _POOL_STATE_TICKS_OFFSET))\n            mstore(0x00, tick)\n            // Encode calldata.\n            mstore(0x20, keccak256(0x00, 0x40))\n            mstore(0x00, EXTSLOAD_SELECTOR)\n            if iszero(staticcall(gas(), self, 0x1c, 0x24, 0x00, 0x20)) {\n                mstore(0x00, 0x535cf94b /* ExtsloadFailed() */ )\n                revert(0x1c, 0x04)\n            }\n            let packed := mload(0x00)\n            liquidityGross := and(packed, 0xffffffffffffffffffffffffffffffff)\n            liquidityNet := sar(128, packed)\n        }\n    }\n\n    function getPositionLiquidity(IPoolManager self, PoolId id, bytes32 positionKey)\n        internal\n        view\n        returns (uint128 liquidity)\n    {\n        assembly (\"memory-safe\") {\n            // Pool state slot.\n            mstore(0x20, _POOLS_SLOT)\n            mstore(0x00, id)\n            // Position state slot.\n            mstore(0x20, add(keccak256(0x00, 0x40), _POOL_STATE_POSITIONS_OFFSET))\n            mstore(0x00, positionKey)\n            // Inlined gudExtsload.\n            mstore(0x20, keccak256(0x00, 0x40))\n            mstore(0x00, EXTSLOAD_SELECTOR)\n            if iszero(staticcall(gas(), self, 0x1c, 0x24, 0x00, 0x20)) {\n                mstore(0x00, 0x535cf94b /* ExtsloadFailed() */ )\n                revert(0x1c, 0x04)\n            }\n            liquidity := and(0xffffffffffffffffffffffffffffffff, mload(0x00))\n        }\n    }\n\n    function getPoolLiquidity(IPoolManager self, PoolId id) internal view returns (uint128) {\n        uint256 slot = self.computePoolStateSlot(id);\n        unchecked {\n            uint256 rawLiquidity = self.gudExtsload(slot + _POOL_STATE_LIQUIDITY_OFFSET);\n            return uint128(rawLiquidity);\n        }\n    }\n\n    /// @dev WARNING: Expects `owner` & `asset` to not have dirty bytes.\n    function getDelta(IPoolManager self, address owner, address asset)\n        internal\n        view\n        returns (int256 delta)\n    {\n        bytes32 tslot;\n        assembly (\"memory-safe\") {\n            mstore(0x00, owner)\n            mstore(0x20, asset)\n            tslot := keccak256(0x00, 0x40)\n        }\n        bytes32 value = self.exttload(tslot);\n        delta = int256(uint256(value));\n    }\n\n    function isInitialized(IPoolManager self, PoolId id, int24 tick, int24 tickSpacing)\n        internal\n        view\n        returns (bool initialized)\n    {\n        (int16 wordPos, uint8 bitPos) = TickLib.position(TickLib.compress(tick, tickSpacing));\n        initialized = self.getPoolBitmapInfo(id, wordPos).isInitialized(bitPos);\n    }\n\n    /// @dev Gets the next tick down such that `tick ∉ [nextTick; nextTick + TICK_SPACING)`\n    function getNextTickLt(IPoolManager self, PoolId id, int24 tick, int24 tickSpacing)\n        internal\n        view\n        returns (bool initialized, int24 nextTick)\n    {\n        (int16 wordPos, uint8 bitPos) = TickLib.position(TickLib.compress(tick, tickSpacing) - 1);\n        (initialized, bitPos) = self.getPoolBitmapInfo(id, wordPos).nextBitPosLte(bitPos);\n        nextTick = TickLib.toTick(wordPos, bitPos, tickSpacing);\n    }\n\n    function getNextTickLe(IPoolManager self, PoolId id, int24 tick, int24 tickSpacing)\n        internal\n        view\n        returns (bool initialized, int24 nextTick)\n    {\n        (int16 wordPos, uint8 bitPos) = TickLib.position(TickLib.compress(tick, tickSpacing));\n        (initialized, bitPos) = self.getPoolBitmapInfo(id, wordPos).nextBitPosLte(bitPos);\n        nextTick = TickLib.toTick(wordPos, bitPos, tickSpacing);\n    }\n\n    function getNextTickGt(IPoolManager self, PoolId id, int24 tick, int24 tickSpacing)\n        internal\n        view\n        returns (bool initialized, int24 nextTick)\n    {\n        (int16 wordPos, uint8 bitPos) = TickLib.position(TickLib.compress(tick, tickSpacing) + 1);\n        (initialized, bitPos) = self.getPoolBitmapInfo(id, wordPos).nextBitPosGte(bitPos);\n        nextTick = TickLib.toTick(wordPos, bitPos, tickSpacing);\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/types/PoolId.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {PoolKey} from \"./PoolKey.sol\";\n\ntype PoolId is bytes32;\n\n/// @notice Library for computing the ID of a pool\nlibrary PoolIdLibrary {\n    /// @notice Returns value equal to keccak256(abi.encode(poolKey))\n    function toId(PoolKey memory poolKey) internal pure returns (PoolId poolId) {\n        assembly (\"memory-safe\") {\n            // 0xa0 represents the total size of the poolKey struct (5 slots of 32 bytes)\n            poolId := keccak256(poolKey, 0xa0)\n        }\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/types/Currency.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC20Minimal} from \"../interfaces/external/IERC20Minimal.sol\";\nimport {CustomRevert} from \"../libraries/CustomRevert.sol\";\n\ntype Currency is address;\n\nusing {greaterThan as >, lessThan as <, greaterThanOrEqualTo as >=, equals as ==} for Currency global;\nusing CurrencyLibrary for Currency global;\n\nfunction equals(Currency currency, Currency other) pure returns (bool) {\n    return Currency.unwrap(currency) == Currency.unwrap(other);\n}\n\nfunction greaterThan(Currency currency, Currency other) pure returns (bool) {\n    return Currency.unwrap(currency) > Currency.unwrap(other);\n}\n\nfunction lessThan(Currency currency, Currency other) pure returns (bool) {\n    return Currency.unwrap(currency) < Currency.unwrap(other);\n}\n\nfunction greaterThanOrEqualTo(Currency currency, Currency other) pure returns (bool) {\n    return Currency.unwrap(currency) >= Currency.unwrap(other);\n}\n\n/// @title CurrencyLibrary\n/// @dev This library allows for transferring and holding native tokens and ERC20 tokens\nlibrary CurrencyLibrary {\n    /// @notice Additional context for ERC-7751 wrapped error when a native transfer fails\n    error NativeTransferFailed();\n\n    /// @notice Additional context for ERC-7751 wrapped error when an ERC20 transfer fails\n    error ERC20TransferFailed();\n\n    /// @notice A constant to represent the native currency\n    Currency public constant ADDRESS_ZERO = Currency.wrap(address(0));\n\n    function transfer(Currency currency, address to, uint256 amount) internal {\n        // altered from https://github.com/transmissions11/solmate/blob/44a9963d4c78111f77caa0e65d677b8b46d6f2e6/src/utils/SafeTransferLib.sol\n        // modified custom error selectors\n\n        bool success;\n        if (currency.isAddressZero()) {\n            assembly (\"memory-safe\") {\n                // Transfer the ETH and revert if it fails.\n                success := call(gas(), to, amount, 0, 0, 0, 0)\n            }\n            // revert with NativeTransferFailed, containing the bubbled up error as an argument\n            if (!success) {\n                CustomRevert.bubbleUpAndRevertWith(to, bytes4(0), NativeTransferFailed.selector);\n            }\n        } else {\n            assembly (\"memory-safe\") {\n                // Get a pointer to some free memory.\n                let fmp := mload(0x40)\n\n                // Write the abi-encoded calldata into memory, beginning with the function selector.\n                mstore(fmp, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n                mstore(add(fmp, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n                mstore(add(fmp, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n                success :=\n                    and(\n                        // Set success to whether the call reverted, if not we check it either\n                        // returned exactly 1 (can't just be non-zero data), or had no return data.\n                        or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                        // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                        // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                        // Counterintuitively, this call must be positioned second to the or() call in the\n                        // surrounding and() call or else returndatasize() will be zero during the computation.\n                        call(gas(), currency, 0, fmp, 68, 0, 32)\n                    )\n\n                // Now clean the memory we used\n                mstore(fmp, 0) // 4 byte `selector` and 28 bytes of `to` were stored here\n                mstore(add(fmp, 0x20), 0) // 4 bytes of `to` and 28 bytes of `amount` were stored here\n                mstore(add(fmp, 0x40), 0) // 4 bytes of `amount` were stored here\n            }\n            // revert with ERC20TransferFailed, containing the bubbled up error as an argument\n            if (!success) {\n                CustomRevert.bubbleUpAndRevertWith(\n                    Currency.unwrap(currency), IERC20Minimal.transfer.selector, ERC20TransferFailed.selector\n                );\n            }\n        }\n    }\n\n    function balanceOfSelf(Currency currency) internal view returns (uint256) {\n        if (currency.isAddressZero()) {\n            return address(this).balance;\n        } else {\n            return IERC20Minimal(Currency.unwrap(currency)).balanceOf(address(this));\n        }\n    }\n\n    function balanceOf(Currency currency, address owner) internal view returns (uint256) {\n        if (currency.isAddressZero()) {\n            return owner.balance;\n        } else {\n            return IERC20Minimal(Currency.unwrap(currency)).balanceOf(owner);\n        }\n    }\n\n    function isAddressZero(Currency currency) internal pure returns (bool) {\n        return Currency.unwrap(currency) == Currency.unwrap(ADDRESS_ZERO);\n    }\n\n    function toId(Currency currency) internal pure returns (uint256) {\n        return uint160(Currency.unwrap(currency));\n    }\n\n    // If the upper 12 bytes are non-zero, they will be zero-ed out\n    // Therefore, fromId() and toId() are not inverses of each other\n    function fromId(uint256 id) internal pure returns (Currency) {\n        return Currency.wrap(address(uint160(id)));\n    }\n}\n"},"lib/solady/src/utils/FixedPointMathLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\nlibrary FixedPointMathLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error ExpOverflow();\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error FactorialOverflow();\n\n    /// @dev The operation failed, due to an overflow.\n    error RPowOverflow();\n\n    /// @dev The mantissa is too big to fit.\n    error MantissaOverflow();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error MulWadFailed();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error SMulWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error DivWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error SDivWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error MulDivFailed();\n\n    /// @dev The division failed, as the denominator is zero.\n    error DivFailed();\n\n    /// @dev The full precision multiply-divide operation failed, either due\n    /// to the result being larger than 256 bits, or a division by a zero.\n    error FullMulDivFailed();\n\n    /// @dev The output is undefined, as the input is less-than-or-equal to zero.\n    error LnWadUndefined();\n\n    /// @dev The input outside the acceptable domain.\n    error OutOfDomain();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The scalar of ETH and most ERC20s.\n    uint256 internal constant WAD = 1e18;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              SIMPLIFIED FIXED POINT OPERATIONS             */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if gt(x, div(not(0), y)) {\n                if y {\n                    mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function sMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require((x == 0 || z / x == y) && !(x == -1 && y == type(int256).min))`.\n            if iszero(gt(or(iszero(x), eq(sdiv(z, x), y)), lt(not(x), eq(y, shl(255, 1))))) {\n                mstore(0x00, 0xedcd4dd4) // `SMulWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(z, WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\n    function rawMulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\n    function rawSMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up.\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if iszero(eq(div(z, y), x)) {\n                if y {\n                    mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            z := add(iszero(iszero(mod(z, WAD))), div(z, WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up, but without overflow checks.\n    function rawMulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function divWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && x <= type(uint256).max / WAD)`.\n            if iszero(mul(y, lt(x, add(1, div(not(0), WAD))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function sDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, WAD)\n            // Equivalent to `require(y != 0 && ((x * WAD) / WAD == x))`.\n            if iszero(mul(y, eq(sdiv(z, WAD), x))) {\n                mstore(0x00, 0x5c43740d) // `SDivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(z, y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\n    function rawDivWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\n    function rawSDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up.\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && x <= type(uint256).max / WAD)`.\n            if iszero(mul(y, lt(x, add(1, div(not(0), WAD))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up, but without overflow and divide by zero checks.\n    function rawDivWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `x` to the power of `y`.\n    /// because `x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)`.\n    /// Note: This function is an approximation.\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\n        // Using `ln(x)` means `x` must be greater than 0.\n        return expWad((lnWad(x) * y) / int256(WAD));\n    }\n\n    /// @dev Returns `exp(x)`, denominated in `WAD`.\n    /// Credit to Remco Bloemen under MIT license: https://2π.com/22/exp-ln\n    /// Note: This function is an approximation. Monotonically increasing.\n    function expWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            // When the result is less than 0.5 we return zero.\n            // This happens when `x <= (log(1e-18) * 1e18) ~ -4.15e19`.\n            if (x <= -41446531673892822313) return r;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // When the result is greater than `(2**255 - 1) / 1e18` we can not represent it as\n                // an int. This happens when `x >= floor(log((2**255 - 1) / 1e18) * 1e18) ≈ 135`.\n                if iszero(slt(x, 135305999368893231589)) {\n                    mstore(0x00, 0xa37bfec9) // `ExpOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n\n            // `x` is now in the range `(-42, 136) * 1e18`. Convert to `(-42, 136) * 2**96`\n            // for more intermediate precision and a binary basis. This base conversion\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n            x = (x << 78) / 5 ** 18;\n\n            // Reduce range of x to (-½ ln 2, ½ ln 2) * 2**96 by factoring out powers\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\n            x = x - k * 54916777467707473351141471128;\n\n            // `k` is in the range `[-61, 195]`.\n\n            // Evaluate using a (6, 7)-term rational approximation.\n            // `p` is made monic, we'll multiply by a scale factor later.\n            int256 y = x + 1346386616545796478920950773328;\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\n            int256 p = y + x - 94201549194550492254356042504812;\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n            p = p * x + (4385272521454847904659076985693276 << 96);\n\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n            int256 q = x - 2855989394907223263936484059900;\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\n                // No scaling is necessary because p is already `2**96` too large.\n                r := sdiv(p, q)\n            }\n\n            // r should be in the range `(0.09, 0.25) * 2**96`.\n\n            // We now need to multiply r by:\n            // - The scale factor `s ≈ 6.031367120`.\n            // - The `2**k` factor from the range reduction.\n            // - The `1e18 / 2**96` factor for base conversion.\n            // We do this all at once, with an intermediate result in `2**213`\n            // basis, so the final right shift is always by a positive amount.\n            r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\n        }\n    }\n\n    /// @dev Returns `ln(x)`, denominated in `WAD`.\n    /// Credit to Remco Bloemen under MIT license: https://2π.com/22/exp-ln\n    /// Note: This function is an approximation. Monotonically increasing.\n    function lnWad(int256 x) internal pure returns (int256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We want to convert `x` from `10**18` fixed point to `2**96` fixed point.\n            // We do this by multiplying by `2**96 / 10**18`. But since\n            // `ln(x * C) = ln(x) + ln(C)`, we can simply do nothing here\n            // and add `ln(2**96 / 10**18)` at the end.\n\n            // Compute `k = log2(x) - 96`, `r = 159 - k = 255 - log2(x) = 255 ^ log2(x)`.\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // We place the check here for more optimal stack operations.\n            if iszero(sgt(x, 0)) {\n                mstore(0x00, 0x1615e638) // `LnWadUndefined()`.\n                revert(0x1c, 0x04)\n            }\n            // forgefmt: disable-next-item\n            r := xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff))\n\n            // Reduce range of x to (1, 2) * 2**96\n            // ln(2^k * x) = k * ln(2) + ln(x)\n            x := shr(159, shl(r, x))\n\n            // Evaluate using a (8, 8)-term rational approximation.\n            // `p` is made monic, we will multiply by a scale factor later.\n            // forgefmt: disable-next-item\n            let p := sub( // This heavily nested expression is to avoid stack-too-deep for via-ir.\n                sar(96, mul(add(43456485725739037958740375743393,\n                sar(96, mul(add(24828157081833163892658089445524,\n                sar(96, mul(add(3273285459638523848632254066296,\n                    x), x))), x))), x)), 11111509109440967052023855526967)\n            p := sub(sar(96, mul(p, x)), 45023709667254063763336534515857)\n            p := sub(sar(96, mul(p, x)), 14706773417378608786704636184526)\n            p := sub(mul(p, x), shl(96, 795164235651350426258249787498))\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n\n            // `q` is monic by convention.\n            let q := add(5573035233440673466300451813936, x)\n            q := add(71694874799317883764090561454958, sar(96, mul(x, q)))\n            q := add(283447036172924575727196451306956, sar(96, mul(x, q)))\n            q := add(401686690394027663651624208769553, sar(96, mul(x, q)))\n            q := add(204048457590392012362485061816622, sar(96, mul(x, q)))\n            q := add(31853899698501571402653359427138, sar(96, mul(x, q)))\n            q := add(909429971244387300277376558375, sar(96, mul(x, q)))\n\n            // `p / q` is in the range `(0, 0.125) * 2**96`.\n\n            // Finalization, we need to:\n            // - Multiply by the scale factor `s = 5.549…`.\n            // - Add `ln(2**96 / 10**18)`.\n            // - Add `k * ln(2)`.\n            // - Multiply by `10**18 / 2**96 = 5**18 >> 78`.\n\n            // The q polynomial is known not to have zeros in the domain.\n            // No scaling required because p is already `2**96` too large.\n            p := sdiv(p, q)\n            // Multiply by the scaling factor: `s * 5**18 * 2**96`, base is now `5**18 * 2**192`.\n            p := mul(1677202110996718588342820967067443963516166, p)\n            // Add `ln(2) * k * 5**18 * 2**192`.\n            // forgefmt: disable-next-item\n            p := add(mul(16597577552685614221487285958193947469193820559219878177908093499208371, sub(159, r)), p)\n            // Add `ln(2**96 / 10**18) * 5**18 * 2**192`.\n            p := add(600920179829731861736702779321621459595472258049074101567377883020018308, p)\n            // Base conversion: mul `2**18 / 2**192`.\n            r := sar(174, p)\n        }\n    }\n\n    /// @dev Returns `W_0(x)`, denominated in `WAD`.\n    /// See: https://en.wikipedia.org/wiki/Lambert_W_function\n    /// a.k.a. Product log function. This is an approximation of the principal branch.\n    /// Note: This function is an approximation. Monotonically increasing.\n    function lambertW0Wad(int256 x) internal pure returns (int256 w) {\n        // forgefmt: disable-next-item\n        unchecked {\n            if ((w = x) <= -367879441171442322) revert OutOfDomain(); // `x` less than `-1/e`.\n            (int256 wad, int256 p) = (int256(WAD), x);\n            uint256 c; // Whether we need to avoid catastrophic cancellation.\n            uint256 i = 4; // Number of iterations.\n            if (w <= 0x1ffffffffffff) {\n                if (-0x4000000000000 <= w) {\n                    i = 1; // Inputs near zero only take one step to converge.\n                } else if (w <= -0x3ffffffffffffff) {\n                    i = 32; // Inputs near `-1/e` take very long to converge.\n                }\n            } else if (uint256(w >> 63) == uint256(0)) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // Inline log2 for more performance, since the range is small.\n                    let v := shr(49, w)\n                    let l := shl(3, lt(0xff, v))\n                    l := add(or(l, byte(and(0x1f, shr(shr(l, v), 0x8421084210842108cc6318c6db6d54be)),\n                        0x0706060506020504060203020504030106050205030304010505030400000000)), 49)\n                    w := sdiv(shl(l, 7), byte(sub(l, 31), 0x0303030303030303040506080c13))\n                    c := gt(l, 60)\n                    i := add(2, add(gt(l, 53), c))\n                }\n            } else {\n                int256 ll = lnWad(w = lnWad(w));\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // `w = ln(x) - ln(ln(x)) + b * ln(ln(x)) / ln(x)`.\n                    w := add(sdiv(mul(ll, 1023715080943847266), w), sub(w, ll))\n                    i := add(3, iszero(shr(68, x)))\n                    c := iszero(shr(143, x))\n                }\n                if (c == uint256(0)) {\n                    do { // If `x` is big, use Newton's so that intermediate values won't overflow.\n                        int256 e = expWad(w);\n                        /// @solidity memory-safe-assembly\n                        assembly {\n                            let t := mul(w, div(e, wad))\n                            w := sub(w, sdiv(sub(t, x), div(add(e, t), wad)))\n                        }\n                        if (p <= w) break;\n                        p = w;\n                    } while (--i != uint256(0));\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        w := sub(w, sgt(w, 2))\n                    }\n                    return w;\n                }\n            }\n            do { // Otherwise, use Halley's for faster convergence.\n                int256 e = expWad(w);\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let t := add(w, wad)\n                    let s := sub(mul(w, e), mul(x, wad))\n                    w := sub(w, sdiv(mul(s, wad), sub(mul(e, t), sdiv(mul(add(t, wad), s), add(t, t)))))\n                }\n                if (p <= w) break;\n                p = w;\n            } while (--i != c);\n            /// @solidity memory-safe-assembly\n            assembly {\n                w := sub(w, sgt(w, 2))\n            }\n            // For certain ranges of `x`, we'll use the quadratic-rate recursive formula of\n            // R. Iacono and J.P. Boyd for the last iteration, to avoid catastrophic cancellation.\n            if (c == uint256(0)) return w;\n            int256 t = w | 1;\n            /// @solidity memory-safe-assembly\n            assembly {\n                x := sdiv(mul(x, wad), t)\n            }\n            x = (t * (wad + lnWad(x)));\n            /// @solidity memory-safe-assembly\n            assembly {\n                w := sdiv(x, add(wad, t))\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  GENERAL NUMBER UTILITIES                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `a * b == x * y`, with full precision.\n    function fullMulEq(uint256 a, uint256 b, uint256 x, uint256 y) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(eq(mul(a, b), mul(x, y)), eq(mulmod(x, y, not(0)), mulmod(a, b, not(0))))\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Remco Bloemen under MIT license: https://2π.com/21/muldiv\n    function fullMulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // 512-bit multiply `[p1 p0] = x * y`.\n            // Compute the product mod `2**256` and mod `2**256 - 1`\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that `product = p1 * 2**256 + p0`.\n\n            // Temporarily use `z` as `p0` to save gas.\n            z := mul(x, y) // Lower 256 bits of `x * y`.\n            for {} 1 {} {\n                // If overflows.\n                if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                    let mm := mulmod(x, y, not(0))\n                    let p1 := sub(mm, add(z, lt(mm, z))) // Upper 256 bits of `x * y`.\n\n                    /*------------------- 512 by 256 division --------------------*/\n\n                    // Make division exact by subtracting the remainder from `[p1 p0]`.\n                    let r := mulmod(x, y, d) // Compute remainder using mulmod.\n                    let t := and(d, sub(0, d)) // The least significant bit of `d`. `t >= 1`.\n                    // Make sure `z` is less than `2**256`. Also prevents `d == 0`.\n                    // Placing the check here seems to give more optimal stack operations.\n                    if iszero(gt(d, p1)) {\n                        mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    d := div(d, t) // Divide `d` by `t`, which is a power of two.\n                    // Invert `d mod 2**256`\n                    // Now that `d` is an odd number, it has an inverse\n                    // modulo `2**256` such that `d * inv = 1 mod 2**256`.\n                    // Compute the inverse by starting with a seed that is correct\n                    // correct for four bits. That is, `d * inv = 1 mod 2**4`.\n                    let inv := xor(2, mul(3, d))\n                    // Now use Newton-Raphson iteration to improve the precision.\n                    // Thanks to Hensel's lifting lemma, this also works in modular\n                    // arithmetic, doubling the correct bits in each step.\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**8\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**16\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**32\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**64\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**128\n                    z :=\n                        mul(\n                            // Divide [p1 p0] by the factors of two.\n                            // Shift in bits from `p1` into `p0`. For this we need\n                            // to flip `t` such that it is `2**256 / t`.\n                            or(mul(sub(p1, gt(r, z)), add(div(sub(0, t), t), 1)), div(sub(z, r), t)),\n                            mul(sub(2, mul(d, inv)), inv) // inverse mod 2**256\n                        )\n                    break\n                }\n                z := div(z, d)\n                break\n            }\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision.\n    /// Behavior is undefined if `d` is zero or the final result cannot fit in 256 bits.\n    /// Performs the full 512 bit calculation regardless.\n    function fullMulDivUnchecked(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            let mm := mulmod(x, y, not(0))\n            let p1 := sub(mm, add(z, lt(mm, z)))\n            let t := and(d, sub(0, d))\n            let r := mulmod(x, y, d)\n            d := div(d, t)\n            let inv := xor(2, mul(3, d))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            z :=\n                mul(or(mul(sub(p1, gt(r, z)), add(div(sub(0, t), t), 1)), div(sub(z, r), t)), mul(sub(2, mul(d, inv)), inv))\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision, rounded up.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Uniswap-v3-core under MIT license:\n    /// https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/FullMath.sol\n    function fullMulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        z = fullMulDiv(x, y, d);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mulmod(x, y, d) {\n                z := add(z, 1)\n                if iszero(z) {\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / 2 ** n)` with full precision.\n    /// Throws if result overflows a uint256.\n    /// Credit to Philogy under MIT license:\n    /// https://github.com/SorellaLabs/angstrom/blob/main/contracts/src/libraries/X128MathLib.sol\n    function fullMulDivN(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Temporarily use `z` as `p0` to save gas.\n            z := mul(x, y) // Lower 256 bits of `x * y`. We'll call this `z`.\n            for {} 1 {} {\n                if iszero(or(iszero(x), eq(div(z, x), y))) {\n                    let k := and(n, 0xff) // `n`, cleaned.\n                    let mm := mulmod(x, y, not(0))\n                    let p1 := sub(mm, add(z, lt(mm, z))) // Upper 256 bits of `x * y`.\n                    //         |      p1     |      z     |\n                    // Before: | p1_0 ¦ p1_1 | z_0  ¦ z_1 |\n                    // Final:  |   0  ¦ p1_0 | p1_1 ¦ z_0 |\n                    // Check that final `z` doesn't overflow by checking that p1_0 = 0.\n                    if iszero(shr(k, p1)) {\n                        z := add(shl(sub(256, k), p1), shr(k, z))\n                        break\n                    }\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                z := shr(and(n, 0xff), z)\n                break\n            }\n        }\n    }\n\n    /// @dev Returns `floor(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(d != 0 && (y == 0 || x <= type(uint256).max / y))`.\n            if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(z, d)\n        }\n    }\n\n    /// @dev Returns `ceil(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(d != 0 && (y == 0 || x <= type(uint256).max / y))`.\n            if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(z, d))), div(z, d))\n        }\n    }\n\n    /// @dev Returns `x`, the modular multiplicative inverse of `a`, such that `(a * x) % n == 1`.\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256 x) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let g := n\n            let r := mod(a, n)\n            for { let y := 1 } 1 {} {\n                let q := div(g, r)\n                let t := g\n                g := r\n                r := sub(t, mul(r, q))\n                let u := x\n                x := y\n                y := sub(u, mul(y, q))\n                if iszero(r) { break }\n            }\n            x := mul(eq(g, 1), add(x, mul(slt(x, 0), n)))\n        }\n    }\n\n    /// @dev Returns `ceil(x / d)`.\n    /// Reverts if `d` is zero.\n    function divUp(uint256 x, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(d) {\n                mstore(0x00, 0x65244e4e) // `DivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(x, d))), div(x, d))\n        }\n    }\n\n    /// @dev Returns `max(0, x - y)`.\n    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(gt(x, y), sub(x, y))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, bytes32 x, bytes32 y) internal pure returns (bytes32 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, address x, address y) internal pure returns (address z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Exponentiate `x` to `y` by squaring, denominated in base `b`.\n    /// Reverts if the computation overflows.\n    function rpow(uint256 x, uint256 y, uint256 b) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(b, iszero(y)) // `0 ** 0 = 1`. Otherwise, `0 ** n = 0`.\n            if x {\n                z := xor(b, mul(xor(b, x), and(y, 1))) // `z = isEven(y) ? scale : x`\n                let half := shr(1, b) // Divide `b` by 2.\n                // Divide `y` by 2 every iteration.\n                for { y := shr(1, y) } y { y := shr(1, y) } {\n                    let xx := mul(x, x) // Store x squared.\n                    let xxRound := add(xx, half) // Round to the nearest number.\n                    // Revert if `xx + half` overflowed, or if `x ** 2` overflows.\n                    if or(lt(xxRound, xx), shr(128, x)) {\n                        mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                        revert(0x1c, 0x04)\n                    }\n                    x := div(xxRound, b) // Set `x` to scaled `xxRound`.\n                    // If `y` is odd:\n                    if and(y, 1) {\n                        let zx := mul(z, x) // Compute `z * x`.\n                        let zxRound := add(zx, half) // Round to the nearest number.\n                        // If `z * x` overflowed or `zx + half` overflowed:\n                        if or(xor(div(zx, x), z), lt(zxRound, zx)) {\n                            // Revert if `x` is non-zero.\n                            if x {\n                                mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                                revert(0x1c, 0x04)\n                            }\n                        }\n                        z := div(zxRound, b) // Return properly scaled `zxRound`.\n                    }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns the square root of `x`, rounded down.\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `floor(sqrt(2**15)) = 181`. `sqrt(2**15) - 181 = 2.84`.\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // Let `y = x / 2**r`. We check `y >= 2**(k + 8)`\n            // but shift right by `k` bits to ensure that if `x >= 256`, then `y >= 256`.\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffffff, shr(r, x))))\n            z := shl(shr(1, r), z)\n\n            // Goal was to get `z*z*y` within a small factor of `x`. More iterations could\n            // get y in a tighter range. Currently, we will have y in `[256, 256*(2**16))`.\n            // We ensured `y >= 256` so that the relative difference between `y` and `y+1` is small.\n            // That's not possible if `x < 256` but we can just verify those cases exhaustively.\n\n            // Now, `z*z*y <= x < z*z*(y+1)`, and `y <= 2**(16+8)`, and either `y >= 256`, or `x < 256`.\n            // Correctness can be checked exhaustively for `x < 256`, so we assume `y >= 256`.\n            // Then `z*sqrt(y)` is within `sqrt(257)/sqrt(256)` of `sqrt(x)`, or about 20bps.\n\n            // For `s` in the range `[1/256, 256]`, the estimate `f(s) = (181/1024) * (s+1)`\n            // is in the range `(1/2.84 * sqrt(s), 2.84 * sqrt(s))`,\n            // with largest error when `s = 1` and when `s = 256` or `1/256`.\n\n            // Since `y` is in `[256, 256*(2**16))`, let `a = y/65536`, so that `a` is in `[1/256, 256)`.\n            // Then we can estimate `sqrt(y)` using\n            // `sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2**18`.\n\n            // There is no overflow risk here since `y < 2**136` after the first branch above.\n            z := shr(18, mul(z, add(shr(r, x), 65536))) // A `mul()` is saved from starting `z` at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If `x+1` is a perfect square, the Babylonian method cycles between\n            // `floor(sqrt(x))` and `ceil(sqrt(x))`. This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    /// @dev Returns the cube root of `x`, rounded down.\n    /// Credit to bout3fiddy and pcaversaccio under AGPLv3 license:\n    /// https://github.com/pcaversaccio/snekmate/blob/main/src/utils/Math.vy\n    /// Formally verified by xuwinnie:\n    /// https://github.com/vectorized/solady/blob/main/audits/xuwinnie-solady-cbrt-proof.pdf\n    function cbrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // Makeshift lookup table to nudge the approximate log2 result.\n            z := div(shl(div(r, 3), shl(lt(0xf, shr(r, x)), 0xf)), xor(7, mod(r, 3)))\n            // Newton-Raphson's.\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            // Round down.\n            z := sub(z, lt(div(x, mul(z, z)), z))\n        }\n    }\n\n    /// @dev Returns the square root of `x`, denominated in `WAD`, rounded down.\n    function sqrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            if (x <= type(uint256).max / 10 ** 18) return sqrt(x * 10 ** 18);\n            z = (1 + sqrt(x)) * 10 ** 9;\n            z = (fullMulDivUnchecked(x, 10 ** 18, z) + z) >> 1;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sub(z, gt(999999999999999999, sub(mulmod(z, z, x), 1))) // Round down.\n        }\n    }\n\n    /// @dev Returns the cube root of `x`, denominated in `WAD`, rounded down.\n    /// Formally verified by xuwinnie:\n    /// https://github.com/vectorized/solady/blob/main/audits/xuwinnie-solady-cbrt-proof.pdf\n    function cbrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            if (x <= type(uint256).max / 10 ** 36) return cbrt(x * 10 ** 36);\n            z = (1 + cbrt(x)) * 10 ** 12;\n            z = (fullMulDivUnchecked(x, 10 ** 36, z * z) + z + z) / 3;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let p := x\n            for {} 1 {} {\n                if iszero(shr(229, p)) {\n                    if iszero(shr(199, p)) {\n                        p := mul(p, 100000000000000000) // 10 ** 17.\n                        break\n                    }\n                    p := mul(p, 100000000) // 10 ** 8.\n                    break\n                }\n                if iszero(shr(249, p)) { p := mul(p, 100) }\n                break\n            }\n            let t := mulmod(mul(z, z), z, p)\n            z := sub(z, gt(lt(t, shr(1, p)), iszero(t))) // Round down.\n        }\n    }\n\n    /// @dev Returns the factorial of `x`.\n    function factorial(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := 1\n            if iszero(lt(x, 58)) {\n                mstore(0x00, 0xaba0f2a2) // `FactorialOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            for {} x { x := sub(x, 1) } { z := mul(z, x) }\n        }\n    }\n\n    /// @dev Returns the log2 of `x`.\n    /// Equivalent to computing the index of the most significant bit (MSB) of `x`.\n    /// Returns 0 if `x` is zero.\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0x0706060506020504060203020504030106050205030304010505030400000000))\n        }\n    }\n\n    /// @dev Returns the log2 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log2Up(uint256 x) internal pure returns (uint256 r) {\n        r = log2(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(r, 1), x))\n        }\n    }\n\n    /// @dev Returns the log10 of `x`.\n    /// Returns 0 if `x` is zero.\n    function log10(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(x, 100000000000000000000000000000000000000)) {\n                x := div(x, 100000000000000000000000000000000000000)\n                r := 38\n            }\n            if iszero(lt(x, 100000000000000000000)) {\n                x := div(x, 100000000000000000000)\n                r := add(r, 20)\n            }\n            if iszero(lt(x, 10000000000)) {\n                x := div(x, 10000000000)\n                r := add(r, 10)\n            }\n            if iszero(lt(x, 100000)) {\n                x := div(x, 100000)\n                r := add(r, 5)\n            }\n            r := add(r, add(gt(x, 9), add(gt(x, 99), add(gt(x, 999), gt(x, 9999)))))\n        }\n    }\n\n    /// @dev Returns the log10 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log10Up(uint256 x) internal pure returns (uint256 r) {\n        r = log10(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(exp(10, r), x))\n        }\n    }\n\n    /// @dev Returns the log256 of `x`.\n    /// Returns 0 if `x` is zero.\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(shr(3, r), lt(0xff, shr(r, x)))\n        }\n    }\n\n    /// @dev Returns the log256 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log256Up(uint256 x) internal pure returns (uint256 r) {\n        r = log256(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(shl(3, r), 1), x))\n        }\n    }\n\n    /// @dev Returns the scientific notation format `mantissa * 10 ** exponent` of `x`.\n    /// Useful for compressing prices (e.g. using 25 bit mantissa and 7 bit exponent).\n    function sci(uint256 x) internal pure returns (uint256 mantissa, uint256 exponent) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mantissa := x\n            if mantissa {\n                if iszero(mod(mantissa, 1000000000000000000000000000000000)) {\n                    mantissa := div(mantissa, 1000000000000000000000000000000000)\n                    exponent := 33\n                }\n                if iszero(mod(mantissa, 10000000000000000000)) {\n                    mantissa := div(mantissa, 10000000000000000000)\n                    exponent := add(exponent, 19)\n                }\n                if iszero(mod(mantissa, 1000000000000)) {\n                    mantissa := div(mantissa, 1000000000000)\n                    exponent := add(exponent, 12)\n                }\n                if iszero(mod(mantissa, 1000000)) {\n                    mantissa := div(mantissa, 1000000)\n                    exponent := add(exponent, 6)\n                }\n                if iszero(mod(mantissa, 10000)) {\n                    mantissa := div(mantissa, 10000)\n                    exponent := add(exponent, 4)\n                }\n                if iszero(mod(mantissa, 100)) {\n                    mantissa := div(mantissa, 100)\n                    exponent := add(exponent, 2)\n                }\n                if iszero(mod(mantissa, 10)) {\n                    mantissa := div(mantissa, 10)\n                    exponent := add(exponent, 1)\n                }\n            }\n        }\n    }\n\n    /// @dev Convenience function for packing `x` into a smaller number using `sci`.\n    /// The `mantissa` will be in bits [7..255] (the upper 249 bits).\n    /// The `exponent` will be in bits [0..6] (the lower 7 bits).\n    /// Use `SafeCastLib` to safely ensure that the `packed` number is small\n    /// enough to fit in the desired unsigned integer type:\n    /// ```\n    ///     uint32 packed = SafeCastLib.toUint32(FixedPointMathLib.packSci(777 ether));\n    /// ```\n    function packSci(uint256 x) internal pure returns (uint256 packed) {\n        (x, packed) = sci(x); // Reuse for `mantissa` and `exponent`.\n        /// @solidity memory-safe-assembly\n        assembly {\n            if shr(249, x) {\n                mstore(0x00, 0xce30380c) // `MantissaOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            packed := or(shl(7, x), packed)\n        }\n    }\n\n    /// @dev Convenience function for unpacking a packed number from `packSci`.\n    function unpackSci(uint256 packed) internal pure returns (uint256 unpacked) {\n        unchecked {\n            unpacked = (packed >> 7) * 10 ** (packed & 0x7f);\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`. Rounds towards zero.\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = (x & y) + ((x ^ y) >> 1);\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`. Rounds towards negative infinity.\n    function avg(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = (x >> 1) + (y >> 1) + (x & y & 1);\n        }\n    }\n\n    /// @dev Returns the absolute value of `x`.\n    function abs(int256 x) internal pure returns (uint256 z) {\n        unchecked {\n            z = (uint256(x) + uint256(x >> 255)) ^ uint256(x >> 255);\n        }\n    }\n\n    /// @dev Returns the absolute distance between `x` and `y`.\n    function dist(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(xor(sub(0, gt(x, y)), sub(y, x)), gt(x, y))\n        }\n    }\n\n    /// @dev Returns the absolute distance between `x` and `y`.\n    function dist(int256 x, int256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(xor(sub(0, sgt(x, y)), sub(y, x)), sgt(x, y))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), lt(y, x)))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), slt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), gt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), sgt(y, x)))\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(uint256 x, uint256 minValue, uint256 maxValue) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), gt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), lt(maxValue, z)))\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(int256 x, int256 minValue, int256 maxValue) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), sgt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), slt(maxValue, z)))\n        }\n    }\n\n    /// @dev Returns greatest common divisor of `x` and `y`.\n    function gcd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { z := x } y {} {\n                let t := y\n                y := mod(z, y)\n                z := t\n            }\n        }\n    }\n\n    /// @dev Returns `a + (b - a) * (t - begin) / (end - begin)`,\n    /// with `t` clamped between `begin` and `end` (inclusive).\n    /// Agnostic to the order of (`a`, `b`) and (`end`, `begin`).\n    /// If `begins == end`, returns `t <= begin ? a : b`.\n    function lerp(uint256 a, uint256 b, uint256 t, uint256 begin, uint256 end) internal pure returns (uint256) {\n        if (begin > end) (t, begin, end) = (~t, ~begin, ~end);\n        if (t <= begin) return a;\n        if (t >= end) return b;\n        unchecked {\n            if (b >= a) return a + fullMulDiv(b - a, t - begin, end - begin);\n            return a - fullMulDiv(a - b, t - begin, end - begin);\n        }\n    }\n\n    /// @dev Returns `a + (b - a) * (t - begin) / (end - begin)`.\n    /// with `t` clamped between `begin` and `end` (inclusive).\n    /// Agnostic to the order of (`a`, `b`) and (`end`, `begin`).\n    /// If `begins == end`, returns `t <= begin ? a : b`.\n    function lerp(int256 a, int256 b, int256 t, int256 begin, int256 end) internal pure returns (int256) {\n        if (begin > end) (t, begin, end) = (~t, ~begin, ~end);\n        if (t <= begin) return a;\n        if (t >= end) return b;\n        // forgefmt: disable-next-item\n        unchecked {\n            if (b >= a) return int256(uint256(a) + fullMulDiv(uint256(b - a),\n                uint256(t - begin), uint256(end - begin)));\n            return int256(uint256(a) - fullMulDiv(uint256(a - b),\n                uint256(t - begin), uint256(end - begin)));\n        }\n    }\n\n    /// @dev Returns if `x` is an even number. Some people may need this.\n    function isEven(uint256 x) internal pure returns (bool) {\n        return x & uint256(1) == uint256(0);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   RAW NUMBER OPERATIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(x, y)\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawSDiv(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mod(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawSMod(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := smod(x, y)\n        }\n    }\n\n    /// @dev Returns `(x + y) % d`, return 0 if `d` if zero.\n    function rawAddMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := addmod(x, y, d)\n        }\n    }\n\n    /// @dev Returns `(x * y) % d`, return 0 if `d` if zero.\n    function rawMulMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mulmod(x, y, d)\n        }\n    }\n}\n"},"src/libraries/X128MathLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @author philogy <https://github.com/philogy>\nlibrary X128MathLib {\n    error FullMulX128Failed();\n\n    /// @dev Computes `(numerator * 2**128) / denominator` returning `0` if `denominator = 0`\n    /// instead of reverting.\n    function flatDivX128(uint128 numerator, uint256 denominator)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        assembly (\"memory-safe\") {\n            result := div(shl(128, numerator), denominator)\n        }\n    }\n\n    /// @dev Compute `floor((x * y) / 2**128)` with full precision. Revert if result is larger than / 256 bits.\n    function fullMulX128(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        // Credit to solady under MIT license (https://github.com/Vectorized/solady/blob/7deab021af0426307ae79d091c4d1e26e9e89cf0/src/utils/FixedPointMathLib.sol).\n        assembly (\"memory-safe\") {\n            // Reuse `z` to store lower 256 bits of `x * y`.\n            z := mul(x, y)\n            for {} 1 {} {\n                // We can skip the fancy 512-bit stuff if the 256-bit mul didn't overflow.\n                if iszero(or(iszero(x), eq(div(z, x), y))) {\n                    // Use mathemagic to compute the upper 256 bits of `x * y`.\n                    // Credit to Remco Bloeman under MIT License: https://xn--2-umb.com/17/chinese-remainder-theorem/.\n                    let mm := mulmod(x, y, not(0))\n                    let p1 := sub(mm, add(z, lt(mm, z))) // Upper 256 bits of `x * y`.\n\n                    // We now have the 512-bit numerator (`x * y`) in (p1, z):\n                    // numerator:            |        p1        |       z       |\n                    // In 128-bit chunks:    |  p1_0  ¦   p1_1  |  z_0  ¦  z_1  |\n                    // Right shifted result: |    0   ¦   p1_0  |  p1_1 ¦  z_0  |\n                    // The lower 128 bits of `z` (z_1) are part of the fraction which `floor` discards.\n\n                    // We check the final result doesn't overflow by checking that p1_0 = 0.\n                    if iszero(lt(p1, shl(128, 1))) {\n                        mstore(0x00, 0xc56a0159 /* FullMulX128Failed() */ )\n                        revert(0x1c, 0x04)\n                    }\n\n                    // We now know that our result doesn't overflow.\n                    // Non-overflowing result: |    0   ¦    0    |  p1_1  ¦   z_0   |\n                    // We compute p1_1 and z_0 and slice together.\n                    z := add(shl(128, p1), shr(128, z))\n                    break\n                }\n\n                z := shr(128, z)\n                break\n            }\n        }\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/types/BeforeSwapDelta.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Return type of the beforeSwap hook.\n// Upper 128 bits is the delta in specified tokens. Lower 128 bits is delta in unspecified tokens (to match the afterSwap hook)\ntype BeforeSwapDelta is int256;\n\n// Creates a BeforeSwapDelta from specified and unspecified\nfunction toBeforeSwapDelta(int128 deltaSpecified, int128 deltaUnspecified)\n    pure\n    returns (BeforeSwapDelta beforeSwapDelta)\n{\n    assembly (\"memory-safe\") {\n        beforeSwapDelta := or(shl(128, deltaSpecified), and(sub(shl(128, 1), 1), deltaUnspecified))\n    }\n}\n\n/// @notice Library for getting the specified and unspecified deltas from the BeforeSwapDelta type\nlibrary BeforeSwapDeltaLibrary {\n    /// @notice A BeforeSwapDelta of 0\n    BeforeSwapDelta public constant ZERO_DELTA = BeforeSwapDelta.wrap(0);\n\n    /// extracts int128 from the upper 128 bits of the BeforeSwapDelta\n    /// returned by beforeSwap\n    function getSpecifiedDelta(BeforeSwapDelta delta) internal pure returns (int128 deltaSpecified) {\n        assembly (\"memory-safe\") {\n            deltaSpecified := sar(128, delta)\n        }\n    }\n\n    /// extracts int128 from the lower 128 bits of the BeforeSwapDelta\n    /// returned by beforeSwap and afterSwap\n    function getUnspecifiedDelta(BeforeSwapDelta delta) internal pure returns (int128 deltaUnspecified) {\n        assembly (\"memory-safe\") {\n            deltaUnspecified := signextend(15, delta)\n        }\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/types/BalanceDelta.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {SafeCast} from \"../libraries/SafeCast.sol\";\n\n/// @dev Two `int128` values packed into a single `int256` where the upper 128 bits represent the amount0\n/// and the lower 128 bits represent the amount1.\ntype BalanceDelta is int256;\n\nusing {add as +, sub as -, eq as ==, neq as !=} for BalanceDelta global;\nusing BalanceDeltaLibrary for BalanceDelta global;\nusing SafeCast for int256;\n\nfunction toBalanceDelta(int128 _amount0, int128 _amount1) pure returns (BalanceDelta balanceDelta) {\n    assembly (\"memory-safe\") {\n        balanceDelta := or(shl(128, _amount0), and(sub(shl(128, 1), 1), _amount1))\n    }\n}\n\nfunction add(BalanceDelta a, BalanceDelta b) pure returns (BalanceDelta) {\n    int256 res0;\n    int256 res1;\n    assembly (\"memory-safe\") {\n        let a0 := sar(128, a)\n        let a1 := signextend(15, a)\n        let b0 := sar(128, b)\n        let b1 := signextend(15, b)\n        res0 := add(a0, b0)\n        res1 := add(a1, b1)\n    }\n    return toBalanceDelta(res0.toInt128(), res1.toInt128());\n}\n\nfunction sub(BalanceDelta a, BalanceDelta b) pure returns (BalanceDelta) {\n    int256 res0;\n    int256 res1;\n    assembly (\"memory-safe\") {\n        let a0 := sar(128, a)\n        let a1 := signextend(15, a)\n        let b0 := sar(128, b)\n        let b1 := signextend(15, b)\n        res0 := sub(a0, b0)\n        res1 := sub(a1, b1)\n    }\n    return toBalanceDelta(res0.toInt128(), res1.toInt128());\n}\n\nfunction eq(BalanceDelta a, BalanceDelta b) pure returns (bool) {\n    return BalanceDelta.unwrap(a) == BalanceDelta.unwrap(b);\n}\n\nfunction neq(BalanceDelta a, BalanceDelta b) pure returns (bool) {\n    return BalanceDelta.unwrap(a) != BalanceDelta.unwrap(b);\n}\n\n/// @notice Library for getting the amount0 and amount1 deltas from the BalanceDelta type\nlibrary BalanceDeltaLibrary {\n    /// @notice A BalanceDelta of 0\n    BalanceDelta public constant ZERO_DELTA = BalanceDelta.wrap(0);\n\n    function amount0(BalanceDelta balanceDelta) internal pure returns (int128 _amount0) {\n        assembly (\"memory-safe\") {\n            _amount0 := sar(128, balanceDelta)\n        }\n    }\n\n    function amount1(BalanceDelta balanceDelta) internal pure returns (int128 _amount1) {\n        assembly (\"memory-safe\") {\n            _amount1 := signextend(15, balanceDelta)\n        }\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/interfaces/external/IERC6909Claims.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Interface for claims over a contract balance, wrapped as a ERC6909\ninterface IERC6909Claims {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OperatorSet(address indexed owner, address indexed operator, bool approved);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id, uint256 amount);\n\n    event Transfer(address caller, address indexed from, address indexed to, uint256 indexed id, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                                 FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Owner balance of an id.\n    /// @param owner The address of the owner.\n    /// @param id The id of the token.\n    /// @return amount The balance of the token.\n    function balanceOf(address owner, uint256 id) external view returns (uint256 amount);\n\n    /// @notice Spender allowance of an id.\n    /// @param owner The address of the owner.\n    /// @param spender The address of the spender.\n    /// @param id The id of the token.\n    /// @return amount The allowance of the token.\n    function allowance(address owner, address spender, uint256 id) external view returns (uint256 amount);\n\n    /// @notice Checks if a spender is approved by an owner as an operator\n    /// @param owner The address of the owner.\n    /// @param spender The address of the spender.\n    /// @return approved The approval status.\n    function isOperator(address owner, address spender) external view returns (bool approved);\n\n    /// @notice Transfers an amount of an id from the caller to a receiver.\n    /// @param receiver The address of the receiver.\n    /// @param id The id of the token.\n    /// @param amount The amount of the token.\n    /// @return bool True, always, unless the function reverts\n    function transfer(address receiver, uint256 id, uint256 amount) external returns (bool);\n\n    /// @notice Transfers an amount of an id from a sender to a receiver.\n    /// @param sender The address of the sender.\n    /// @param receiver The address of the receiver.\n    /// @param id The id of the token.\n    /// @param amount The amount of the token.\n    /// @return bool True, always, unless the function reverts\n    function transferFrom(address sender, address receiver, uint256 id, uint256 amount) external returns (bool);\n\n    /// @notice Approves an amount of an id to a spender.\n    /// @param spender The address of the spender.\n    /// @param id The id of the token.\n    /// @param amount The amount of the token.\n    /// @return bool True, always\n    function approve(address spender, uint256 id, uint256 amount) external returns (bool);\n\n    /// @notice Sets or removes an operator for the caller.\n    /// @param operator The address of the operator.\n    /// @param approved The approval status.\n    /// @return bool True, always\n    function setOperator(address operator, bool approved) external returns (bool);\n}\n"},"lib/v4-periphery/lib/v4-core/src/interfaces/IProtocolFees.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Currency} from \"../types/Currency.sol\";\nimport {PoolId} from \"../types/PoolId.sol\";\nimport {PoolKey} from \"../types/PoolKey.sol\";\n\n/// @notice Interface for all protocol-fee related functions in the pool manager\ninterface IProtocolFees {\n    /// @notice Thrown when protocol fee is set too high\n    error ProtocolFeeTooLarge(uint24 fee);\n\n    /// @notice Thrown when collectProtocolFees or setProtocolFee is not called by the controller.\n    error InvalidCaller();\n\n    /// @notice Thrown when collectProtocolFees is attempted on a token that is synced.\n    error ProtocolFeeCurrencySynced();\n\n    /// @notice Emitted when the protocol fee controller address is updated in setProtocolFeeController.\n    event ProtocolFeeControllerUpdated(address indexed protocolFeeController);\n\n    /// @notice Emitted when the protocol fee is updated for a pool.\n    event ProtocolFeeUpdated(PoolId indexed id, uint24 protocolFee);\n\n    /// @notice Given a currency address, returns the protocol fees accrued in that currency\n    /// @param currency The currency to check\n    /// @return amount The amount of protocol fees accrued in the currency\n    function protocolFeesAccrued(Currency currency) external view returns (uint256 amount);\n\n    /// @notice Sets the protocol fee for the given pool\n    /// @param key The key of the pool to set a protocol fee for\n    /// @param newProtocolFee The fee to set\n    function setProtocolFee(PoolKey memory key, uint24 newProtocolFee) external;\n\n    /// @notice Sets the protocol fee controller\n    /// @param controller The new protocol fee controller\n    function setProtocolFeeController(address controller) external;\n\n    /// @notice Collects the protocol fees for a given recipient and currency, returning the amount collected\n    /// @dev This will revert if the contract is unlocked\n    /// @param recipient The address to receive the protocol fees\n    /// @param currency The currency to withdraw\n    /// @param amount The amount of currency to withdraw\n    /// @return amountCollected The amount of currency successfully withdrawn\n    function collectProtocolFees(address recipient, Currency currency, uint256 amount)\n        external\n        returns (uint256 amountCollected);\n\n    /// @notice Returns the current protocol fee controller address\n    /// @return address The current protocol fee controller address\n    function protocolFeeController() external view returns (address);\n}\n"},"lib/v4-periphery/lib/v4-core/src/interfaces/IExtsload.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Interface for functions to access any storage slot in a contract\ninterface IExtsload {\n    /// @notice Called by external contracts to access granular pool state\n    /// @param slot Key of slot to sload\n    /// @return value The value of the slot as bytes32\n    function extsload(bytes32 slot) external view returns (bytes32 value);\n\n    /// @notice Called by external contracts to access granular pool state\n    /// @param startSlot Key of slot to start sloading from\n    /// @param nSlots Number of slots to load into return value\n    /// @return values List of loaded values.\n    function extsload(bytes32 startSlot, uint256 nSlots) external view returns (bytes32[] memory values);\n\n    /// @notice Called by external contracts to access sparse pool state\n    /// @param slots List of slots to SLOAD from.\n    /// @return values List of loaded values.\n    function extsload(bytes32[] calldata slots) external view returns (bytes32[] memory values);\n}\n"},"lib/v4-periphery/lib/v4-core/src/interfaces/IExttload.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/// @notice Interface for functions to access any transient storage slot in a contract\ninterface IExttload {\n    /// @notice Called by external contracts to access transient storage of the contract\n    /// @param slot Key of slot to tload\n    /// @return value The value of the slot as bytes32\n    function exttload(bytes32 slot) external view returns (bytes32 value);\n\n    /// @notice Called by external contracts to access sparse transient pool state\n    /// @param slots List of slots to tload\n    /// @return values List of loaded values\n    function exttload(bytes32[] calldata slots) external view returns (bytes32[] memory values);\n}\n"},"lib/v4-periphery/lib/v4-core/src/libraries/Hooks.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {PoolKey} from \"../types/PoolKey.sol\";\nimport {IHooks} from \"../interfaces/IHooks.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\nimport {LPFeeLibrary} from \"./LPFeeLibrary.sol\";\nimport {BalanceDelta, toBalanceDelta, BalanceDeltaLibrary} from \"../types/BalanceDelta.sol\";\nimport {BeforeSwapDelta, BeforeSwapDeltaLibrary} from \"../types/BeforeSwapDelta.sol\";\nimport {IPoolManager} from \"../interfaces/IPoolManager.sol\";\nimport {ParseBytes} from \"./ParseBytes.sol\";\nimport {CustomRevert} from \"./CustomRevert.sol\";\n\n/// @notice V4 decides whether to invoke specific hooks by inspecting the least significant bits\n/// of the address that the hooks contract is deployed to.\n/// For example, a hooks contract deployed to address: 0x0000000000000000000000000000000000002400\n/// has the lowest bits '10 0100 0000 0000' which would cause the 'before initialize' and 'after add liquidity' hooks to be used.\nlibrary Hooks {\n    using LPFeeLibrary for uint24;\n    using Hooks for IHooks;\n    using SafeCast for int256;\n    using BeforeSwapDeltaLibrary for BeforeSwapDelta;\n    using ParseBytes for bytes;\n    using CustomRevert for bytes4;\n\n    uint160 internal constant ALL_HOOK_MASK = uint160((1 << 14) - 1);\n\n    uint160 internal constant BEFORE_INITIALIZE_FLAG = 1 << 13;\n    uint160 internal constant AFTER_INITIALIZE_FLAG = 1 << 12;\n\n    uint160 internal constant BEFORE_ADD_LIQUIDITY_FLAG = 1 << 11;\n    uint160 internal constant AFTER_ADD_LIQUIDITY_FLAG = 1 << 10;\n\n    uint160 internal constant BEFORE_REMOVE_LIQUIDITY_FLAG = 1 << 9;\n    uint160 internal constant AFTER_REMOVE_LIQUIDITY_FLAG = 1 << 8;\n\n    uint160 internal constant BEFORE_SWAP_FLAG = 1 << 7;\n    uint160 internal constant AFTER_SWAP_FLAG = 1 << 6;\n\n    uint160 internal constant BEFORE_DONATE_FLAG = 1 << 5;\n    uint160 internal constant AFTER_DONATE_FLAG = 1 << 4;\n\n    uint160 internal constant BEFORE_SWAP_RETURNS_DELTA_FLAG = 1 << 3;\n    uint160 internal constant AFTER_SWAP_RETURNS_DELTA_FLAG = 1 << 2;\n    uint160 internal constant AFTER_ADD_LIQUIDITY_RETURNS_DELTA_FLAG = 1 << 1;\n    uint160 internal constant AFTER_REMOVE_LIQUIDITY_RETURNS_DELTA_FLAG = 1 << 0;\n\n    struct Permissions {\n        bool beforeInitialize;\n        bool afterInitialize;\n        bool beforeAddLiquidity;\n        bool afterAddLiquidity;\n        bool beforeRemoveLiquidity;\n        bool afterRemoveLiquidity;\n        bool beforeSwap;\n        bool afterSwap;\n        bool beforeDonate;\n        bool afterDonate;\n        bool beforeSwapReturnDelta;\n        bool afterSwapReturnDelta;\n        bool afterAddLiquidityReturnDelta;\n        bool afterRemoveLiquidityReturnDelta;\n    }\n\n    /// @notice Thrown if the address will not lead to the specified hook calls being called\n    /// @param hooks The address of the hooks contract\n    error HookAddressNotValid(address hooks);\n\n    /// @notice Hook did not return its selector\n    error InvalidHookResponse();\n\n    /// @notice Additional context for ERC-7751 wrapped error when a hook call fails\n    error HookCallFailed();\n\n    /// @notice The hook's delta changed the swap from exactIn to exactOut or vice versa\n    error HookDeltaExceedsSwapAmount();\n\n    /// @notice Utility function intended to be used in hook constructors to ensure\n    /// the deployed hooks address causes the intended hooks to be called\n    /// @param permissions The hooks that are intended to be called\n    /// @dev permissions param is memory as the function will be called from constructors\n    function validateHookPermissions(IHooks self, Permissions memory permissions) internal pure {\n        if (\n            permissions.beforeInitialize != self.hasPermission(BEFORE_INITIALIZE_FLAG)\n                || permissions.afterInitialize != self.hasPermission(AFTER_INITIALIZE_FLAG)\n                || permissions.beforeAddLiquidity != self.hasPermission(BEFORE_ADD_LIQUIDITY_FLAG)\n                || permissions.afterAddLiquidity != self.hasPermission(AFTER_ADD_LIQUIDITY_FLAG)\n                || permissions.beforeRemoveLiquidity != self.hasPermission(BEFORE_REMOVE_LIQUIDITY_FLAG)\n                || permissions.afterRemoveLiquidity != self.hasPermission(AFTER_REMOVE_LIQUIDITY_FLAG)\n                || permissions.beforeSwap != self.hasPermission(BEFORE_SWAP_FLAG)\n                || permissions.afterSwap != self.hasPermission(AFTER_SWAP_FLAG)\n                || permissions.beforeDonate != self.hasPermission(BEFORE_DONATE_FLAG)\n                || permissions.afterDonate != self.hasPermission(AFTER_DONATE_FLAG)\n                || permissions.beforeSwapReturnDelta != self.hasPermission(BEFORE_SWAP_RETURNS_DELTA_FLAG)\n                || permissions.afterSwapReturnDelta != self.hasPermission(AFTER_SWAP_RETURNS_DELTA_FLAG)\n                || permissions.afterAddLiquidityReturnDelta != self.hasPermission(AFTER_ADD_LIQUIDITY_RETURNS_DELTA_FLAG)\n                || permissions.afterRemoveLiquidityReturnDelta\n                    != self.hasPermission(AFTER_REMOVE_LIQUIDITY_RETURNS_DELTA_FLAG)\n        ) {\n            HookAddressNotValid.selector.revertWith(address(self));\n        }\n    }\n\n    /// @notice Ensures that the hook address includes at least one hook flag or dynamic fees, or is the 0 address\n    /// @param self The hook to verify\n    /// @param fee The fee of the pool the hook is used with\n    /// @return bool True if the hook address is valid\n    function isValidHookAddress(IHooks self, uint24 fee) internal pure returns (bool) {\n        // The hook can only have a flag to return a hook delta on an action if it also has the corresponding action flag\n        if (!self.hasPermission(BEFORE_SWAP_FLAG) && self.hasPermission(BEFORE_SWAP_RETURNS_DELTA_FLAG)) return false;\n        if (!self.hasPermission(AFTER_SWAP_FLAG) && self.hasPermission(AFTER_SWAP_RETURNS_DELTA_FLAG)) return false;\n        if (!self.hasPermission(AFTER_ADD_LIQUIDITY_FLAG) && self.hasPermission(AFTER_ADD_LIQUIDITY_RETURNS_DELTA_FLAG))\n        {\n            return false;\n        }\n        if (\n            !self.hasPermission(AFTER_REMOVE_LIQUIDITY_FLAG)\n                && self.hasPermission(AFTER_REMOVE_LIQUIDITY_RETURNS_DELTA_FLAG)\n        ) return false;\n\n        // If there is no hook contract set, then fee cannot be dynamic\n        // If a hook contract is set, it must have at least 1 flag set, or have a dynamic fee\n        return address(self) == address(0)\n            ? !fee.isDynamicFee()\n            : (uint160(address(self)) & ALL_HOOK_MASK > 0 || fee.isDynamicFee());\n    }\n\n    /// @notice performs a hook call using the given calldata on the given hook that doesn't return a delta\n    /// @return result The complete data returned by the hook\n    function callHook(IHooks self, bytes memory data) internal returns (bytes memory result) {\n        bool success;\n        assembly (\"memory-safe\") {\n            success := call(gas(), self, 0, add(data, 0x20), mload(data), 0, 0)\n        }\n        // Revert with FailedHookCall, containing any error message to bubble up\n        if (!success) CustomRevert.bubbleUpAndRevertWith(address(self), bytes4(data), HookCallFailed.selector);\n\n        // The call was successful, fetch the returned data\n        assembly (\"memory-safe\") {\n            // allocate result byte array from the free memory pointer\n            result := mload(0x40)\n            // store new free memory pointer at the end of the array padded to 32 bytes\n            mstore(0x40, add(result, and(add(returndatasize(), 0x3f), not(0x1f))))\n            // store length in memory\n            mstore(result, returndatasize())\n            // copy return data to result\n            returndatacopy(add(result, 0x20), 0, returndatasize())\n        }\n\n        // Length must be at least 32 to contain the selector. Check expected selector and returned selector match.\n        if (result.length < 32 || result.parseSelector() != data.parseSelector()) {\n            InvalidHookResponse.selector.revertWith();\n        }\n    }\n\n    /// @notice performs a hook call using the given calldata on the given hook\n    /// @return int256 The delta returned by the hook\n    function callHookWithReturnDelta(IHooks self, bytes memory data, bool parseReturn) internal returns (int256) {\n        bytes memory result = callHook(self, data);\n\n        // If this hook wasn't meant to return something, default to 0 delta\n        if (!parseReturn) return 0;\n\n        // A length of 64 bytes is required to return a bytes4, and a 32 byte delta\n        if (result.length != 64) InvalidHookResponse.selector.revertWith();\n        return result.parseReturnDelta();\n    }\n\n    /// @notice modifier to prevent calling a hook if they initiated the action\n    modifier noSelfCall(IHooks self) {\n        if (msg.sender != address(self)) {\n            _;\n        }\n    }\n\n    /// @notice calls beforeInitialize hook if permissioned and validates return value\n    function beforeInitialize(IHooks self, PoolKey memory key, uint160 sqrtPriceX96) internal noSelfCall(self) {\n        if (self.hasPermission(BEFORE_INITIALIZE_FLAG)) {\n            self.callHook(abi.encodeCall(IHooks.beforeInitialize, (msg.sender, key, sqrtPriceX96)));\n        }\n    }\n\n    /// @notice calls afterInitialize hook if permissioned and validates return value\n    function afterInitialize(IHooks self, PoolKey memory key, uint160 sqrtPriceX96, int24 tick)\n        internal\n        noSelfCall(self)\n    {\n        if (self.hasPermission(AFTER_INITIALIZE_FLAG)) {\n            self.callHook(abi.encodeCall(IHooks.afterInitialize, (msg.sender, key, sqrtPriceX96, tick)));\n        }\n    }\n\n    /// @notice calls beforeModifyLiquidity hook if permissioned and validates return value\n    function beforeModifyLiquidity(\n        IHooks self,\n        PoolKey memory key,\n        IPoolManager.ModifyLiquidityParams memory params,\n        bytes calldata hookData\n    ) internal noSelfCall(self) {\n        if (params.liquidityDelta > 0 && self.hasPermission(BEFORE_ADD_LIQUIDITY_FLAG)) {\n            self.callHook(abi.encodeCall(IHooks.beforeAddLiquidity, (msg.sender, key, params, hookData)));\n        } else if (params.liquidityDelta <= 0 && self.hasPermission(BEFORE_REMOVE_LIQUIDITY_FLAG)) {\n            self.callHook(abi.encodeCall(IHooks.beforeRemoveLiquidity, (msg.sender, key, params, hookData)));\n        }\n    }\n\n    /// @notice calls afterModifyLiquidity hook if permissioned and validates return value\n    function afterModifyLiquidity(\n        IHooks self,\n        PoolKey memory key,\n        IPoolManager.ModifyLiquidityParams memory params,\n        BalanceDelta delta,\n        BalanceDelta feesAccrued,\n        bytes calldata hookData\n    ) internal returns (BalanceDelta callerDelta, BalanceDelta hookDelta) {\n        if (msg.sender == address(self)) return (delta, BalanceDeltaLibrary.ZERO_DELTA);\n\n        callerDelta = delta;\n        if (params.liquidityDelta > 0) {\n            if (self.hasPermission(AFTER_ADD_LIQUIDITY_FLAG)) {\n                hookDelta = BalanceDelta.wrap(\n                    self.callHookWithReturnDelta(\n                        abi.encodeCall(\n                            IHooks.afterAddLiquidity, (msg.sender, key, params, delta, feesAccrued, hookData)\n                        ),\n                        self.hasPermission(AFTER_ADD_LIQUIDITY_RETURNS_DELTA_FLAG)\n                    )\n                );\n                callerDelta = callerDelta - hookDelta;\n            }\n        } else {\n            if (self.hasPermission(AFTER_REMOVE_LIQUIDITY_FLAG)) {\n                hookDelta = BalanceDelta.wrap(\n                    self.callHookWithReturnDelta(\n                        abi.encodeCall(\n                            IHooks.afterRemoveLiquidity, (msg.sender, key, params, delta, feesAccrued, hookData)\n                        ),\n                        self.hasPermission(AFTER_REMOVE_LIQUIDITY_RETURNS_DELTA_FLAG)\n                    )\n                );\n                callerDelta = callerDelta - hookDelta;\n            }\n        }\n    }\n\n    /// @notice calls beforeSwap hook if permissioned and validates return value\n    function beforeSwap(IHooks self, PoolKey memory key, IPoolManager.SwapParams memory params, bytes calldata hookData)\n        internal\n        returns (int256 amountToSwap, BeforeSwapDelta hookReturn, uint24 lpFeeOverride)\n    {\n        amountToSwap = params.amountSpecified;\n        if (msg.sender == address(self)) return (amountToSwap, BeforeSwapDeltaLibrary.ZERO_DELTA, lpFeeOverride);\n\n        if (self.hasPermission(BEFORE_SWAP_FLAG)) {\n            bytes memory result = callHook(self, abi.encodeCall(IHooks.beforeSwap, (msg.sender, key, params, hookData)));\n\n            // A length of 96 bytes is required to return a bytes4, a 32 byte delta, and an LP fee\n            if (result.length != 96) InvalidHookResponse.selector.revertWith();\n\n            // dynamic fee pools that want to override the cache fee, return a valid fee with the override flag. If override flag\n            // is set but an invalid fee is returned, the transaction will revert. Otherwise the current LP fee will be used\n            if (key.fee.isDynamicFee()) lpFeeOverride = result.parseFee();\n\n            // skip this logic for the case where the hook return is 0\n            if (self.hasPermission(BEFORE_SWAP_RETURNS_DELTA_FLAG)) {\n                hookReturn = BeforeSwapDelta.wrap(result.parseReturnDelta());\n\n                // any return in unspecified is passed to the afterSwap hook for handling\n                int128 hookDeltaSpecified = hookReturn.getSpecifiedDelta();\n\n                // Update the swap amount according to the hook's return, and check that the swap type doesn't change (exact input/output)\n                if (hookDeltaSpecified != 0) {\n                    bool exactInput = amountToSwap < 0;\n                    amountToSwap += hookDeltaSpecified;\n                    if (exactInput ? amountToSwap > 0 : amountToSwap < 0) {\n                        HookDeltaExceedsSwapAmount.selector.revertWith();\n                    }\n                }\n            }\n        }\n    }\n\n    /// @notice calls afterSwap hook if permissioned and validates return value\n    function afterSwap(\n        IHooks self,\n        PoolKey memory key,\n        IPoolManager.SwapParams memory params,\n        BalanceDelta swapDelta,\n        bytes calldata hookData,\n        BeforeSwapDelta beforeSwapHookReturn\n    ) internal returns (BalanceDelta, BalanceDelta) {\n        if (msg.sender == address(self)) return (swapDelta, BalanceDeltaLibrary.ZERO_DELTA);\n\n        int128 hookDeltaSpecified = beforeSwapHookReturn.getSpecifiedDelta();\n        int128 hookDeltaUnspecified = beforeSwapHookReturn.getUnspecifiedDelta();\n\n        if (self.hasPermission(AFTER_SWAP_FLAG)) {\n            hookDeltaUnspecified += self.callHookWithReturnDelta(\n                abi.encodeCall(IHooks.afterSwap, (msg.sender, key, params, swapDelta, hookData)),\n                self.hasPermission(AFTER_SWAP_RETURNS_DELTA_FLAG)\n            ).toInt128();\n        }\n\n        BalanceDelta hookDelta;\n        if (hookDeltaUnspecified != 0 || hookDeltaSpecified != 0) {\n            hookDelta = (params.amountSpecified < 0 == params.zeroForOne)\n                ? toBalanceDelta(hookDeltaSpecified, hookDeltaUnspecified)\n                : toBalanceDelta(hookDeltaUnspecified, hookDeltaSpecified);\n\n            // the caller has to pay for (or receive) the hook's delta\n            swapDelta = swapDelta - hookDelta;\n        }\n        return (swapDelta, hookDelta);\n    }\n\n    /// @notice calls beforeDonate hook if permissioned and validates return value\n    function beforeDonate(IHooks self, PoolKey memory key, uint256 amount0, uint256 amount1, bytes calldata hookData)\n        internal\n        noSelfCall(self)\n    {\n        if (self.hasPermission(BEFORE_DONATE_FLAG)) {\n            self.callHook(abi.encodeCall(IHooks.beforeDonate, (msg.sender, key, amount0, amount1, hookData)));\n        }\n    }\n\n    /// @notice calls afterDonate hook if permissioned and validates return value\n    function afterDonate(IHooks self, PoolKey memory key, uint256 amount0, uint256 amount1, bytes calldata hookData)\n        internal\n        noSelfCall(self)\n    {\n        if (self.hasPermission(AFTER_DONATE_FLAG)) {\n            self.callHook(abi.encodeCall(IHooks.afterDonate, (msg.sender, key, amount0, amount1, hookData)));\n        }\n    }\n\n    function hasPermission(IHooks self, uint160 flag) internal pure returns (bool) {\n        return uint160(address(self)) & flag != 0;\n    }\n}\n"},"src/interfaces/IAngstromComposable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @dev Expected return magic (`keccak256(\"Angstrom.hook.return-magic\")[-4:]`).\nuint32 constant EXPECTED_HOOK_RETURN_MAGIC = 0x24a2e44b;\n\n/// @author philogy <https://github.com/philogy>\ninterface IAngstromComposable {\n    function compose(address from, bytes calldata payload) external returns (uint32);\n}\n"},"src/interfaces/IERC2612.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @author philogy <https://github.com/philogy>\ninterface IERC2612 {\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"},"src/interfaces/IDaiPermit.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @author philogy <https://github.com/philogy>\ninterface IDaiPermit {\n    function permit(\n        address holder,\n        address spender,\n        uint256 nonce,\n        uint256 expiry,\n        bool allowed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"},"src/libraries/RayMathLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {FixedPointMathLib} from \"solady/src/utils/FixedPointMathLib.sol\";\n\n/// @author philogy <https://github.com/philogy>\n/// @dev Similar to \"wad math\" except that the decimals used is a bit higher for the sake of\n/// precision. Done to accommodate tokens that maybe have very large denominations.\nlibrary RayMathLib {\n    using FixedPointMathLib for uint256;\n\n    uint256 internal constant RAY = 1e27;\n    uint256 internal constant RAY_2 = 1e54;\n\n    function mulRayDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return x * y / RAY;\n    }\n\n    function mulRayUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return x.mulDivUp(y, RAY);\n    }\n\n    function divRayDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return x * RAY / y;\n    }\n\n    function divRayUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return x.mulDivUp(RAY, y);\n    }\n\n    function invRayUnchecked(uint256 x) internal pure returns (uint256 y) {\n        assembly (\"memory-safe\") {\n            y := div(RAY_2, x)\n        }\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/libraries/TickMath.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {BitMath} from \"./BitMath.sol\";\nimport {CustomRevert} from \"./CustomRevert.sol\";\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    using CustomRevert for bytes4;\n\n    /// @notice Thrown when the tick passed to #getSqrtPriceAtTick is not between MIN_TICK and MAX_TICK\n    error InvalidTick(int24 tick);\n    /// @notice Thrown when the price passed to #getTickAtSqrtPrice does not correspond to a price between MIN_TICK and MAX_TICK\n    error InvalidSqrtPrice(uint160 sqrtPriceX96);\n\n    /// @dev The minimum tick that may be passed to #getSqrtPriceAtTick computed from log base 1.0001 of 2**-128\n    /// @dev If ever MIN_TICK and MAX_TICK are not centered around 0, the absTick logic in getSqrtPriceAtTick cannot be used\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtPriceAtTick computed from log base 1.0001 of 2**128\n    /// @dev If ever MIN_TICK and MAX_TICK are not centered around 0, the absTick logic in getSqrtPriceAtTick cannot be used\n    int24 internal constant MAX_TICK = 887272;\n\n    /// @dev The minimum tick spacing value drawn from the range of type int16 that is greater than 0, i.e. min from the range [1, 32767]\n    int24 internal constant MIN_TICK_SPACING = 1;\n    /// @dev The maximum tick spacing value drawn from the range of type int16, i.e. max from the range [1, 32767]\n    int24 internal constant MAX_TICK_SPACING = type(int16).max;\n\n    /// @dev The minimum value that can be returned from #getSqrtPriceAtTick. Equivalent to getSqrtPriceAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_PRICE = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtPriceAtTick. Equivalent to getSqrtPriceAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_PRICE = 1461446703485210103287273052203988822378723970342;\n    /// @dev A threshold used for optimized bounds check, equals `MAX_SQRT_PRICE - MIN_SQRT_PRICE - 1`\n    uint160 internal constant MAX_SQRT_PRICE_MINUS_MIN_SQRT_PRICE_MINUS_ONE =\n        1461446703485210103287273052203988822378723970342 - 4295128739 - 1;\n\n    /// @notice Given a tickSpacing, compute the maximum usable tick\n    function maxUsableTick(int24 tickSpacing) internal pure returns (int24) {\n        unchecked {\n            return (MAX_TICK / tickSpacing) * tickSpacing;\n        }\n    }\n\n    /// @notice Given a tickSpacing, compute the minimum usable tick\n    function minUsableTick(int24 tickSpacing) internal pure returns (int24) {\n        unchecked {\n            return (MIN_TICK / tickSpacing) * tickSpacing;\n        }\n    }\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the price of the two assets (currency1/currency0)\n    /// at the given tick\n    function getSqrtPriceAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        unchecked {\n            uint256 absTick;\n            assembly (\"memory-safe\") {\n                tick := signextend(2, tick)\n                // mask = 0 if tick >= 0 else -1 (all 1s)\n                let mask := sar(255, tick)\n                // if tick >= 0, |tick| = tick = 0 ^ tick\n                // if tick < 0, |tick| = ~~|tick| = ~(-|tick| - 1) = ~(tick - 1) = (-1) ^ (tick - 1)\n                // either way, |tick| = mask ^ (tick + mask)\n                absTick := xor(mask, add(mask, tick))\n            }\n\n            if (absTick > uint256(int256(MAX_TICK))) InvalidTick.selector.revertWith(tick);\n\n            // The tick is decomposed into bits, and for each bit with index i that is set, the product of 1/sqrt(1.0001^(2^i))\n            // is calculated (using Q128.128). The constants used for this calculation are rounded to the nearest integer\n\n            // Equivalent to:\n            //     price = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n            //     or price = int(2**128 / sqrt(1.0001)) if (absTick & 0x1) else 1 << 128\n            uint256 price;\n            assembly (\"memory-safe\") {\n                price := xor(shl(128, 1), mul(xor(shl(128, 1), 0xfffcb933bd6fad37aa2d162d1a594001), and(absTick, 0x1)))\n            }\n            if (absTick & 0x2 != 0) price = (price * 0xfff97272373d413259a46990580e213a) >> 128;\n            if (absTick & 0x4 != 0) price = (price * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n            if (absTick & 0x8 != 0) price = (price * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n            if (absTick & 0x10 != 0) price = (price * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n            if (absTick & 0x20 != 0) price = (price * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n            if (absTick & 0x40 != 0) price = (price * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n            if (absTick & 0x80 != 0) price = (price * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n            if (absTick & 0x100 != 0) price = (price * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n            if (absTick & 0x200 != 0) price = (price * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n            if (absTick & 0x400 != 0) price = (price * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n            if (absTick & 0x800 != 0) price = (price * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n            if (absTick & 0x1000 != 0) price = (price * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n            if (absTick & 0x2000 != 0) price = (price * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n            if (absTick & 0x4000 != 0) price = (price * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n            if (absTick & 0x8000 != 0) price = (price * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n            if (absTick & 0x10000 != 0) price = (price * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n            if (absTick & 0x20000 != 0) price = (price * 0x5d6af8dedb81196699c329225ee604) >> 128;\n            if (absTick & 0x40000 != 0) price = (price * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n            if (absTick & 0x80000 != 0) price = (price * 0x48a170391f7dc42444e8fa2) >> 128;\n\n            assembly (\"memory-safe\") {\n                // if (tick > 0) price = type(uint256).max / price;\n                if sgt(tick, 0) { price := div(not(0), price) }\n\n                // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n                // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n                // we round up in the division so getTickAtSqrtPrice of the output price is always consistent\n                // `sub(shl(32, 1), 1)` is `type(uint32).max`\n                // `price + type(uint32).max` will not overflow because `price` fits in 192 bits\n                sqrtPriceX96 := shr(32, add(price, sub(shl(32, 1), 1)))\n            }\n        }\n    }\n\n    /// @notice Calculates the greatest tick value such that getSqrtPriceAtTick(tick) <= sqrtPriceX96\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_PRICE, as MIN_SQRT_PRICE is the lowest value getSqrtPriceAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt price for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the getSqrtPriceAtTick(tick) is less than or equal to the input sqrtPriceX96\n    function getTickAtSqrtPrice(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        unchecked {\n            // Equivalent: if (sqrtPriceX96 < MIN_SQRT_PRICE || sqrtPriceX96 >= MAX_SQRT_PRICE) revert InvalidSqrtPrice();\n            // second inequality must be >= because the price can never reach the price at the max tick\n            // if sqrtPriceX96 < MIN_SQRT_PRICE, the `sub` underflows and `gt` is true\n            // if sqrtPriceX96 >= MAX_SQRT_PRICE, sqrtPriceX96 - MIN_SQRT_PRICE > MAX_SQRT_PRICE - MIN_SQRT_PRICE - 1\n            if ((sqrtPriceX96 - MIN_SQRT_PRICE) > MAX_SQRT_PRICE_MINUS_MIN_SQRT_PRICE_MINUS_ONE) {\n                InvalidSqrtPrice.selector.revertWith(sqrtPriceX96);\n            }\n\n            uint256 price = uint256(sqrtPriceX96) << 32;\n\n            uint256 r = price;\n            uint256 msb = BitMath.mostSignificantBit(r);\n\n            if (msb >= 128) r = price >> (msb - 127);\n            else r = price << (127 - msb);\n\n            int256 log_2 = (int256(msb) - 128) << 64;\n\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(63, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(62, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(61, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(60, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(59, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(58, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(57, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(56, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(55, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(54, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(53, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(52, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(51, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(50, f))\n            }\n\n            int256 log_sqrt10001 = log_2 * 255738958999603826347141; // Q22.128 number\n\n            // Magic number represents the ceiling of the maximum value of the error when approximating log_sqrt10001(x)\n            int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n\n            // Magic number represents the minimum value of the error when approximating log_sqrt10001(x), when\n            // sqrtPrice is from the range (2^-64, 2^64). This is safe as MIN_SQRT_PRICE is more than 2^-64. If MIN_SQRT_PRICE\n            // is changed, this may need to be changed too\n            int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n            tick = tickLow == tickHi ? tickLow : getSqrtPriceAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n        }\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/libraries/CustomRevert.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Library for reverting with custom errors efficiently\n/// @notice Contains functions for reverting with custom errors with different argument types efficiently\n/// @dev To use this library, declare `using CustomRevert for bytes4;` and replace `revert CustomError()` with\n/// `CustomError.selector.revertWith()`\n/// @dev The functions may tamper with the free memory pointer but it is fine since the call context is exited immediately\nlibrary CustomRevert {\n    /// @dev ERC-7751 error for wrapping bubbled up reverts\n    error WrappedError(address target, bytes4 selector, bytes reason, bytes details);\n\n    /// @dev Reverts with the selector of a custom error in the scratch space\n    function revertWith(bytes4 selector) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            revert(0, 0x04)\n        }\n    }\n\n    /// @dev Reverts with a custom error with an address argument in the scratch space\n    function revertWith(bytes4 selector, address addr) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            mstore(0x04, and(addr, 0xffffffffffffffffffffffffffffffffffffffff))\n            revert(0, 0x24)\n        }\n    }\n\n    /// @dev Reverts with a custom error with an int24 argument in the scratch space\n    function revertWith(bytes4 selector, int24 value) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            mstore(0x04, signextend(2, value))\n            revert(0, 0x24)\n        }\n    }\n\n    /// @dev Reverts with a custom error with a uint160 argument in the scratch space\n    function revertWith(bytes4 selector, uint160 value) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            mstore(0x04, and(value, 0xffffffffffffffffffffffffffffffffffffffff))\n            revert(0, 0x24)\n        }\n    }\n\n    /// @dev Reverts with a custom error with two int24 arguments\n    function revertWith(bytes4 selector, int24 value1, int24 value2) internal pure {\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(fmp, selector)\n            mstore(add(fmp, 0x04), signextend(2, value1))\n            mstore(add(fmp, 0x24), signextend(2, value2))\n            revert(fmp, 0x44)\n        }\n    }\n\n    /// @dev Reverts with a custom error with two uint160 arguments\n    function revertWith(bytes4 selector, uint160 value1, uint160 value2) internal pure {\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(fmp, selector)\n            mstore(add(fmp, 0x04), and(value1, 0xffffffffffffffffffffffffffffffffffffffff))\n            mstore(add(fmp, 0x24), and(value2, 0xffffffffffffffffffffffffffffffffffffffff))\n            revert(fmp, 0x44)\n        }\n    }\n\n    /// @dev Reverts with a custom error with two address arguments\n    function revertWith(bytes4 selector, address value1, address value2) internal pure {\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(fmp, selector)\n            mstore(add(fmp, 0x04), and(value1, 0xffffffffffffffffffffffffffffffffffffffff))\n            mstore(add(fmp, 0x24), and(value2, 0xffffffffffffffffffffffffffffffffffffffff))\n            revert(fmp, 0x44)\n        }\n    }\n\n    /// @notice bubble up the revert message returned by a call and revert with a wrapped ERC-7751 error\n    /// @dev this method can be vulnerable to revert data bombs\n    function bubbleUpAndRevertWith(\n        address revertingContract,\n        bytes4 revertingFunctionSelector,\n        bytes4 additionalContext\n    ) internal pure {\n        bytes4 wrappedErrorSelector = WrappedError.selector;\n        assembly (\"memory-safe\") {\n            // Ensure the size of the revert data is a multiple of 32 bytes\n            let encodedDataSize := mul(div(add(returndatasize(), 31), 32), 32)\n\n            let fmp := mload(0x40)\n\n            // Encode wrapped error selector, address, function selector, offset, additional context, size, revert reason\n            mstore(fmp, wrappedErrorSelector)\n            mstore(add(fmp, 0x04), and(revertingContract, 0xffffffffffffffffffffffffffffffffffffffff))\n            mstore(\n                add(fmp, 0x24),\n                and(revertingFunctionSelector, 0xffffffff00000000000000000000000000000000000000000000000000000000)\n            )\n            // offset revert reason\n            mstore(add(fmp, 0x44), 0x80)\n            // offset additional context\n            mstore(add(fmp, 0x64), add(0xa0, encodedDataSize))\n            // size revert reason\n            mstore(add(fmp, 0x84), returndatasize())\n            // revert reason\n            returndatacopy(add(fmp, 0xa4), 0, returndatasize())\n            // size additional context\n            mstore(add(fmp, add(0xa4, encodedDataSize)), 0x04)\n            // additional context\n            mstore(\n                add(fmp, add(0xc4, encodedDataSize)),\n                and(additionalContext, 0xffffffff00000000000000000000000000000000000000000000000000000000)\n            )\n            revert(fmp, add(0xe4, encodedDataSize))\n        }\n    }\n}\n"},"src/libraries/MixedSignLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @author philogy <https://github.com/philogy>\n/// @dev Adds helper methods to enable safe, checked arithmetic between signed & unsigned types. Not\n/// generalized as only these 4 particular instantiations were required.\nlibrary MixedSignLib {\n    error ArithmeticOverflowUnderflow();\n\n    function add(int256 x, uint256 y) internal pure returns (int256 z) {\n        assembly (\"memory-safe\") {\n            z := add(x, y)\n\n            if slt(z, x) {\n                mstore(0x00, 0xc9654ed4 /* ArithmeticOverflowUnderflow() */ )\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    function sub(int256 x, uint256 y) internal pure returns (int256 z) {\n        assembly (\"memory-safe\") {\n            z := sub(x, y)\n\n            if sgt(z, x) {\n                mstore(0x00, 0xc9654ed4 /* ArithmeticOverflowUnderflow() */ )\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    function add(uint128 x, int128 y) internal pure returns (uint128 z) {\n        assembly (\"memory-safe\") {\n            z := add(x, y)\n\n            if shr(128, z) {\n                mstore(0x00, 0xc9654ed4 /* ArithmeticOverflowUnderflow() */ )\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    function sub(uint128 x, int128 y) internal pure returns (uint128 z) {\n        assembly (\"memory-safe\") {\n            z := sub(x, y)\n\n            if shr(128, z) {\n                mstore(0x00, 0xc9654ed4 /* ArithmeticOverflowUnderflow() */ )\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n}\n"},"lib/transient-goodies/src/TransientPrimitives.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/// @author philogy <https://github.com/philogy>\n\nstruct tuint256 {\n    uint256 __placeholder;\n}\n\nstruct tint256 {\n    uint256 __placeholder;\n}\n\nstruct tbytes32 {\n    uint256 __placeholder;\n}\n\nstruct taddress {\n    uint256 __placeholder;\n}\n\nusing TransientPrimitivesLib for tuint256 global;\nusing TransientPrimitivesLib for tint256 global;\nusing TransientPrimitivesLib for tbytes32 global;\nusing TransientPrimitivesLib for taddress global;\n\nlibrary TransientPrimitivesLib {\n    error ArithmeticOverflowUnderflow();\n\n    function get(tuint256 storage ptr) internal view returns (uint256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(ptr.slot)\n        }\n    }\n\n    function get(tint256 storage ptr) internal view returns (int256 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(ptr.slot)\n        }\n    }\n\n    function get(tbytes32 storage ptr) internal view returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(ptr.slot)\n        }\n    }\n\n    function get(taddress storage ptr) internal view returns (address value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := tload(ptr.slot)\n        }\n    }\n\n    function set(tuint256 storage ptr, uint256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, value)\n        }\n    }\n\n    function inc(tuint256 storage ptr, uint256 change) internal returns (uint256 newValue) {\n        ptr.set(newValue = ptr.get() + change);\n    }\n\n    function dec(tuint256 storage ptr, uint256 change) internal returns (uint256 newValue) {\n        ptr.set(newValue = ptr.get() - change);\n    }\n\n    function inc(tuint256 storage ptr, int256 change) internal returns (uint256 newValue) {\n        uint256 currentValue = ptr.get();\n        assembly (\"memory-safe\") {\n            newValue := add(currentValue, change)\n            if iszero(eq(lt(newValue, currentValue), slt(change, 0))) {\n                mstore(0x00, 0xc9654ed4 /* ArithmeticOverflowUnderflow() */ )\n                revert(0x1c, 0x04)\n            }\n        }\n        ptr.set(newValue);\n    }\n\n    function dec(tuint256 storage ptr, int256 change) internal returns (uint256 newValue) {\n        uint256 currentValue = ptr.get();\n        assembly (\"memory-safe\") {\n            newValue := sub(currentValue, change)\n            if iszero(eq(lt(newValue, currentValue), sgt(change, 0))) {\n                mstore(0x00, 0xc9654ed4 /* ArithmeticOverflowUnderflow() */ )\n                revert(0x1c, 0x04)\n            }\n        }\n        ptr.set(newValue);\n    }\n\n    function set(tint256 storage ptr, int256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, value)\n        }\n    }\n\n    function inc(tint256 storage ptr, int256 change) internal returns (int256 newValue) {\n        ptr.set(newValue = ptr.get() + change);\n    }\n\n    function dec(tint256 storage ptr, int256 change) internal returns (int256 newValue) {\n        ptr.set(newValue = ptr.get() - change);\n    }\n\n    function set(tbytes32 storage ptr, bytes32 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, value)\n        }\n    }\n\n    function set(taddress storage ptr, address value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, value)\n        }\n    }\n}\n"},"src/libraries/TickLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {LibBit} from \"solady/src/utils/LibBit.sol\";\n\n/// @author philogy <https://github.com/philogy>\nlibrary TickLib {\n    int24 internal constant MIN_TICK = -887272;\n    int24 internal constant MAX_TICK = 887272;\n\n    function isInitialized(uint256 word, uint8 bitPos) internal pure returns (bool) {\n        return word & (uint256(1) << bitPos) != 0;\n    }\n\n    function nextBitPosLte(uint256 word, uint8 bitPos)\n        internal\n        pure\n        returns (bool initialized, uint8 nextBitPos)\n    {\n        unchecked {\n            uint8 offset = 0xff - bitPos;\n\n            uint256 relativePos = LibBit.fls(word << offset);\n            initialized = relativePos != 256;\n            nextBitPos = initialized ? uint8(relativePos - offset) : 0;\n        }\n    }\n\n    function nextBitPosGte(uint256 word, uint8 bitPos)\n        internal\n        pure\n        returns (bool initialized, uint8 nextBitPos)\n    {\n        unchecked {\n            uint256 relativePos = LibBit.ffs(word >> bitPos);\n            initialized = relativePos != 256;\n            nextBitPos = initialized ? uint8(relativePos + bitPos) : type(uint8).max;\n        }\n    }\n\n    function compress(int24 tick, int24 tickSpacing) internal pure returns (int24 compressed) {\n        assembly (\"memory-safe\") {\n            compressed := sub(sdiv(tick, tickSpacing), slt(smod(tick, tickSpacing), 0))\n        }\n    }\n\n    /// @dev Normalize tick to its tick boundary (rounding towards negative infinity). WARN: Can underflow\n    /// for values of `tick < mul(sdiv(type(int24).min, tickSpacing), tickSpacing)`.\n    function normalizeUnchecked(int24 tick, int24 tickSpacing)\n        internal\n        pure\n        returns (int24 normalized)\n    {\n        assembly (\"memory-safe\") {\n            normalized :=\n                mul(sub(sdiv(tick, tickSpacing), slt(smod(tick, tickSpacing), 0)), tickSpacing)\n        }\n    }\n\n    function position(int24 compressed) internal pure returns (int16 wordPos, uint8 bitPos) {\n        assembly (\"memory-safe\") {\n            wordPos := sar(8, compressed)\n            bitPos := and(compressed, 0xff)\n        }\n    }\n\n    function toTick(int16 wordPos, uint8 bitPos, int24 tickSpacing) internal pure returns (int24) {\n        return (int24(wordPos) * 256 + int24(uint24(bitPos))) * tickSpacing;\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/types/Slot0.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @dev Slot0 is a packed version of solidity structure.\n * Using the packaged version saves gas by not storing the structure fields in memory slots.\n *\n * Layout:\n * 24 bits empty | 24 bits lpFee | 12 bits protocolFee 1->0 | 12 bits protocolFee 0->1 | 24 bits tick | 160 bits sqrtPriceX96\n *\n * Fields in the direction from the least significant bit:\n *\n * The current price\n * uint160 sqrtPriceX96;\n *\n * The current tick\n * int24 tick;\n *\n * Protocol fee, expressed in hundredths of a bip, upper 12 bits are for 1->0, and the lower 12 are for 0->1\n * the maximum is 1000 - meaning the maximum protocol fee is 0.1%\n * the protocolFee is taken from the input first, then the lpFee is taken from the remaining input\n * uint24 protocolFee;\n *\n * The current LP fee of the pool. If the pool is dynamic, this does not include the dynamic fee flag.\n * uint24 lpFee;\n */\ntype Slot0 is bytes32;\n\nusing Slot0Library for Slot0 global;\n\n/// @notice Library for getting and setting values in the Slot0 type\nlibrary Slot0Library {\n    uint160 internal constant MASK_160_BITS = 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n    uint24 internal constant MASK_24_BITS = 0xFFFFFF;\n\n    uint8 internal constant TICK_OFFSET = 160;\n    uint8 internal constant PROTOCOL_FEE_OFFSET = 184;\n    uint8 internal constant LP_FEE_OFFSET = 208;\n\n    // #### GETTERS ####\n    function sqrtPriceX96(Slot0 _packed) internal pure returns (uint160 _sqrtPriceX96) {\n        assembly (\"memory-safe\") {\n            _sqrtPriceX96 := and(MASK_160_BITS, _packed)\n        }\n    }\n\n    function tick(Slot0 _packed) internal pure returns (int24 _tick) {\n        assembly (\"memory-safe\") {\n            _tick := signextend(2, shr(TICK_OFFSET, _packed))\n        }\n    }\n\n    function protocolFee(Slot0 _packed) internal pure returns (uint24 _protocolFee) {\n        assembly (\"memory-safe\") {\n            _protocolFee := and(MASK_24_BITS, shr(PROTOCOL_FEE_OFFSET, _packed))\n        }\n    }\n\n    function lpFee(Slot0 _packed) internal pure returns (uint24 _lpFee) {\n        assembly (\"memory-safe\") {\n            _lpFee := and(MASK_24_BITS, shr(LP_FEE_OFFSET, _packed))\n        }\n    }\n\n    // #### SETTERS ####\n    function setSqrtPriceX96(Slot0 _packed, uint160 _sqrtPriceX96) internal pure returns (Slot0 _result) {\n        assembly (\"memory-safe\") {\n            _result := or(and(not(MASK_160_BITS), _packed), and(MASK_160_BITS, _sqrtPriceX96))\n        }\n    }\n\n    function setTick(Slot0 _packed, int24 _tick) internal pure returns (Slot0 _result) {\n        assembly (\"memory-safe\") {\n            _result := or(and(not(shl(TICK_OFFSET, MASK_24_BITS)), _packed), shl(TICK_OFFSET, and(MASK_24_BITS, _tick)))\n        }\n    }\n\n    function setProtocolFee(Slot0 _packed, uint24 _protocolFee) internal pure returns (Slot0 _result) {\n        assembly (\"memory-safe\") {\n            _result :=\n                or(\n                    and(not(shl(PROTOCOL_FEE_OFFSET, MASK_24_BITS)), _packed),\n                    shl(PROTOCOL_FEE_OFFSET, and(MASK_24_BITS, _protocolFee))\n                )\n        }\n    }\n\n    function setLpFee(Slot0 _packed, uint24 _lpFee) internal pure returns (Slot0 _result) {\n        assembly (\"memory-safe\") {\n            _result :=\n                or(and(not(shl(LP_FEE_OFFSET, MASK_24_BITS)), _packed), shl(LP_FEE_OFFSET, and(MASK_24_BITS, _lpFee)))\n        }\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/interfaces/external/IERC20Minimal.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Minimal ERC20 interface for Uniswap\n/// @notice Contains a subset of the full ERC20 interface that is used in Uniswap V3\ninterface IERC20Minimal {\n    /// @notice Returns an account's balance in the token\n    /// @param account The account for which to look up the number of tokens it has, i.e. its balance\n    /// @return The number of tokens held by the account\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Transfers the amount of token from the `msg.sender` to the recipient\n    /// @param recipient The account that will receive the amount transferred\n    /// @param amount The number of tokens to send from the sender to the recipient\n    /// @return Returns true for a successful transfer, false for an unsuccessful transfer\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /// @notice Returns the current allowance given to a spender by an owner\n    /// @param owner The account of the token owner\n    /// @param spender The account of the token spender\n    /// @return The current allowance granted by `owner` to `spender`\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Sets the allowance of a spender from the `msg.sender` to the value `amount`\n    /// @param spender The account which will be allowed to spend a given amount of the owners tokens\n    /// @param amount The amount of tokens allowed to be used by `spender`\n    /// @return Returns true for a successful approval, false for unsuccessful\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`\n    /// @param sender The account from which the transfer will be initiated\n    /// @param recipient The recipient of the transfer\n    /// @param amount The amount of the transfer\n    /// @return Returns true for a successful transfer, false for unsuccessful\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /// @notice Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`.\n    /// @param from The account from which the tokens were sent, i.e. the balance decreased\n    /// @param to The account to which the tokens were sent, i.e. the balance increased\n    /// @param value The amount of tokens that were transferred\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice Event emitted when the approval amount for the spender of a given owner's tokens changes.\n    /// @param owner The account that approved spending of its tokens\n    /// @param spender The account for which the spending allowance was modified\n    /// @param value The new allowance from the owner to the spender\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"lib/v4-periphery/lib/v4-core/src/libraries/SafeCast.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {CustomRevert} from \"./CustomRevert.sol\";\n\n/// @title Safe casting methods\n/// @notice Contains methods for safely casting between types\nlibrary SafeCast {\n    using CustomRevert for bytes4;\n\n    error SafeCastOverflow();\n\n    /// @notice Cast a uint256 to a uint160, revert on overflow\n    /// @param x The uint256 to be downcasted\n    /// @return y The downcasted integer, now type uint160\n    function toUint160(uint256 x) internal pure returns (uint160 y) {\n        y = uint160(x);\n        if (y != x) SafeCastOverflow.selector.revertWith();\n    }\n\n    /// @notice Cast a uint256 to a uint128, revert on overflow\n    /// @param x The uint256 to be downcasted\n    /// @return y The downcasted integer, now type uint128\n    function toUint128(uint256 x) internal pure returns (uint128 y) {\n        y = uint128(x);\n        if (x != y) SafeCastOverflow.selector.revertWith();\n    }\n\n    /// @notice Cast a int128 to a uint128, revert on overflow or underflow\n    /// @param x The int128 to be casted\n    /// @return y The casted integer, now type uint128\n    function toUint128(int128 x) internal pure returns (uint128 y) {\n        if (x < 0) SafeCastOverflow.selector.revertWith();\n        y = uint128(x);\n    }\n\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\n    /// @param x The int256 to be downcasted\n    /// @return y The downcasted integer, now type int128\n    function toInt128(int256 x) internal pure returns (int128 y) {\n        y = int128(x);\n        if (y != x) SafeCastOverflow.selector.revertWith();\n    }\n\n    /// @notice Cast a uint256 to a int256, revert on overflow\n    /// @param x The uint256 to be casted\n    /// @return y The casted integer, now type int256\n    function toInt256(uint256 x) internal pure returns (int256 y) {\n        y = int256(x);\n        if (y < 0) SafeCastOverflow.selector.revertWith();\n    }\n\n    /// @notice Cast a uint256 to a int128, revert on overflow\n    /// @param x The uint256 to be downcasted\n    /// @return The downcasted integer, now type int128\n    function toInt128(uint256 x) internal pure returns (int128) {\n        if (x >= 1 << 127) SafeCastOverflow.selector.revertWith();\n        return int128(int256(x));\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/libraries/ParseBytes.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @notice Parses bytes returned from hooks and the byte selector used to check return selectors from hooks.\n/// @dev parseSelector also is used to parse the expected selector\n/// For parsing hook returns, note that all hooks return either bytes4 or (bytes4, 32-byte-delta) or (bytes4, 32-byte-delta, uint24).\nlibrary ParseBytes {\n    function parseSelector(bytes memory result) internal pure returns (bytes4 selector) {\n        // equivalent: (selector,) = abi.decode(result, (bytes4, int256));\n        assembly (\"memory-safe\") {\n            selector := mload(add(result, 0x20))\n        }\n    }\n\n    function parseFee(bytes memory result) internal pure returns (uint24 lpFee) {\n        // equivalent: (,, lpFee) = abi.decode(result, (bytes4, int256, uint24));\n        assembly (\"memory-safe\") {\n            lpFee := mload(add(result, 0x60))\n        }\n    }\n\n    function parseReturnDelta(bytes memory result) internal pure returns (int256 hookReturn) {\n        // equivalent: (, hookReturnDelta) = abi.decode(result, (bytes4, int256));\n        assembly (\"memory-safe\") {\n            hookReturn := mload(add(result, 0x40))\n        }\n    }\n}\n"},"lib/v4-periphery/lib/v4-core/src/libraries/BitMath.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title BitMath\n/// @dev This library provides functionality for computing bit properties of an unsigned integer\n/// @author Solady (https://github.com/Vectorized/solady/blob/8200a70e8dc2a77ecb074fc2e99a2a0d36547522/src/utils/LibBit.sol)\nlibrary BitMath {\n    /// @notice Returns the index of the most significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @param x the value for which to compute the most significant bit, must be greater than 0\n    /// @return r the index of the most significant bit\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        assembly (\"memory-safe\") {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0x0706060506020500060203020504000106050205030304010505030400000000))\n        }\n    }\n\n    /// @notice Returns the index of the least significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @param x the value for which to compute the least significant bit, must be greater than 0\n    /// @return r the index of the least significant bit\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        assembly (\"memory-safe\") {\n            // Isolate the least significant bit.\n            x := and(x, sub(0, x))\n            // For the upper 3 bits of the result, use a De Bruijn-like lookup.\n            // Credit to adhusson: https://blog.adhusson.com/cheap-find-first-set-evm/\n            // forgefmt: disable-next-item\n            r := shl(5, shr(252, shl(shl(2, shr(250, mul(x,\n                0xb6db6db6ddddddddd34d34d349249249210842108c6318c639ce739cffffffff))),\n                0x8040405543005266443200005020610674053026020000107506200176117077)))\n            // For the lower 5 bits of the result, use a De Bruijn lookup.\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(div(0xd76453e0, shr(r, x)), 0x1f),\n                0x001f0d1e100c1d070f090b19131c1706010e11080a1a141802121b1503160405))\n        }\n    }\n}\n"},"lib/solady/src/utils/LibBit.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for bit twiddling and boolean operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibBit.sol)\n/// @author Inspired by (https://graphics.stanford.edu/~seander/bithacks.html)\nlibrary LibBit {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  BIT TWIDDLING OPERATIONS                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Find last set.\n    /// Returns the index of the most significant bit of `x`,\n    /// counting from the least significant bit position.\n    /// If `x` is zero, returns 256.\n    function fls(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := or(shl(8, iszero(x)), shl(7, lt(0xffffffffffffffffffffffffffffffff, x)))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0x0706060506020504060203020504030106050205030304010505030400000000))\n        }\n    }\n\n    /// @dev Count leading zeros.\n    /// Returns the number of zeros preceding the most significant one bit.\n    /// If `x` is zero, returns 256.\n    function clz(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := add(xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff)), iszero(x))\n        }\n    }\n\n    /// @dev Find first set.\n    /// Returns the index of the least significant bit of `x`,\n    /// counting from the least significant bit position.\n    /// If `x` is zero, returns 256.\n    /// Equivalent to `ctz` (count trailing zeros), which gives\n    /// the number of zeros following the least significant one bit.\n    function ffs(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Isolate the least significant bit.\n            x := and(x, add(not(x), 1))\n            // For the upper 3 bits of the result, use a De Bruijn-like lookup.\n            // Credit to adhusson: https://blog.adhusson.com/cheap-find-first-set-evm/\n            // forgefmt: disable-next-item\n            r := shl(5, shr(252, shl(shl(2, shr(250, mul(x,\n                0xb6db6db6ddddddddd34d34d349249249210842108c6318c639ce739cffffffff))),\n                0x8040405543005266443200005020610674053026020000107506200176117077)))\n            // For the lower 5 bits of the result, use a De Bruijn lookup.\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(div(0xd76453e0, shr(r, x)), 0x1f),\n                0x001f0d1e100c1d070f090b19131c1706010e11080a1a141802121b1503160405))\n        }\n    }\n\n    /// @dev Returns the number of set bits in `x`.\n    function popCount(uint256 x) internal pure returns (uint256 c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let max := not(0)\n            let isMax := eq(x, max)\n            x := sub(x, and(shr(1, x), div(max, 3)))\n            x := add(and(x, div(max, 5)), and(shr(2, x), div(max, 5)))\n            x := and(add(x, shr(4, x)), div(max, 17))\n            c := or(shl(8, isMax), shr(248, mul(x, div(max, 255))))\n        }\n    }\n\n    /// @dev Returns whether `x` is a power of 2.\n    function isPo2(uint256 x) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `x && !(x & (x - 1))`.\n            result := iszero(add(and(x, sub(x, 1)), iszero(x)))\n        }\n    }\n\n    /// @dev Returns `x` reversed at the bit level.\n    function reverseBits(uint256 x) internal pure returns (uint256 r) {\n        uint256 m0 = 0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f;\n        uint256 m1 = m0 ^ (m0 << 2);\n        uint256 m2 = m1 ^ (m1 << 1);\n        r = reverseBytes(x);\n        r = (m2 & (r >> 1)) | ((m2 & r) << 1);\n        r = (m1 & (r >> 2)) | ((m1 & r) << 2);\n        r = (m0 & (r >> 4)) | ((m0 & r) << 4);\n    }\n\n    /// @dev Returns `x` reversed at the byte level.\n    function reverseBytes(uint256 x) internal pure returns (uint256 r) {\n        unchecked {\n            // Computing masks on-the-fly reduces bytecode size by about 200 bytes.\n            uint256 m0 = 0x100000000000000000000000000000001 * (~toUint(x == uint256(0)) >> 192);\n            uint256 m1 = m0 ^ (m0 << 32);\n            uint256 m2 = m1 ^ (m1 << 16);\n            uint256 m3 = m2 ^ (m2 << 8);\n            r = (m3 & (x >> 8)) | ((m3 & x) << 8);\n            r = (m2 & (r >> 16)) | ((m2 & r) << 16);\n            r = (m1 & (r >> 32)) | ((m1 & r) << 32);\n            r = (m0 & (r >> 64)) | ((m0 & r) << 64);\n            r = (r >> 128) | (r << 128);\n        }\n    }\n\n    /// @dev Returns the common prefix of `x` and `y` at the bit level.\n    function commonBitPrefix(uint256 x, uint256 y) internal pure returns (uint256) {\n        unchecked {\n            uint256 s = 256 - clz(x ^ y);\n            return (x >> s) << s;\n        }\n    }\n\n    /// @dev Returns the common prefix of `x` and `y` at the nibble level.\n    function commonNibblePrefix(uint256 x, uint256 y) internal pure returns (uint256) {\n        unchecked {\n            uint256 s = (64 - (clz(x ^ y) >> 2)) << 2;\n            return (x >> s) << s;\n        }\n    }\n\n    /// @dev Returns the common prefix of `x` and `y` at the byte level.\n    function commonBytePrefix(uint256 x, uint256 y) internal pure returns (uint256) {\n        unchecked {\n            uint256 s = (32 - (clz(x ^ y) >> 3)) << 3;\n            return (x >> s) << s;\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     BOOLEAN OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // A Solidity bool on the stack or memory is represented as a 256-bit word.\n    // Non-zero values are true, zero is false.\n    // A clean bool is either 0 (false) or 1 (true) under the hood.\n    // Usually, if not always, the bool result of a regular Solidity expression,\n    // or the argument of a public/external function will be a clean bool.\n    // You can usually use the raw variants for more performance.\n    // If uncertain, test (best with exact compiler settings).\n    // Or use the non-raw variants (compiler can sometimes optimize out the double `iszero`s).\n\n    /// @dev Returns `x & y`. Inputs must be clean.\n    function rawAnd(bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := and(x, y)\n        }\n    }\n\n    /// @dev Returns `x & y`.\n    function and(bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := and(iszero(iszero(x)), iszero(iszero(y)))\n        }\n    }\n\n    /// @dev Returns `x | y`. Inputs must be clean.\n    function rawOr(bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(x, y)\n        }\n    }\n\n    /// @dev Returns `x | y`.\n    function or(bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(iszero(iszero(x)), iszero(iszero(y)))\n        }\n    }\n\n    /// @dev Returns 1 if `b` is true, else 0. Input must be clean.\n    function rawToUint(bool b) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := b\n        }\n    }\n\n    /// @dev Returns 1 if `b` is true, else 0.\n    function toUint(bool b) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := iszero(iszero(b))\n        }\n    }\n}\n"}},"settings":{"remappings":["solady/src/=lib/solady/src/","v4-core/src/=lib/v4-periphery/lib/v4-core/src/","v4-periphery/src/=lib/v4-periphery/src/","forge-std/=lib/forge-std/src/","solmate/=lib/solmate/","core/src/=src/","@ensdomains/=lib/v4-periphery/lib/v4-core/node_modules/@ensdomains/","@openzeppelin/=lib/v4-periphery/lib/v4-core/lib/openzeppelin-contracts/","@uniswap/v4-core/=lib/v4-periphery/lib/v4-core/","ds-test/=lib/solmate/lib/ds-test/src/","erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/","forge-gas-snapshot/=lib/v4-periphery/lib/permit2/lib/forge-gas-snapshot/src/","halmos-cheatcodes/=lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/","hardhat/=lib/v4-periphery/lib/v4-core/node_modules/hardhat/","openzeppelin-contracts/=lib/openzeppelin-contracts/","permit2/=lib/v4-periphery/lib/permit2/","super-sol/=lib/super-sol/src/","transient-goodies/=lib/transient-goodies/src/"],"optimizer":{"enabled":true,"runs":22000},"metadata":{"useLiteralContent":false,"bytecodeHash":"none","appendCBOR":true},"outputSelection":{"*":{"":["ast"],"*":["abi","evm.bytecode.object","evm.bytecode.sourceMap","evm.bytecode.linkReferences","evm.deployedBytecode.object","evm.deployedBytecode.sourceMap","evm.deployedBytecode.linkReferences","evm.deployedBytecode.immutableReferences","evm.methodIdentifiers","metadata","storageLayout"]}},"evmVersion":"cancun","viaIR":false,"libraries":{}}}
